------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_19.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_19.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_19.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  3000 ????				      include	"multisprite.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????	       00 80	   missile0x  =	$80
      4  3000 ????	       00 81	   missile1x  =	$81
      5  3000 ????	       00 82	   ballx      =	$82
      6  3000 ????
      7  3000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  3000 ????
      9  3000 ????	       00 83	   SpriteIndex =	$83
     10  3000 ????
     11  3000 ????	       00 84	   player0x   =	$84
     12  3000 ????	       00 85	   NewSpriteX =	$85	;		X position
     13  3000 ????	       00 85	   player1x   =	$85
     14  3000 ????	       00 86	   player2x   =	$86
     15  3000 ????	       00 87	   player3x   =	$87
     16  3000 ????	       00 88	   player4x   =	$88
     17  3000 ????	       00 89	   player5x   =	$89
     18  3000 ????
     19  3000 ????	       00 8a	   objecty    =	$8A
     20  3000 ????	       00 8a	   missile0y  =	$8A
     21  3000 ????	       00 8b	   missile1y  =	$8B
     22  3000 ????	       00 8c	   bally      =	$8C
     23  3000 ????
     24  3000 ????	       00 8d	   player0y   =	$8D
     25  3000 ????	       00 8e	   NewSpriteY =	$8E	;		Y position
     26  3000 ????	       00 8e	   player1y   =	$8E
     27  3000 ????	       00 8f	   player2y   =	$8F
     28  3000 ????	       00 90	   player3y   =	$90
     29  3000 ????	       00 91	   player4y   =	$91
     30  3000 ????	       00 92	   player5y   =	$92
     31  3000 ????
     32  3000 ????	       00 93	   NewNUSIZ   =	$93
     33  3000 ????	       00 93	   _NUSIZ1    =	$93
     34  3000 ????	       00 94	   NUSIZ2     =	$94
     35  3000 ????	       00 95	   NUSIZ3     =	$95
     36  3000 ????	       00 96	   NUSIZ4     =	$96
     37  3000 ????	       00 97	   NUSIZ5     =	$97
     38  3000 ????
     39  3000 ????	       00 98	   NewCOLUP1  =	$98
     40  3000 ????	       00 98	   _COLUP1    =	$98
     41  3000 ????	       00 99	   COLUP2     =	$99
     42  3000 ????	       00 9a	   COLUP3     =	$9A
     43  3000 ????	       00 9b	   COLUP4     =	$9B
     44  3000 ????	       00 9c	   COLUP5     =	$9C
     45  3000 ????
     46  3000 ????	       00 9d	   SpriteGfxIndex =	$9D
     47  3000 ????
     48  3000 ????	       00 a2	   player0pointer =	$A2
     49  3000 ????	       00 a2	   player0pointerlo =	$A2
     50  3000 ????	       00 a3	   player0pointerhi =	$A3
     51  3000 ????
     52  3000 ????						;P0Top = temp5
     53  3000 ????	       00 cf	   P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  3000 ????	       00 a4	   P0Bottom   =	$A4
     55  3000 ????	       00 a5	   P1Bottom   =	$A5
     56  3000 ????
     57  3000 ????	       00 a6	   player1pointerlo =	$A6
     58  3000 ????	       00 a7	   player2pointerlo =	$A7
     59  3000 ????	       00 a8	   player3pointerlo =	$A8
     60  3000 ????	       00 a9	   player4pointerlo =	$A9
     61  3000 ????	       00 aa	   player5pointerlo =	$AA
     62  3000 ????
     63  3000 ????	       00 ab	   player1pointerhi =	$AB
     64  3000 ????	       00 ac	   player2pointerhi =	$AC
     65  3000 ????	       00 ad	   player3pointerhi =	$AD
     66  3000 ????	       00 ae	   player4pointerhi =	$AE
     67  3000 ????	       00 af	   player5pointerhi =	$AF
     68  3000 ????
     69  3000 ????	       00 b0	   player0height =	$B0
     70  3000 ????	       00 b1	   spriteheight =	$B1	; heights of multiplexed player sprite
     71  3000 ????	       00 b1	   player1height =	$B1
     72  3000 ????	       00 b2	   player2height =	$B2
     73  3000 ????	       00 b3	   player3height =	$B3
     74  3000 ????	       00 b4	   player4height =	$B4
     75  3000 ????	       00 b5	   player5height =	$B5
     76  3000 ????
     77  3000 ????	       00 b6	   PF1temp1   =	$B6
     78  3000 ????	       00 b7	   PF1temp2   =	$B7
     79  3000 ????	       00 b8	   PF2temp1   =	$B8
     80  3000 ????	       00 b9	   PF2temp2   =	$B9
     81  3000 ????
     82  3000 ????	       00 ba	   pfpixelheight =	$BA
     83  3000 ????
     84  3000 ????						; playfield is now a pointer to graphics
     85  3000 ????	       00 bb	   playfield  =	$BB
     86  3000 ????	       00 bb	   PF1pointer =	$BB
     87  3000 ????
     88  3000 ????	       00 bd	   PF2pointer =	$BD
     89  3000 ????
     90  3000 ????	       00 bf	   statusbarlength =	$BF
     91  3000 ????	       00 bf	   aux3       =	$BF
     92  3000 ????
     93  3000 ????	       00 c0	   lifecolor  =	$C0
     94  3000 ????	       00 c0	   pfscorecolor =	$C0
     95  3000 ????	       00 c0	   aux4       =	$C0
     96  3000 ????
     97  3000 ????						;P1display = temp2 ; temp2 and temp3
     98  3000 ????	       00 cc	   P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  3000 ????	       00 c1	   lifepointer =	$c1
    100  3000 ????	       00 c2	   lives      =	$c2
    101  3000 ????	       00 c1	   pfscore1   =	$c1
    102  3000 ????	       00 c2	   pfscore2   =	$c2
    103  3000 ????	       00 c1	   aux5       =	$c1
    104  3000 ????	       00 c2	   aux6       =	$c2
    105  3000 ????
    106  3000 ????	       00 c3	   playfieldpos =	$C3
    107  3000 ????
    108  3000 ????						;RepoLine = temp4
    109  3000 ????	       00 ce	   RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  3000 ????
    111  3000 ????	       00 c4	   pfheight   =	$C4
    112  3000 ????	       00 c5	   scorepointers =	$C5
    113  3000 ????
    114  3000 ????	       00 cb	   temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  3000 ????	       00 cc	   temp2      =	$CC	;are obliterated when drawscreen is called.
    116  3000 ????	       00 cd	   temp3      =	$CD
    117  3000 ????	       00 ce	   temp4      =	$CE
    118  3000 ????	       00 cf	   temp5      =	$CF
    119  3000 ????	       00 d0	   temp6      =	$D0
    120  3000 ????	       00 d1	   temp7      =	$D1	; This is used to aid in bankswitching
    121  3000 ????
    122  3000 ????	       00 d2	   score      =	$D2
    123  3000 ????	       00 d5	   scorecolor =	$D5	;need to find other places for these, possibly...
    124  3000 ????	       00 d6	   rand       =	$D6
    125  3000 ????
    126  3000 ????
    127  3000 ????
    128  3000 ????	       00 d7	   A	      =	$d7
    129  3000 ????	       00 d7	   a	      =	$d7
    130  3000 ????	       00 d8	   B	      =	$d8
    131  3000 ????	       00 d8	   b	      =	$d8
    132  3000 ????	       00 d9	   C	      =	$d9
    133  3000 ????	       00 d9	   c	      =	$d9
    134  3000 ????	       00 da	   D	      =	$da
    135  3000 ????	       00 da	   d	      =	$da
    136  3000 ????	       00 db	   E	      =	$db
    137  3000 ????	       00 db	   e	      =	$db
    138  3000 ????	       00 dc	   F	      =	$dc
    139  3000 ????	       00 dc	   f	      =	$dc
    140  3000 ????	       00 dd	   G	      =	$dd
    141  3000 ????	       00 dd	   g	      =	$dd
    142  3000 ????	       00 de	   H	      =	$de
    143  3000 ????	       00 de	   h	      =	$de
    144  3000 ????	       00 df	   I	      =	$df
    145  3000 ????	       00 df	   i	      =	$df
    146  3000 ????	       00 e0	   J	      =	$e0
    147  3000 ????	       00 e0	   j	      =	$e0
    148  3000 ????	       00 e1	   K	      =	$e1
    149  3000 ????	       00 e1	   k	      =	$e1
    150  3000 ????	       00 e2	   L	      =	$e2
    151  3000 ????	       00 e2	   l	      =	$e2
    152  3000 ????	       00 e3	   M	      =	$e3
    153  3000 ????	       00 e3	   m	      =	$e3
    154  3000 ????	       00 e4	   N	      =	$e4
    155  3000 ????	       00 e4	   n	      =	$e4
    156  3000 ????	       00 e5	   O	      =	$e5
    157  3000 ????	       00 e5	   o	      =	$e5
    158  3000 ????	       00 e6	   P	      =	$e6
    159  3000 ????	       00 e6	   p	      =	$e6
    160  3000 ????	       00 e7	   Q	      =	$e7
    161  3000 ????	       00 e7	   q	      =	$e7
    162  3000 ????	       00 e8	   R	      =	$e8
    163  3000 ????	       00 e8	   r	      =	$e8
    164  3000 ????	       00 e9	   S	      =	$e9
    165  3000 ????	       00 e9	   s	      =	$e9
    166  3000 ????	       00 ea	   T	      =	$ea
    167  3000 ????	       00 ea	   t	      =	$ea
    168  3000 ????	       00 eb	   U	      =	$eb
    169  3000 ????	       00 eb	   u	      =	$eb
    170  3000 ????	       00 ec	   V	      =	$ec
    171  3000 ????	       00 ec	   v	      =	$ec
    172  3000 ????	       00 ed	   W	      =	$ed
    173  3000 ????	       00 ed	   w	      =	$ed
    174  3000 ????	       00 ee	   X	      =	$ee
    175  3000 ????	       00 ee	   x	      =	$ee
    176  3000 ????	       00 ef	   Y	      =	$ef
    177  3000 ????	       00 ef	   y	      =	$ef
    178  3000 ????	       00 f0	   Z	      =	$f0
    179  3000 ????	       00 f0	   z	      =	$f0
    180  3000 ????
    181  3000 ????	       00 f1	   spritesort =	$f1	; helps with flickersort
    182  3000 ????	       00 f2	   spritesort2 =	$f2	; helps with flickersort
    183  3000 ????	       00 f3	   spritesort3 =	$f3
    184  3000 ????	       00 f4	   spritesort4 =	$f4
    185  3000 ????	       00 f5	   spritesort5 =	$f5
    186  3000 ????
    187  3000 ????	       00 f6	   stack1     =	$f6
    188  3000 ????	       00 f7	   stack2     =	$f7
    189  3000 ????	       00 f8	   stack3     =	$f8
    190  3000 ????	       00 f9	   stack4     =	$f9
    191  3000 ????						; the stack bytes above may be used in the kernel
    192  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  3000 ????
    194  3000 ????				      MAC	return
    195  3000 ????				      ifnconst	bankswitch
    196  3000 ????				      rts
    197  3000 ????				      else
    198  3000 ????				      jmp	BS_return
    199  3000 ????				      endif
    200  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_19.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 e9	   tur_anim_frame =	s
      5  3000 ????	       00 e8	   tur_anim_playing =	r
      6  3000 ????	       00 e7	   tur_hit    =	q
      7  3000 ????	       00 e3	   tur_fired  =	m
      8  3000 ????	       00 e0	   shot_y     =	j
      9  3000 ????	       00 df	   shot_x     =	i
     10  3000 ????	       00 db	   tur_y      =	e
     11  3000 ????	       00 da	   tur_x      =	d
     12  3000 ????	       00 e5	   inv_blast_delay =	o
     13  3000 ????	       00 e4	   inv_hit    =	n
     14  3000 ????	       00 e2	   inv_fired  =	l
     15  3000 ????	       00 e1	   inv_fire_delay =	k
     16  3000 ????	       00 de	   inv_shot_y =	h
     17  3000 ????	       00 dd	   inv_shot_x =	g
     18  3000 ????	       00 dc	   inv_dir    =	f
     19  3000 ????	       00 d9	   inv_delay  =	c
     20  3000 ????	       00 d8	   inv_y      =	b
     21  3000 ????	       00 d7	   inv_x      =	a
     22  3000 ????	       00 e6	   reducing_lives =	p
     23  3000 ????	       00 00	   pfscore    =	0
     24  3000 ????
     25  3000 ????	       00 01	   bs_mask    =	1
     26  3000 ????	       00 08	   bankswitch =	8
     27  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
     28  3000 ????	       00 01	   multisprite =	1
     29  3000 ????	       00 01	   no_blank_lines =	1
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_19.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	234	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .L00 		;  includesfile multisprite_bankswitch.inc
     57  1000
     58  1000				   .L01 		;  set kernel_options no_blank_lines
     59  1000
     60  1000				   .
     61  1000							; 
     62  1000
     63  1000				   .L02 		;  set kernel multisprite
     64  1000
     65  1000				   .L03 		;  set romsize 8k
     66  1000
     67  1000				   .
     68  1000							; 
     69  1000
     70  1000				   .
     71  1000							; 
     72  1000
     73  1000				   .L04 		;  const pfscore  =  0
     74  1000
     75  1000				   .
     76  1000							; 
     77  1000
     78  1000				   .
     79  1000							; 
     80  1000
     81  1000				   .
     82  1000							; 
     83  1000
     84  1000				   .L05 		;  dim reducing_lives	=  p  :  p  =  0
     85  1000
     86  1000		       a9 00		      LDA	#0
     87  1002		       85 e6		      STA	p
     88  1004				   .
     89  1004							; 
     90  1004
     91  1004				   .L06 		;  pfscore2  =  %00101010
     92  1004
     93  1004		       a9 2a		      LDA	#%00101010
     94  1006		       85 c2		      STA	pfscore2
     95  1008				   .
     96  1008							; 
     97  1008
     98  1008				   .
     99  1008							; 
    100  1008
    101  1008				   .L07 		;  dim inv_x  =  a  :	a  =  84
    102  1008
    103  1008		       a9 54		      LDA	#84
    104  100a		       85 d7		      STA	a
    105  100c				   .L08 		;  dim inv_y  =  b  :	b  =  76
    106  100c
    107  100c		       a9 4c		      LDA	#76
    108  100e		       85 d8		      STA	b
    109  1010				   .L09 		;  dim inv_delay  =  c  :  c  =  0
    110  1010
    111  1010		       a9 00		      LDA	#0
    112  1012		       85 d9		      STA	c
    113  1014				   .L010		;  dim inv_dir  =  f  :  f  =	1
    114  1014
    115  1014		       a9 01		      LDA	#1
    116  1016		       85 dc		      STA	f
    117  1018				   .L011		;  dim inv_shot_x  =  g  :  g	=  inv_x
    118  1018
    119  1018		       a5 d7		      LDA	inv_x
    120  101a		       85 dd		      STA	g
    121  101c				   .L012		;  dim inv_shot_y  =  h  :  h	=  inv_y
    122  101c
    123  101c		       a5 d8		      LDA	inv_y
    124  101e		       85 de		      STA	h
    125  1020				   .L013		;  dim inv_fire_delay	=  k  :  k  =  0
    126  1020
    127  1020		       a9 00		      LDA	#0
    128  1022		       85 e1		      STA	k
    129  1024				   .L014		;  dim inv_fired  =  l  :  l  =  0
    130  1024
    131  1024		       a9 00		      LDA	#0
    132  1026		       85 e2		      STA	l
    133  1028				   .L015		;  dim inv_hit  =  n  :  n  =	0
    134  1028
    135  1028		       a9 00		      LDA	#0
    136  102a		       85 e4		      STA	n
    137  102c				   .L016		;  dim inv_blast_delay  =  o  :  o  =	0
    138  102c
    139  102c		       a9 00		      LDA	#0
    140  102e		       85 e5		      STA	o
    141  1030				   .
    142  1030							; 
    143  1030
    144  1030				   .
    145  1030							; 
    146  1030
    147  1030				   .L017		;  dim tur_x  =  d  :	d  =  84
    148  1030
    149  1030		       a9 54		      LDA	#84
    150  1032		       85 da		      STA	d
    151  1034				   .L018		;  dim tur_y  =  e  :	e  =  14
    152  1034
    153  1034		       a9 0e		      LDA	#14
    154  1036		       85 db		      STA	e
    155  1038				   .L019		;  dim shot_x	=  i  :  i  =  tur_x
    156  1038
    157  1038		       a5 da		      LDA	tur_x
    158  103a		       85 df		      STA	i
    159  103c				   .L020		;  dim shot_y	=  j  :  j  =  tur_y
    160  103c
    161  103c		       a5 db		      LDA	tur_y
    162  103e		       85 e0		      STA	j
    163  1040				   .L021		;  dim tur_fired  =  m  :  m  =  0
    164  1040
    165  1040		       a9 00		      LDA	#0
    166  1042		       85 e3		      STA	m
    167  1044				   .L022		;  dim tur_hit  =  q  :  q  =	0
    168  1044
    169  1044		       a9 00		      LDA	#0
    170  1046		       85 e7		      STA	q
    171  1048				   .L023		;  dim tur_anim_playing  =  r	:  r  =  0
    172  1048
    173  1048		       a9 00		      LDA	#0
    174  104a		       85 e8		      STA	r
    175  104c				   .L024		;  dim tur_anim_frame	=  s  :  s  =  0
    176  104c
    177  104c		       a9 00		      LDA	#0
    178  104e		       85 e9		      STA	s
    179  1050				   .
    180  1050							; 
    181  1050
    182  1050				   .
    183  1050							; 
    184  1050
    185  1050				   .
    186  1050							; 
    187  1050
    188  1050				   .
    189  1050							; 
    190  1050
    191  1050				   .
    192  1050							; 
    193  1050
    194  1050				   .main
    195  1050							; main
    196  1050
    197  1050				   .
    198  1050							; 
    199  1050
    200  1050				   .L025		;  gosub draw__move_turret
    201  1050
    202  1050		       20 85 d2 	      jsr	.draw__move_turret
    203  1053
    204  1053				   .L026		;  gosub draw__move_turret_shot
    205  1053
    206  1053		       20 ca d2 	      jsr	.draw__move_turret_shot
    207  1056
    208  1056				   .L027		;  gosub draw__move_invader
    209  1056
    210  1056		       20 85 d0 	      jsr	.draw__move_invader
    211  1059
    212  1059				   .L028		;  gosub draw__move_inv_shot
    213  1059
    214  1059		       20 57 d1 	      jsr	.draw__move_inv_shot
    215  105c
    216  105c				   .L029		;  gosub col_shot_inv
    217  105c
    218  105c		       20 d6 d1 	      jsr	.col_shot_inv
    219  105f
    220  105f				   .L030		;  gosub col_inv_shot_turret
    221  105f
    222  105f		       20 31 d3 	      jsr	.col_inv_shot_turret
    223  1062
    224  1062				   .
    225  1062							; 
    226  1062
    227  1062				   .
    228  1062							; 
    229  1062
    230  1062				   .
    231  1062							; 
    232  1062
    233  1062				   .
    234  1062							; 
    235  1062
    236  1062				   .
    237  1062							; 
    238  1062
    239  1062				   .L031		;  pfscorecolor  =  196
    240  1062
    241  1062		       a9 c4		      LDA	#196
    242  1064		       85 c0		      STA	pfscorecolor
    243  1066				   .
    244  1066							; 
    245  1066
    246  1066				   .
    247  1066							; 
    248  1066
    249  1066				   .L032		;  scorecolor	=  152
    250  1066
    251  1066		       a9 98		      LDA	#152
    252  1068		       85 d5		      STA	scorecolor
    253  106a				   .
    254  106a							; 
    255  106a
    256  106a				   .
    257  106a							; 
    258  106a
    259  106a				   .L033		;  drawscreen
    260  106a
    261  106a		       85 d1		      sta	temp7
    262  106c		       a9 d0		      lda	#>(ret_point1-1)
    263  106e		       48		      pha
    264  106f		       a9 81		      lda	#<(ret_point1-1)
    265  1071		       48		      pha
    266  1072		       a9 f0		      lda	#>(drawscreen-1)
    267  1074		       48		      pha
    268  1075		       a9 39		      lda	#<(drawscreen-1)
    269  1077		       48		      pha
    270  1078		       a5 d1		      lda	temp7
    271  107a		       48		      pha
    272  107b		       8a		      txa
    273  107c		       48		      pha
    274  107d		       a2 02		      ldx	#2
    275  107f		       4c eb ff 	      jmp	BS_jsr
    276  1082				   ret_point1
    277  1082				   .
    278  1082							; 
    279  1082
    280  1082				   .L034		;  goto main
    281  1082
    282  1082		       4c 50 d0 	      jmp	.main
    283  1085
    284  1085				   .
    285  1085							; 
    286  1085
    287  1085				   .
    288  1085							; 
    289  1085
    290  1085				   .
    291  1085							; 
    292  1085
    293  1085				   .
    294  1085							; 
    295  1085
    296  1085				   .
    297  1085							; 
    298  1085
    299  1085				   .
    300  1085							; 
    301  1085
    302  1085				   .
    303  1085							; 
    304  1085
    305  1085				   .draw__move_invader
    306  1085							; draw__move_invader
    307  1085
    308  1085				   .
    309  1085							; 
    310  1085
    311  1085				   .L035		;  inv_delay  =  inv_delay  +	1
    312  1085
    313  1085		       e6 d9		      INC	inv_delay
    314  1087				   .
    315  1087							; 
    316  1087
    317  1087				   .
    318  1087							; 
    319  1087
    320  1087				   .L036		;  if inv_delay  =  15  &&  inv_hit  =  0 then player0:  
    321  1087
    322  1087		       a5 d9		      LDA	inv_delay
    323  1089		       c9 0f		      CMP	#15
    324  108b		       d0 12		      BNE	.skipL036
    325  108d				   .condpart0
    326  108d		       a5 e4		      LDA	inv_hit
    327  108f		       c9 00		      CMP	#0
    328  1091		       d0 0c		      BNE	.skip0then
    329  1093				   .condpart1
    330  1093		       a2 5a		      LDX	#<player1then_0
    331  1095		       86 a2		      STX	player0pointerlo
    332  1097		       a9 f4		      LDA	#>player1then_0
    333  1099		       85 a3		      STA	player0pointerhi
    334  109b		       a9 09		      LDA	#9
    335  109d		       85 b0		      STA	player0height
    336  109f				   .skip0then
    337  109f				   .skipL036
    338  109f				   .
    339  109f							; 
    340  109f
    341  109f				   .
    342  109f							; 
    343  109f
    344  109f				   .L037		;  if inv_delay  =  30  &&  inv_hit  =  0 then player0:  
    345  109f
    346  109f		       a5 d9		      LDA	inv_delay
    347  10a1		       c9 1e		      CMP	#30
    348  10a3		       d0 12		      BNE	.skipL037
    349  10a5				   .condpart2
    350  10a5		       a5 e4		      LDA	inv_hit
    351  10a7		       c9 00		      CMP	#0
    352  10a9		       d0 0c		      BNE	.skip2then
    353  10ab				   .condpart3
    354  10ab		       a2 63		      LDX	#<player3then_0
    355  10ad		       86 a2		      STX	player0pointerlo
    356  10af		       a9 f4		      LDA	#>player3then_0
    357  10b1		       85 a3		      STA	player0pointerhi
    358  10b3		       a9 09		      LDA	#9
    359  10b5		       85 b0		      STA	player0height
    360  10b7				   .skip2then
    361  10b7				   .skipL037
    362  10b7				   .
    363  10b7							; 
    364  10b7
    365  10b7				   .L038		;  if inv_delay  >  30 then inv_delay	=  0
    366  10b7
    367  10b7		       a9 1e		      LDA	#30
    368  10b9		       c5 d9		      CMP	inv_delay
    369  10bb		       b0 04		      BCS	.skipL038
    370  10bd				   .condpart4
    371  10bd		       a9 00		      LDA	#0
    372  10bf		       85 d9		      STA	inv_delay
    373  10c1				   .skipL038
    374  10c1				   .
    375  10c1							; 
    376  10c1
    377  10c1				   .
    378  10c1							; 
    379  10c1
    380  10c1				   .L039		;  COLUP0  =  52
    381  10c1
    382  10c1		       a9 34		      LDA	#52
    383  10c3		       85 06		      STA	COLUP0
    384  10c5				   .
    385  10c5							; 
    386  10c5
    387  10c5				   .
    388  10c5							; 
    389  10c5
    390  10c5				   .L040		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  15 then inv_x  =  inv_x  +  1
    391  10c5
    392  10c5		       a5 e4		      LDA	inv_hit
    393  10c7		       c9 00		      CMP	#0
    394  10c9		       d0 0e		      BNE	.skipL040
    395  10cb				   .condpart5
    396  10cb		       a5 dc		      LDA	inv_dir
    397  10cd		       c9 01		      CMP	#1
    398  10cf		       d0 08		      BNE	.skip5then
    399  10d1				   .condpart6
    400  10d1		       a5 d9		      LDA	inv_delay
    401  10d3		       c9 0f		      CMP	#15
    402  10d5		       d0 02		      BNE	.skip6then
    403  10d7				   .condpart7
    404  10d7		       e6 d7		      INC	inv_x
    405  10d9				   .skip6then
    406  10d9				   .skip5then
    407  10d9				   .skipL040
    408  10d9				   .L041		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  30 then inv_x  =  inv_x  +  1
    409  10d9
    410  10d9		       a5 e4		      LDA	inv_hit
    411  10db		       c9 00		      CMP	#0
    412  10dd		       d0 0e		      BNE	.skipL041
    413  10df				   .condpart8
    414  10df		       a5 dc		      LDA	inv_dir
    415  10e1		       c9 01		      CMP	#1
    416  10e3		       d0 08		      BNE	.skip8then
    417  10e5				   .condpart9
    418  10e5		       a5 d9		      LDA	inv_delay
    419  10e7		       c9 1e		      CMP	#30
    420  10e9		       d0 02		      BNE	.skip9then
    421  10eb				   .condpart10
    422  10eb		       e6 d7		      INC	inv_x
    423  10ed				   .skip9then
    424  10ed				   .skip8then
    425  10ed				   .skipL041
    426  10ed				   .
    427  10ed							; 
    428  10ed
    429  10ed				   .L042		;  if inv_x  >  143 then inv_dir  =  0  :  inv_x  =  143  :  inv_y  =	inv_y  -  5
    430  10ed
    431  10ed		       a9 8f		      LDA	#143
    432  10ef		       c5 d7		      CMP	inv_x
    433  10f1		       b0 0f		      BCS	.skipL042
    434  10f3				   .condpart11
    435  10f3		       a9 00		      LDA	#0
    436  10f5		       85 dc		      STA	inv_dir
    437  10f7		       a9 8f		      LDA	#143
    438  10f9		       85 d7		      STA	inv_x
    439  10fb		       a5 d8		      LDA	inv_y
    440  10fd		       38		      SEC
    441  10fe		       e9 05		      SBC	#5
    442  1100		       85 d8		      STA	inv_y
    443  1102				   .skipL042
    444  1102				   .
    445  1102							; 
    446  1102
    447  1102				   .
    448  1102							; 
    449  1102
    450  1102				   .L043		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  15 then inv_x  =  inv_x  -  1
    451  1102
    452  1102		       a5 e4		      LDA	inv_hit
    453  1104		       c9 00		      CMP	#0
    454  1106		       d0 0e		      BNE	.skipL043
    455  1108				   .condpart12
    456  1108		       a5 dc		      LDA	inv_dir
    457  110a		       c9 00		      CMP	#0
    458  110c		       d0 08		      BNE	.skip12then
    459  110e				   .condpart13
    460  110e		       a5 d9		      LDA	inv_delay
    461  1110		       c9 0f		      CMP	#15
    462  1112		       d0 02		      BNE	.skip13then
    463  1114				   .condpart14
    464  1114		       c6 d7		      DEC	inv_x
    465  1116				   .skip13then
    466  1116				   .skip12then
    467  1116				   .skipL043
    468  1116				   .L044		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  30 then inv_x  =  inv_x  -  1
    469  1116
    470  1116		       a5 e4		      LDA	inv_hit
    471  1118		       c9 00		      CMP	#0
    472  111a		       d0 0e		      BNE	.skipL044
    473  111c				   .condpart15
    474  111c		       a5 dc		      LDA	inv_dir
    475  111e		       c9 00		      CMP	#0
    476  1120		       d0 08		      BNE	.skip15then
    477  1122				   .condpart16
    478  1122		       a5 d9		      LDA	inv_delay
    479  1124		       c9 1e		      CMP	#30
    480  1126		       d0 02		      BNE	.skip16then
    481  1128				   .condpart17
    482  1128		       c6 d7		      DEC	inv_x
    483  112a				   .skip16then
    484  112a				   .skip15then
    485  112a				   .skipL044
    486  112a				   .
    487  112a							; 
    488  112a
    489  112a				   .L045		;  if inv_x  <  26 then inv_dir  =  1	:  inv_x  =  26  :  inv_y  =  inv_y  -	5
    490  112a
    491  112a		       a5 d7		      LDA	inv_x
    492  112c		       c9 1a		      CMP	#26
    493  112e		       b0 0f		      BCS	.skipL045
    494  1130				   .condpart18
    495  1130		       a9 01		      LDA	#1
    496  1132		       85 dc		      STA	inv_dir
    497  1134		       a9 1a		      LDA	#26
    498  1136		       85 d7		      STA	inv_x
    499  1138		       a5 d8		      LDA	inv_y
    500  113a		       38		      SEC
    501  113b		       e9 05		      SBC	#5
    502  113d		       85 d8		      STA	inv_y
    503  113f				   .skipL045
    504  113f				   .
    505  113f							; 
    506  113f
    507  113f				   .
    508  113f							; 
    509  113f
    510  113f				   .L046		;  player0x  =  inv_x	-  8  :  player0y  =  inv_y
    511  113f
    512  113f		       a5 d7		      LDA	inv_x
    513  1141		       38		      SEC
    514  1142		       e9 08		      SBC	#8
    515  1144		       85 84		      STA	player0x
    516  1146		       a5 d8		      LDA	inv_y
    517  1148		       85 8d		      STA	player0y
    518  114a				   .L047		;  return
    519  114a
    520  114a		       ba		      tsx
    521  114b		       b5 02		      lda	2,x	; check return address
    522  114d		       49 d1		      eor	#(>*)	; vs. current PCH
    523  114f		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    524  1151		       f0 03		      beq	*+5	; if equal, do normal return
    525  1153		       4c dd ff 	      JMP	BS_return
    526  1156		       60		      RTS
    527  1157				   .
    528  1157							; 
    529  1157
    530  1157				   .
    531  1157							; 
    532  1157
    533  1157				   .
    534  1157							; 
    535  1157
    536  1157				   .
    537  1157							; 
    538  1157
    539  1157				   .draw__move_inv_shot
    540  1157							; draw__move_inv_shot
    541  1157
    542  1157				   .
    543  1157							; 
    544  1157
    545  1157				   .L048		;  player2:
    546  1157
    547  1157		       a2 6c		      LDX	#<playerL048_2
    548  1159		       86 a7		      STX	player2pointerlo
    549  115b		       a9 f4		      LDA	#>playerL048_2
    550  115d		       85 ac		      STA	player2pointerhi
    551  115f		       a9 09		      LDA	#9
    552  1161		       85 b2		      STA	player2height
    553  1163				   .
    554  1163							; 
    555  1163
    556  1163				   .L049		;  COLUP2  =  14
    557  1163
    558  1163		       a9 0e		      LDA	#14
    559  1165		       85 99		      STA	COLUP2
    560  1167				   .
    561  1167							; 
    562  1167
    563  1167				   .L050		;  inv_fire_delay  =  inv_fire_delay  +  1
    564  1167
    565  1167		       e6 e1		      INC	inv_fire_delay
    566  1169				   .
    567  1169							; 
    568  1169
    569  1169				   .L051		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_shot_x  =  inv_x  :  inv_shot_y  =	inv_y  -  9
    570  1169
    571  1169		       a5 e2		      LDA	inv_fired
    572  116b		       c9 00		      CMP	#0
    573  116d		       d0 11		      BNE	.skipL051
    574  116f				   .condpart19
    575  116f		       a5 e1		      LDA	inv_fire_delay
    576  1171		       c9 b4		      CMP	#180
    577  1173		       d0 0b		      BNE	.skip19then
    578  1175				   .condpart20
    579  1175		       a5 d7		      LDA	inv_x
    580  1177		       85 dd		      STA	inv_shot_x
    581  1179		       a5 d8		      LDA	inv_y
    582  117b		       38		      SEC
    583  117c		       e9 09		      SBC	#9
    584  117e		       85 de		      STA	inv_shot_y
    585  1180				   .skip19then
    586  1180				   .skipL051
    587  1180				   .L052		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then player2x  =  inv_shot_x  :  player2y  =  inv_shot_y
    588  1180
    589  1180		       a5 e2		      LDA	inv_fired
    590  1182		       c9 00		      CMP	#0
    591  1184		       d0 0e		      BNE	.skipL052
    592  1186				   .condpart21
    593  1186		       a5 e1		      LDA	inv_fire_delay
    594  1188		       c9 b4		      CMP	#180
    595  118a		       d0 08		      BNE	.skip21then
    596  118c				   .condpart22
    597  118c		       a5 dd		      LDA	inv_shot_x
    598  118e		       85 86		      STA	player2x
    599  1190		       a5 de		      LDA	inv_shot_y
    600  1192		       85 8f		      STA	player2y
    601  1194				   .skip21then
    602  1194				   .skipL052
    603  1194				   .L053		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_fired  =  1
    604  1194
    605  1194		       a5 e2		      LDA	inv_fired
    606  1196		       c9 00		      CMP	#0
    607  1198		       d0 0a		      BNE	.skipL053
    608  119a				   .condpart23
    609  119a		       a5 e1		      LDA	inv_fire_delay
    610  119c		       c9 b4		      CMP	#180
    611  119e		       d0 04		      BNE	.skip23then
    612  11a0				   .condpart24
    613  11a0		       a9 01		      LDA	#1
    614  11a2		       85 e2		      STA	inv_fired
    615  11a4				   .skip23then
    616  11a4				   .skipL053
    617  11a4				   .
    618  11a4							; 
    619  11a4
    620  11a4				   .L054		;  if inv_fired  =  1 then inv_shot_y	=  inv_shot_y  -  2  :	player2y  =  inv_shot_y
    621  11a4
    622  11a4		       a5 e2		      LDA	inv_fired
    623  11a6		       c9 01		      CMP	#1
    624  11a8		       d0 0b		      BNE	.skipL054
    625  11aa				   .condpart25
    626  11aa		       a5 de		      LDA	inv_shot_y
    627  11ac		       38		      SEC
    628  11ad		       e9 02		      SBC	#2
    629  11af		       85 de		      STA	inv_shot_y
    630  11b1		       a5 de		      LDA	inv_shot_y
    631  11b3		       85 8f		      STA	player2y
    632  11b5				   .skipL054
    633  11b5				   .
    634  11b5							; 
    635  11b5
    636  11b5				   .L055		;  if inv_shot_y  <  12 then inv_fired  =  0  :  inv_fire_delay  =  0	:  inv_shot_y  =  88  :  player2y  =  inv_shot_y
    637  11b5
    638  11b5		       a5 de		      LDA	inv_shot_y
    639  11b7		       c9 0c		      CMP	#12
    640  11b9		       b0 0e		      BCS	.skipL055
    641  11bb				   .condpart26
    642  11bb		       a9 00		      LDA	#0
    643  11bd		       85 e2		      STA	inv_fired
    644  11bf		       85 e1		      STA	inv_fire_delay
    645  11c1		       a9 58		      LDA	#88
    646  11c3		       85 de		      STA	inv_shot_y
    647  11c5		       a5 de		      LDA	inv_shot_y
    648  11c7		       85 8f		      STA	player2y
    649  11c9				   .skipL055
    650  11c9				   .
    651  11c9							; 
    652  11c9
    653  11c9				   .L056		;  return
    654  11c9
    655  11c9		       ba		      tsx
    656  11ca		       b5 02		      lda	2,x	; check return address
    657  11cc		       49 d1		      eor	#(>*)	; vs. current PCH
    658  11ce		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    659  11d0		       f0 03		      beq	*+5	; if equal, do normal return
    660  11d2		       4c dd ff 	      JMP	BS_return
    661  11d5		       60		      RTS
    662  11d6				   .
    663  11d6							; 
    664  11d6
    665  11d6				   .
    666  11d6							; 
    667  11d6
    668  11d6				   .
    669  11d6							; 
    670  11d6
    671  11d6				   .
    672  11d6							; 
    673  11d6
    674  11d6				   .col_shot_inv
    675  11d6							; col_shot_inv
    676  11d6
    677  11d6				   .L057		;  if shot_x  +  3  >=  inv_x	&&  shot_x  +  3  <=  inv_x  +	6  &&  shot_y  >  inv_y then inv_hit  =  1
    678  11d6
    679  11d6							; complex condition detected
    680  11d6		       a5 df		      LDA	shot_x
    681  11d8		       18		      CLC
    682  11d9		       69 03		      ADC	#3
    683  11db							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
    684  11db		       c5 d7		      CMP	inv_x
    685  11dd		       90 1d		      BCC	.skipL057
    686  11df				   .condpart27
    687  11df							; complex condition detected
    688  11df		       a5 d7		      LDA	inv_x
    689  11e1		       18		      CLC
    690  11e2		       69 06		      ADC	#6
    691  11e4		       48		      PHA
    692  11e5		       a5 df		      LDA	shot_x
    693  11e7		       18		      CLC
    694  11e8		       69 03		      ADC	#3
    695  11ea		       48		      PHA
    696  11eb		       ba		      TSX
    697  11ec		       68		      PLA
    698  11ed		       68		      PLA
    699  11ee							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
    700  11ee		       d5 01		      CMP	1,x
    701  11f0		       90 0a		      BCC	.skip27then
    702  11f2				   .condpart28
    703  11f2		       a5 d8		      LDA	inv_y
    704  11f4		       c5 e0		      CMP	shot_y
    705  11f6		       b0 04		      BCS	.skip28then
    706  11f8				   .condpart29
    707  11f8		       a9 01		      LDA	#1
    708  11fa		       85 e4		      STA	inv_hit
    709  11fc				   .skip28then
    710  11fc				   .skip27then
    711  11fc				   .skipL057
    712  11fc				   .
    713  11fc							; 
    714  11fc
    715  11fc				   .L058		;  if inv_hit	=  1 then inv_blast_delay  =  inv_blast_delay  +  1
    716  11fc
    717  11fc		       a5 e4		      LDA	inv_hit
    718  11fe		       c9 01		      CMP	#1
    719  1200		       d0 02		      BNE	.skipL058
    720  1202				   .condpart30
    721  1202		       e6 e5		      INC	inv_blast_delay
    722  1204				   .skipL058
    723  1204				   .
    724  1204							; 
    725  1204
    726  1204				   .L059		;  if inv_blast_delay	>  30 then score  =  score  +  10  :  inv_hit  =  0  :	gosub reset_blast
    727  1204
    728  1204		       a9 1e		      LDA	#30
    729  1206		       c5 e5		      CMP	inv_blast_delay
    730  1208		       b0 1c		      BCS	.skipL059
    731  120a				   .condpart31
    732  120a		       f8		      SED
    733  120b		       18		      CLC
    734  120c		       a5 d4		      LDA	score+2
    735  120e		       69 10		      ADC	#$10
    736  1210		       85 d4		      STA	score+2
    737  1212		       a5 d3		      LDA	score+1
    738  1214		       69 00		      ADC	#$00
    739  1216		       85 d3		      STA	score+1
    740  1218		       a5 d2		      LDA	score
    741  121a		       69 00		      ADC	#$00
    742  121c		       85 d2		      STA	score
    743  121e		       d8		      CLD
    744  121f		       a9 00		      LDA	#0
    745  1221		       85 e4		      STA	inv_hit
    746  1223		       20 45 d2 	      jsr	.reset_blast
    747  1226
    748  1226				   .skipL059
    749  1226				   .
    750  1226							; 
    751  1226
    752  1226				   .L060		;  if inv_hit	=  1 then player0:  
    753  1226
    754  1226		       a5 e4		      LDA	inv_hit
    755  1228		       c9 01		      CMP	#1
    756  122a		       d0 0c		      BNE	.skipL060
    757  122c				   .condpart32
    758  122c		       a2 74		      LDX	#<player32then_0
    759  122e		       86 a2		      STX	player0pointerlo
    760  1230		       a9 f4		      LDA	#>player32then_0
    761  1232		       85 a3		      STA	player0pointerhi
    762  1234		       a9 09		      LDA	#9
    763  1236		       85 b0		      STA	player0height
    764  1238				   .skipL060
    765  1238				   .
    766  1238							; 
    767  1238
    768  1238				   .L061		;  return
    769  1238
    770  1238		       ba		      tsx
    771  1239		       b5 02		      lda	2,x	; check return address
    772  123b		       49 d2		      eor	#(>*)	; vs. current PCH
    773  123d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    774  123f		       f0 03		      beq	*+5	; if equal, do normal return
    775  1241		       4c dd ff 	      JMP	BS_return
    776  1244		       60		      RTS
    777  1245				   .
    778  1245							; 
    779  1245
    780  1245				   .
    781  1245							; 
    782  1245
    783  1245				   .
    784  1245							; 
    785  1245
    786  1245				   .
    787  1245							; 
    788  1245
    789  1245				   .reset_blast
    790  1245							; reset_blast
    791  1245
    792  1245				   .L062		;  player0:  
    793  1245
    794  1245		       a2 7d		      LDX	#<playerL062_0
    795  1247		       86 a2		      STX	player0pointerlo
    796  1249		       a9 f4		      LDA	#>playerL062_0
    797  124b		       85 a3		      STA	player0pointerhi
    798  124d		       a9 09		      LDA	#9
    799  124f		       85 b0		      STA	player0height
    800  1251				   .
    801  1251							; 
    802  1251
    803  1251				   .
    804  1251							; 
    805  1251
    806  1251				   .L063		;  inv_blast_delay  =	0  :  inv_x  =	 ( rand & 117 )   +  26  :  inv_y  =  76
    807  1251
    808  1251		       a9 00		      LDA	#0
    809  1253		       85 e5		      STA	inv_blast_delay
    810  1255							; complex statement detected
    811  1255		       85 d1		      sta	temp7
    812  1257		       a9 d2		      lda	#>(ret_point2-1)
    813  1259		       48		      pha
    814  125a		       a9 6c		      lda	#<(ret_point2-1)
    815  125c		       48		      pha
    816  125d		       a9 f4		      lda	#>(randomize-1)
    817  125f		       48		      pha
    818  1260		       a9 34		      lda	#<(randomize-1)
    819  1262		       48		      pha
    820  1263		       a5 d1		      lda	temp7
    821  1265		       48		      pha
    822  1266		       8a		      txa
    823  1267		       48		      pha
    824  1268		       a2 02		      ldx	#2
    825  126a		       4c eb ff 	      jmp	BS_jsr
    826  126d				   ret_point2
    827  126d		       29 75		      AND	#117
    828  126f		       18		      CLC
    829  1270		       69 1a		      ADC	#26
    830  1272		       85 d7		      STA	inv_x
    831  1274		       a9 4c		      LDA	#76
    832  1276		       85 d8		      STA	inv_y
    833  1278				   .
    834  1278							; 
    835  1278
    836  1278				   .L064		;  return
    837  1278
    838  1278		       ba		      tsx
    839  1279		       b5 02		      lda	2,x	; check return address
    840  127b		       49 d2		      eor	#(>*)	; vs. current PCH
    841  127d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    842  127f		       f0 03		      beq	*+5	; if equal, do normal return
    843  1281		       4c dd ff 	      JMP	BS_return
    844  1284		       60		      RTS
    845  1285				   .
    846  1285							; 
    847  1285
    848  1285				   .
    849  1285							; 
    850  1285
    851  1285				   .
    852  1285							; 
    853  1285
    854  1285				   .
    855  1285							; 
    856  1285
    857  1285				   .draw__move_turret
    858  1285							; draw__move_turret
    859  1285
    860  1285				   .L065		;  player1:
    861  1285
    862  1285		       a2 86		      LDX	#<playerL065_1
    863  1287		       86 a6		      STX	player1pointerlo
    864  1289		       a9 f4		      LDA	#>playerL065_1
    865  128b		       85 ab		      STA	player1pointerhi
    866  128d		       a9 09		      LDA	#9
    867  128f		       85 b1		      STA	player1height
    868  1291				   .
    869  1291							; 
    870  1291
    871  1291				   .
    872  1291							; 
    873  1291
    874  1291				   .L066		;  _COLUP1  =	196
    875  1291
    876  1291		       a9 c4		      LDA	#196
    877  1293		       85 98		      STA	_COLUP1
    878  1295				   .
    879  1295							; 
    880  1295
    881  1295				   .L067		;  if joy0left  &&  tur_x  >=	26 then tur_x  =  tur_x  -  1
    882  1295
    883  1295		       2c 80 02 	      bit	SWCHA
    884  1298		       70 08		      BVS	.skipL067
    885  129a				   .condpart33
    886  129a		       a5 da		      LDA	tur_x
    887  129c		       c9 1a		      CMP	#26
    888  129e		       90 02		      BCC	.skip33then
    889  12a0				   .condpart34
    890  12a0		       c6 da		      DEC	tur_x
    891  12a2				   .skip33then
    892  12a2				   .skipL067
    893  12a2				   .L068		;  if joy0right  &&  tur_x  <=  143 then tur_x  =  tur_x  +  1
    894  12a2
    895  12a2		       2c 80 02 	      bit	SWCHA
    896  12a5		       30 08		      BMI	.skipL068
    897  12a7				   .condpart35
    898  12a7		       a9 8f		      LDA	#143
    899  12a9		       c5 da		      CMP	tur_x
    900  12ab		       90 02		      BCC	.skip35then
    901  12ad				   .condpart36
    902  12ad		       e6 da		      INC	tur_x
    903  12af				   .skip35then
    904  12af				   .skipL068
    905  12af				   .
    906  12af							; 
    907  12af
    908  12af				   .
    909  12af							; 
    910  12af
    911  12af				   .
    912  12af							; 
    913  12af
    914  12af				   .
    915  12af							; 
    916  12af
    917  12af				   .L069		;  if tur_hit	=  0 then player1x  =  tur_x  :  player1y  =  tur_y
    918  12af
    919  12af		       a5 e7		      LDA	tur_hit
    920  12b1		       c9 00		      CMP	#0
    921  12b3		       d0 08		      BNE	.skipL069
    922  12b5				   .condpart37
    923  12b5		       a5 da		      LDA	tur_x
    924  12b7		       85 85		      STA	player1x
    925  12b9		       a5 db		      LDA	tur_y
    926  12bb		       85 8e		      STA	player1y
    927  12bd				   .skipL069
    928  12bd				   .
    929  12bd							; 
    930  12bd
    931  12bd				   .L070		;  return
    932  12bd
    933  12bd		       ba		      tsx
    934  12be		       b5 02		      lda	2,x	; check return address
    935  12c0		       49 d2		      eor	#(>*)	; vs. current PCH
    936  12c2		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    937  12c4		       f0 03		      beq	*+5	; if equal, do normal return
    938  12c6		       4c dd ff 	      JMP	BS_return
    939  12c9		       60		      RTS
    940  12ca				   .
    941  12ca							; 
    942  12ca
    943  12ca				   .
    944  12ca							; 
    945  12ca
    946  12ca				   .
    947  12ca							; 
    948  12ca
    949  12ca				   .
    950  12ca							; 
    951  12ca
    952  12ca				   .draw__move_turret_shot
    953  12ca							; draw__move_turret_shot
    954  12ca
    955  12ca				   .L071		;  player3:
    956  12ca
    957  12ca		       a2 8e		      LDX	#<playerL071_3
    958  12cc		       86 a8		      STX	player3pointerlo
    959  12ce		       a9 f4		      LDA	#>playerL071_3
    960  12d0		       85 ad		      STA	player3pointerhi
    961  12d2		       a9 09		      LDA	#9
    962  12d4		       85 b3		      STA	player3height
    963  12d6				   .
    964  12d6							; 
    965  12d6
    966  12d6				   .L072		;  COLUP3  =  14
    967  12d6
    968  12d6		       a9 0e		      LDA	#14
    969  12d8		       85 9a		      STA	COLUP3
    970  12da				   .
    971  12da							; 
    972  12da
    973  12da				   .L073		;  if joy0fire  &&  tur_fired	=  0 then tur_fired  =	1  :  shot_x  =  tur_x	:  shot_y  =  tur_y  +	1  :  player3x	=  shot_x  :  player3y	=  shot_y
    974  12da
    975  12da		       24 0c		      bit	INPT4
    976  12dc		       30 1d		      BMI	.skipL073
    977  12de				   .condpart38
    978  12de		       a5 e3		      LDA	tur_fired
    979  12e0		       c9 00		      CMP	#0
    980  12e2		       d0 17		      BNE	.skip38then
    981  12e4				   .condpart39
    982  12e4		       a9 01		      LDA	#1
    983  12e6		       85 e3		      STA	tur_fired
    984  12e8		       a5 da		      LDA	tur_x
    985  12ea		       85 df		      STA	shot_x
    986  12ec		       a5 db		      LDA	tur_y
    987  12ee		       18		      CLC
    988  12ef		       69 01		      ADC	#1
    989  12f1		       85 e0		      STA	shot_y
    990  12f3		       a5 df		      LDA	shot_x
    991  12f5		       85 87		      STA	player3x
    992  12f7		       a5 e0		      LDA	shot_y
    993  12f9		       85 90		      STA	player3y
    994  12fb				   .skip38then
    995  12fb				   .skipL073
    996  12fb				   .
    997  12fb							; 
    998  12fb
    999  12fb				   .L074		;  if tur_fired  =  1 then shot_y  =  shot_y  +  2  :	player3x  =  shot_x  :	player3y  =  shot_y
   1000  12fb
   1001  12fb		       a5 e3		      LDA	tur_fired
   1002  12fd		       c9 01		      CMP	#1
   1003  12ff		       d0 0f		      BNE	.skipL074
   1004  1301				   .condpart40
   1005  1301		       a5 e0		      LDA	shot_y
   1006  1303		       18		      CLC
   1007  1304		       69 02		      ADC	#2
   1008  1306		       85 e0		      STA	shot_y
   1009  1308		       a5 df		      LDA	shot_x
   1010  130a		       85 87		      STA	player3x
   1011  130c		       a5 e0		      LDA	shot_y
   1012  130e		       85 90		      STA	player3y
   1013  1310				   .skipL074
   1014  1310				   .
   1015  1310							; 
   1016  1310
   1017  1310				   .L075		;  if shot_y  >  77  &&  ! joy0fire then tur_fired  =	0  :  shot_y  =  0  :  player3y  =  shot_y
   1018  1310
   1019  1310		       a9 4d		      LDA	#77
   1020  1312		       c5 e0		      CMP	shot_y
   1021  1314		       b0 0e		      BCS	.skipL075
   1022  1316				   .condpart41
   1023  1316		       24 0c		      bit	INPT4
   1024  1318		       10 0a		      BPL	.skip41then
   1025  131a				   .condpart42
   1026  131a		       a9 00		      LDA	#0
   1027  131c		       85 e3		      STA	tur_fired
   1028  131e		       85 e0		      STA	shot_y
   1029  1320		       a5 e0		      LDA	shot_y
   1030  1322		       85 90		      STA	player3y
   1031  1324				   .skip41then
   1032  1324				   .skipL075
   1033  1324				   .
   1034  1324							; 
   1035  1324
   1036  1324				   .L076		;  return
   1037  1324
   1038  1324		       ba		      tsx
   1039  1325		       b5 02		      lda	2,x	; check return address
   1040  1327		       49 d3		      eor	#(>*)	; vs. current PCH
   1041  1329		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1042  132b		       f0 03		      beq	*+5	; if equal, do normal return
   1043  132d		       4c dd ff 	      JMP	BS_return
   1044  1330		       60		      RTS
   1045  1331				   .
   1046  1331							; 
   1047  1331
   1048  1331				   .
   1049  1331							; 
   1050  1331
   1051  1331				   .
   1052  1331							; 
   1053  1331
   1054  1331				   .
   1055  1331							; 
   1056  1331
   1057  1331				   .col_inv_shot_turret
   1058  1331							; col_inv_shot_turret
   1059  1331
   1060  1331				   .
   1061  1331							; 
   1062  1331
   1063  1331				   .L077		;  if inv_shot_x  +  4  >=  tur_x  &&	inv_shot_x  +  2  <=  tur_x  +	6  &&  inv_shot_y  -  5  <  tur_y  - 5 then tur_hit  =	1  :  goto game_over
   1064  1331
   1065  1331							; complex condition detected
   1066  1331		       a5 dd		      LDA	inv_shot_x
   1067  1333		       18		      CLC
   1068  1334		       69 04		      ADC	#4
   1069  1336							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   1070  1336		       c5 da		      CMP	tur_x
   1071  1338		       90 2d		      BCC	.skipL077
   1072  133a				   .condpart43
   1073  133a							; complex condition detected
   1074  133a		       a5 da		      LDA	tur_x
   1075  133c		       18		      CLC
   1076  133d		       69 06		      ADC	#6
   1077  133f		       48		      PHA
   1078  1340		       a5 dd		      LDA	inv_shot_x
   1079  1342		       18		      CLC
   1080  1343		       69 02		      ADC	#2
   1081  1345		       48		      PHA
   1082  1346		       ba		      TSX
   1083  1347		       68		      PLA
   1084  1348		       68		      PLA
   1085  1349							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
   1086  1349		       d5 01		      CMP	1,x
   1087  134b		       90 1a		      BCC	.skip43then
   1088  134d				   .condpart44
   1089  134d							; complex condition detected
   1090  134d		       a5 de		      LDA	inv_shot_y
   1091  134f		       38		      SEC
   1092  1350		       e9 05		      SBC	#5
   1093  1352		       48		      PHA
   1094  1353		       a5 db		      LDA	tur_y
   1095  1355		       38		      SEC
   1096  1356		       e9 05		      SBC	#5
   1097  1358		       48		      PHA
   1098  1359		       ba		      TSX
   1099  135a		       68		      PLA
   1100  135b		       68		      PLA
   1101  135c		       d5 01		      CMP	1,x
   1102  135e		       b0 07		      BCS	.skip44then
   1103  1360				   .condpart45
   1104  1360		       a9 01		      LDA	#1
   1105  1362		       85 e7		      STA	tur_hit
   1106  1364		       4c a5 d3 	      jmp	.game_over
   1107  1367
   1108  1367				   .skip44then
   1109  1367				   .skip43then
   1110  1367				   .skipL077
   1111  1367				   .
   1112  1367							; 
   1113  1367
   1114  1367				   .L078		;  return
   1115  1367
   1116  1367		       ba		      tsx
   1117  1368		       b5 02		      lda	2,x	; check return address
   1118  136a		       49 d3		      eor	#(>*)	; vs. current PCH
   1119  136c		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1120  136e		       f0 03		      beq	*+5	; if equal, do normal return
   1121  1370		       4c dd ff 	      JMP	BS_return
   1122  1373		       60		      RTS
   1123  1374				   .
   1124  1374							; 
   1125  1374
   1126  1374				   .
   1127  1374							; 
   1128  1374
   1129  1374				   .
   1130  1374							; 
   1131  1374
   1132  1374				   .
   1133  1374							; 
   1134  1374
   1135  1374				   .play_tur_anim
   1136  1374							; play_tur_anim
   1137  1374
   1138  1374				   .L079		;  if tur_anim_frame  =  30 then player1:
   1139  1374
   1140  1374		       a5 e9		      LDA	tur_anim_frame
   1141  1376		       c9 1e		      CMP	#30
   1142  1378		       d0 0c		      BNE	.skipL079
   1143  137a				   .condpart46
   1144  137a		       a2 96		      LDX	#<player46then_1
   1145  137c		       86 a6		      STX	player1pointerlo
   1146  137e		       a9 f4		      LDA	#>player46then_1
   1147  1380		       85 ab		      STA	player1pointerhi
   1148  1382		       a9 09		      LDA	#9
   1149  1384		       85 b1		      STA	player1height
   1150  1386				   .skipL079
   1151  1386				   .
   1152  1386							; 
   1153  1386
   1154  1386				   .L080		;  if tur_anim_frame  =  60 then player1:
   1155  1386
   1156  1386		       a5 e9		      LDA	tur_anim_frame
   1157  1388		       c9 3c		      CMP	#60
   1158  138a		       d0 0c		      BNE	.skipL080
   1159  138c				   .condpart47
   1160  138c		       a2 9e		      LDX	#<player47then_1
   1161  138e		       86 a6		      STX	player1pointerlo
   1162  1390		       a9 f4		      LDA	#>player47then_1
   1163  1392		       85 ab		      STA	player1pointerhi
   1164  1394		       a9 09		      LDA	#9
   1165  1396		       85 b1		      STA	player1height
   1166  1398				   .skipL080
   1167  1398				   .
   1168  1398							; 
   1169  1398
   1170  1398				   .
   1171  1398							; 
   1172  1398
   1173  1398				   .
   1174  1398							; 
   1175  1398
   1176  1398				   .
   1177  1398							; 
   1178  1398
   1179  1398				   .
   1180  1398							; 
   1181  1398
   1182  1398				   .
   1183  1398							; 
   1184  1398
   1185  1398				   .
   1186  1398							; 
   1187  1398
   1188  1398				   .
   1189  1398							; 
   1190  1398
   1191  1398				   .
   1192  1398							; 
   1193  1398
   1194  1398				   .
   1195  1398							; 
   1196  1398
   1197  1398				   .L081		;  return
   1198  1398
   1199  1398		       ba		      tsx
   1200  1399		       b5 02		      lda	2,x	; check return address
   1201  139b		       49 d3		      eor	#(>*)	; vs. current PCH
   1202  139d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1203  139f		       f0 03		      beq	*+5	; if equal, do normal return
   1204  13a1		       4c dd ff 	      JMP	BS_return
   1205  13a4		       60		      RTS
   1206  13a5				   .
   1207  13a5							; 
   1208  13a5
   1209  13a5				   .
   1210  13a5							; 
   1211  13a5
   1212  13a5				   .
   1213  13a5							; 
   1214  13a5
   1215  13a5				   .game_over
   1216  13a5							; game_over
   1217  13a5
   1218  13a5				   .
   1219  13a5							; 
   1220  13a5
   1221  13a5				   .L082		;  if joy0up then reboot
   1222  13a5
   1223  13a5		       a9 10		      lda	#$10
   1224  13a7		       2c 80 02 	      bit	SWCHA
   1225  13aa		       d0 03		      BNE	.skipL082
   1226  13ac				   .condpart48
   1227  13ac		       6c fc ff 	      JMP	($FFFC)
   1228  13af				   .skipL082
   1229  13af				   .
   1230  13af							; 
   1231  13af
   1232  13af				   .
   1233  13af							; 
   1234  13af
   1235  13af				   .
   1236  13af							; 
   1237  13af
   1238  13af				   .L083		;  player2:
   1239  13af
   1240  13af		       a2 a6		      LDX	#<playerL083_2
   1241  13b1		       86 a7		      STX	player2pointerlo
   1242  13b3		       a9 f4		      LDA	#>playerL083_2
   1243  13b5		       85 ac		      STA	player2pointerhi
   1244  13b7		       a9 1a		      LDA	#26
   1245  13b9		       85 b2		      STA	player2height
   1246  13bb				   .
   1247  13bb							; 
   1248  13bb
   1249  13bb				   .L084		;  player3:
   1250  13bb
   1251  13bb		       a2 bf		      LDX	#<playerL084_3
   1252  13bd		       86 a8		      STX	player3pointerlo
   1253  13bf		       a9 f4		      LDA	#>playerL084_3
   1254  13c1		       85 ad		      STA	player3pointerhi
   1255  13c3		       a9 1a		      LDA	#26
   1256  13c5		       85 b3		      STA	player3height
   1257  13c7				   .
   1258  13c7							; 
   1259  13c7
   1260  13c7				   .L085		;  player0x  =  0  :  player0y  =  0
   1261  13c7
   1262  13c7		       a9 00		      LDA	#0
   1263  13c9		       85 84		      STA	player0x
   1264  13cb		       85 8d		      STA	player0y
   1265  13cd				   .L086		;  player1x  =  0  :  player1y  =  0
   1266  13cd
   1267  13cd		       a9 00		      LDA	#0
   1268  13cf		       85 85		      STA	player1x
   1269  13d1		       85 8e		      STA	player1y
   1270  13d3				   .L087		;  COLUP0  =  0
   1271  13d3
   1272  13d3		       a9 00		      LDA	#0
   1273  13d5		       85 06		      STA	COLUP0
   1274  13d7				   .L088		;  COLUP1  =  0
   1275  13d7
   1276  13d7		       a9 00		      LDA	#0
   1277  13d9		       85 07		      STA	COLUP1
   1278  13db				   .
   1279  13db							; 
   1280  13db
   1281  13db				   .L089		;  player2x  =  85  :	player2y  =  66
   1282  13db
   1283  13db		       a9 55		      LDA	#85
   1284  13dd		       85 86		      STA	player2x
   1285  13df		       a9 42		      LDA	#66
   1286  13e1		       85 8f		      STA	player2y
   1287  13e3				   .L090		;  player3x  =  85  :	player3y  =  39
   1288  13e3
   1289  13e3		       a9 55		      LDA	#85
   1290  13e5		       85 87		      STA	player3x
   1291  13e7		       a9 27		      LDA	#39
   1292  13e9		       85 90		      STA	player3y
   1293  13eb				   .
   1294  13eb							; 
   1295  13eb
   1296  13eb				   .L091		;  drawscreen
   1297  13eb
   1298  13eb		       85 d1		      sta	temp7
   1299  13ed		       a9 d4		      lda	#>(ret_point3-1)
   1300  13ef		       48		      pha
   1301  13f0		       a9 02		      lda	#<(ret_point3-1)
   1302  13f2		       48		      pha
   1303  13f3		       a9 f0		      lda	#>(drawscreen-1)
   1304  13f5		       48		      pha
   1305  13f6		       a9 39		      lda	#<(drawscreen-1)
   1306  13f8		       48		      pha
   1307  13f9		       a5 d1		      lda	temp7
   1308  13fb		       48		      pha
   1309  13fc		       8a		      txa
   1310  13fd		       48		      pha
   1311  13fe		       a2 02		      ldx	#2
   1312  1400		       4c eb ff 	      jmp	BS_jsr
   1313  1403				   ret_point3
   1314  1403				   .
   1315  1403							; 
   1316  1403
   1317  1403				   .L092		;  goto game_over
   1318  1403
   1319  1403		       4c a5 d3 	      jmp	.game_over
   1320  1406
   1321  1406					      if	ECHO1
      3022 bytes of ROM space left in bank 1
   1322  1406					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1323  1406					      endif
   1324  1406		       00 01	   ECHO1      =	1
   1325  1fd4					      ORG	$1FF4-bscode_length
   1326  1fd4					      RORG	$DFF4-bscode_length
   1327  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1328  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1329  1fd6				  -	      stx	FASTFETCH
   1330  1fd6					      endif
   1331  1fd6		       9a		      txs
   1332  1fd7				  -	      if	bankswitch == 64
   1333  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1334  1fd7					      else
   1335  1fd7		       a9 f3		      lda	#>(start-1)
   1336  1fd9					      endif
   1337  1fd9		       48		      pha
   1338  1fda		       a9 f7		      lda	#<(start-1)
   1339  1fdc		       48		      pha
   1340  1fdd		       48		      pha
   1341  1fde		       8a		      txa
   1342  1fdf		       48		      pha
   1343  1fe0		       ba		      tsx
   1344  1fe1					      if	bankswitch != 64
   1345  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1346  1fe3		       2a		      rol
   1347  1fe4		       2a		      rol
   1348  1fe5		       2a		      rol
   1349  1fe6		       2a		      rol
   1350  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1351  1fe9		       aa		      tax
   1352  1fea		       e8		      inx
   1353  1feb				  -	      else
   1354  1feb				  -	      lda	4,x	; get high byte of return address
   1355  1feb				  -	      tay
   1356  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1357  1feb				  -	      sta	4,x
   1358  1feb				  -	      tya
   1359  1feb				  -	      lsr
   1360  1feb				  -	      lsr
   1361  1feb				  -	      lsr
   1362  1feb				  -	      lsr
   1363  1feb				  -	      tax
   1364  1feb				  -	      inx
   1365  1feb					      endif
   1366  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1367  1fee		       68		      pla
   1368  1fef		       aa		      tax
   1369  1ff0		       68		      pla
   1370  1ff1		       60		      rts
   1371  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1372  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1373  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1374  1ff2					      endif
   1375  1ffc					      ORG	$1FFC
   1376  1ffc					      RORG	$DFFC
   1377  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
   1378  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
   1379  2000					      ORG	$2000
   1380  2000					      RORG	$F000
   1381  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1382  2000
   1383  2000				   FineAdjustTableBegin
   1384  2000		       60		      .byte.b	%01100000	;left 6
   1385  2001		       50		      .byte.b	%01010000
   1386  2002		       40		      .byte.b	%01000000
   1387  2003		       30		      .byte.b	%00110000
   1388  2004		       20		      .byte.b	%00100000
   1389  2005		       10		      .byte.b	%00010000
   1390  2006		       00		      .byte.b	%00000000	;left 0
   1391  2007		       f0		      .byte.b	%11110000
   1392  2008		       e0		      .byte.b	%11100000
   1393  2009		       d0		      .byte.b	%11010000
   1394  200a		       c0		      .byte.b	%11000000
   1395  200b		       b0		      .byte.b	%10110000
   1396  200c		       a0		      .byte.b	%10100000
   1397  200d		       90		      .byte.b	%10010000
   1398  200e		       80		      .byte.b	%10000000	;right 8
   1399  200e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
   1400  200f
   1401  200f				   PFStart
   1402  200f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
   1403  2017				   blank_pf
   1404  2017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
   1405  201f							; .byte 43,21,0,10,0,0,0,5
   1406  201f				  -	      ifconst	screenheight
   1407  201f				  -pfsub
   1408  201f				  -	      .byte	8,4,2,2,1,0,0,1,0
   1409  201f					      endif
   1410  201f							;--set initial P1 positions
   1411  201f				   multisprite_setup
   1412  201f		       a9 0f		      lda	#15
   1413  2021		       85 c4		      sta	pfheight
   1414  2023
   1415  2023		       a2 04		      ldx	#4
   1416  2025							; stx temp3
   1417  2025				   SetCopyHeight
   1418  2025							;	lda #76
   1419  2025							;	sta NewSpriteX,X
   1420  2025							;	lda CopyColorData,X
   1421  2025							;	sta NewCOLUP1,X
   1422  2025							;lda SpriteHeightTable,X
   1423  2025							; sta spriteheight,x
   1424  2025		       8a		      txa
   1425  2026		       95 9d		      sta	SpriteGfxIndex,X
   1426  2028		       95 f1		      sta	spritesort,X
   1427  202a		       ca		      dex
   1428  202b		       10 f8		      bpl	SetCopyHeight
   1429  202d
   1430  202d
   1431  202d
   1432  202d							; since we can't turn off pf, point PF to zeros here
   1433  202d		       a9 f0		      lda	#>blank_pf
   1434  202f		       85 be		      sta	PF2pointer+1
   1435  2031		       85 bc		      sta	PF1pointer+1
   1436  2033		       a9 17		      lda	#<blank_pf
   1437  2035		       85 bd		      sta	PF2pointer
   1438  2037		       85 bb		      sta	PF1pointer
   1439  2039		       60		      rts
   1440  203a
   1441  203a				   drawscreen
   1442  203a				  -	      ifconst	debugscore
   1443  203a				  -	      jsr	debugcycles
   1444  203a					      endif
   1445  203a
   1446  203a				   WaitForOverscanEnd
   1447  203a		       ad 84 02 	      lda	INTIM
   1448  203d		       30 fb		      bmi	WaitForOverscanEnd
   1449  203f
   1450  203f		       a9 02		      lda	#2
   1451  2041		       85 02		      sta	WSYNC
   1452  2043		       85 00		      sta	VSYNC
   1453  2045		       85 02		      sta	WSYNC
   1454  2047		       85 02		      sta	WSYNC
   1455  2049		       4a		      lsr
   1456  204a		       85 27		      sta	VDELBL
   1457  204c		       85 25		      sta	VDELP0
   1458  204e		       85 02		      sta	WSYNC
   1459  2050		       85 00		      sta	VSYNC	;turn off VSYNC
   1460  2052				  -	      ifconst	overscan_time
   1461  2052				  -	      lda	#overscan_time+5+128
   1462  2052					      else
   1463  2052		       a9 aa		      lda	#42+128
   1464  2054					      endif
   1465  2054		       8d 96 02 	      sta	TIM64T
   1466  2057
   1467  2057							; run possible vblank bB code
   1468  2057				  -	      ifconst	vblank_bB_code
   1469  2057				  -	      jsr	vblank_bB_code
   1470  2057					      endif
   1471  2057
   1472  2057		       20 dc f1 	      jsr	setscorepointers
   1473  205a		       20 7e f3 	      jsr	SetupP1Subroutine
   1474  205d
   1475  205d							;-------------
   1476  205d
   1477  205d
   1478  205d
   1479  205d
   1480  205d
   1481  205d							;--position P0, M0, M1, BL
   1482  205d
   1483  205d		       20 b5 f0 	      jsr	PrePositionAllObjects
   1484  2060
   1485  2060							;--set up player 0 pointer
   1486  2060
   1487  2060		       c6 8d		      dec	player0y
   1488  2062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
   1489  2064		       38		      sec
   1490  2065		       e5 8d		      sbc	player0y
   1491  2067		       18		      clc
   1492  2068		       65 b0		      adc	player0height
   1493  206a		       85 a2		      sta	player0pointer
   1494  206c
   1495  206c		       a5 8d		      lda	player0y
   1496  206e		       85 cf		      sta	P0Top
   1497  2070		       38		      sec
   1498  2071		       e5 b0		      sbc	player0height
   1499  2073		       18		      clc
   1500  2074		       69 80		      adc	#$80
   1501  2076		       85 a4		      sta	P0Bottom
   1502  2078
   1503  2078
   1504  2078							;--some final setup
   1505  2078
   1506  2078		       a2 04		      ldx	#4
   1507  207a		       a9 80		      lda	#$80
   1508  207c				   cycle74_HMCLR
   1509  207c		       95 20		      sta	HMP0,X
   1510  207e		       ca		      dex
   1511  207f		       10 fb		      bpl	cycle74_HMCLR
   1512  2081							;	sta HMCLR
   1513  2081
   1514  2081
   1515  2081		       a9 00		      lda	#0
   1516  2083		       85 0e		      sta	PF1
   1517  2085		       85 0f		      sta	PF2
   1518  2087		       85 1b		      sta	GRP0
   1519  2089		       85 1c		      sta	GRP1
   1520  208b
   1521  208b
   1522  208b		       20 d0 f0 	      jsr	KernelSetupSubroutine
   1523  208e
   1524  208e				   WaitForVblankEnd
   1525  208e		       ad 84 02 	      lda	INTIM
   1526  2091		       30 fb		      bmi	WaitForVblankEnd
   1527  2093		       a9 00		      lda	#0
   1528  2095		       85 02		      sta	WSYNC
   1529  2097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
   1530  2099		       85 2c		      sta	CXCLR
   1531  209b
   1532  209b
   1533  209b		       4c 5d f1 	      jmp	KernelRoutine
   1534  209e
   1535  209e
   1536  209e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
   1537  209e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
   1538  209e							;if you do not wish to write to P1 during this function, make
   1539  209e							;sure Y==0 before you call it.  This function will change Y, and A
   1540  209e							;will be the value put into HMxx when returned.
   1541  209e							;Call this function with at least 11 cycles left in the scanline 
   1542  209e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
   1543  209e							;into the second scanline
   1544  209e		       38		      sec
   1545  209f		       85 02		      sta	WSYNC	;begin line 1
   1546  20a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
   1547  20a4				   DivideBy15Loop
   1548  20a4		       e9 0f		      sbc	#15
   1549  20a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
   1550  20a8
   1551  20a8		       a8		      tay		;+2	10/15/...60
   1552  20a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
   1553  20ac
   1554  20ac							;	15
   1555  20ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
   1556  20ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
   1557  20b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1558  20b2		       85 2a		      sta	HMOVE	;+3
   1559  20b4		       60		      rts		;+6	 9
   1560  20b5
   1561  20b5							;-------------------------------------------------------------------------
   1562  20b5
   1563  20b5				   PrePositionAllObjects
   1564  20b5
   1565  20b5		       a2 04		      ldx	#4
   1566  20b7		       a5 82		      lda	ballx
   1567  20b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1568  20bc
   1569  20bc		       ca		      dex
   1570  20bd		       a5 81		      lda	missile1x
   1571  20bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1572  20c2
   1573  20c2		       ca		      dex
   1574  20c3		       a5 80		      lda	missile0x
   1575  20c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1576  20c8
   1577  20c8		       ca		      dex
   1578  20c9		       ca		      dex
   1579  20ca		       a5 84		      lda	player0x
   1580  20cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1581  20cf
   1582  20cf		       60		      rts
   1583  20d0
   1584  20d0
   1585  20d0							;-------------------------------------------------------------------------
   1586  20d0
   1587  20d0
   1588  20d0
   1589  20d0
   1590  20d0
   1591  20d0
   1592  20d0
   1593  20d0
   1594  20d0							;-------------------------------------------------------------------------
   1595  20d0
   1596  20d0
   1597  20d0				   KernelSetupSubroutine
   1598  20d0
   1599  20d0		       a2 04		      ldx	#4
   1600  20d2				   AdjustYValuesUpLoop
   1601  20d2		       b5 8e		      lda	NewSpriteY,X
   1602  20d4		       18		      clc
   1603  20d5		       69 02		      adc	#2
   1604  20d7		       95 8e		      sta	NewSpriteY,X
   1605  20d9		       ca		      dex
   1606  20da		       10 f6		      bpl	AdjustYValuesUpLoop
   1607  20dc
   1608  20dc
   1609  20dc		       a6 cd		      ldx	temp3	; first sprite displayed
   1610  20de
   1611  20de		       b5 9d		      lda	SpriteGfxIndex,x
   1612  20e0		       a8		      tay
   1613  20e1		       b9 8e 00 	      lda	NewSpriteY,y
   1614  20e4		       85 ce		      sta	RepoLine
   1615  20e6
   1616  20e6		       b5 9c		      lda	SpriteGfxIndex-1,x
   1617  20e8		       a8		      tay
   1618  20e9		       b9 8e 00 	      lda	NewSpriteY,y
   1619  20ec		       85 d0		      sta	temp6
   1620  20ee
   1621  20ee		       86 83		      stx	SpriteIndex
   1622  20f0
   1623  20f0
   1624  20f0
   1625  20f0		       a9 ff		      lda	#255
   1626  20f2		       85 a5		      sta	P1Bottom
   1627  20f4
   1628  20f4		       a5 8d		      lda	player0y
   1629  20f6				  -	      ifconst	screenheight
   1630  20f6				  -	      cmp	#screenheight+1
   1631  20f6					      else
   1632  20f6		       c9 59		      cmp	#$59
   1633  20f8					      endif
   1634  20f8		       90 04		      bcc	nottoohigh
   1635  20fa		       a5 a4		      lda	P0Bottom
   1636  20fc		       85 cf		      sta	P0Top
   1637  20fe
   1638  20fe
   1639  20fe
   1640  20fe				   nottoohigh
   1641  20fe		       60		      rts
   1642  20ff
   1643  20ff							;-------------------------------------------------------------------------
   1644  20ff
   1645  20ff
   1646  20ff
   1647  20ff
   1648  20ff
   1649  20ff							;*************************************************************************
   1650  20ff
   1651  20ff							;-------------------------------------------------------------------------
   1652  20ff							;-------------------------Data Below--------------------------------------
   1653  20ff							;-------------------------------------------------------------------------
   1654  20ff
   1655  20ff				   MaskTable
   1656  20ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
   1657  2104
   1658  2104							; shove 6-digit score routine here
   1659  2104
   1660  2104				   sixdigscore
   1661  2104		       a9 00		      lda	#0
   1662  2106							;	sta COLUBK
   1663  2106		       85 0d		      sta	PF0
   1664  2108		       85 0e		      sta	PF1
   1665  210a		       85 0f		      sta	PF2
   1666  210c		       85 1f		      sta	ENABL
   1667  210e		       85 1d		      sta	ENAM0
   1668  2110		       85 1e		      sta	ENAM1
   1669  2112							;end of kernel here
   1670  2112
   1671  2112
   1672  2112							; 6 digit score routine
   1673  2112							; lda #0
   1674  2112							; sta PF1
   1675  2112							; sta PF2
   1676  2112							; tax
   1677  2112
   1678  2112		       85 02		      sta	WSYNC	;,x
   1679  2114
   1680  2114							;		  STA WSYNC ;first one, need one more
   1681  2114		       85 0b		      sta	REFP0
   1682  2116		       85 0c		      sta	REFP1
   1683  2118		       85 1b		      STA	GRP0
   1684  211a		       85 1c		      STA	GRP1
   1685  211c		       85 2b		      sta	HMCLR
   1686  211e
   1687  211e							; restore P0pointer
   1688  211e
   1689  211e		       a5 a2		      lda	player0pointer
   1690  2120		       18		      clc
   1691  2121		       65 8d		      adc	player0y
   1692  2123		       38		      sec
   1693  2124		       e5 b0		      sbc	player0height
   1694  2126		       85 a2		      sta	player0pointer
   1695  2128		       e6 8d		      inc	player0y
   1696  212a
   1697  212a				  -	      ifconst	vblank_time
   1698  212a				  -	      ifconst	screenheight
   1699  212a				  -	      if	screenheight == 84
   1700  212a				  -	      lda	#vblank_time+9+128+10
   1701  212a				  -	      else
   1702  212a				  -	      lda	#vblank_time+9+128+19
   1703  212a				  -	      endif
   1704  212a				  -	      else
   1705  212a				  -	      lda	#vblank_time+9+128
   1706  212a				  -	      endif
   1707  212a					      else
   1708  212a				  -	      ifconst	screenheight
   1709  212a				  -	      if	screenheight == 84
   1710  212a				  -	      lda	#52+128+10
   1711  212a				  -	      else
   1712  212a				  -	      lda	#52+128+19
   1713  212a				  -	      endif
   1714  212a					      else
   1715  212a		       a9 b4		      lda	#52+128
   1716  212c					      endif
   1717  212c					      endif
   1718  212c
   1719  212c		       8d 96 02 	      sta	TIM64T
   1720  212f				  -	      ifconst	minikernel
   1721  212f				  -	      jsr	minikernel
   1722  212f					      endif
   1723  212f				  -	      ifconst	noscore
   1724  212f				  -	      pla
   1725  212f				  -	      pla
   1726  212f				  -	      jmp	skipscore
   1727  212f					      endif
   1728  212f
   1729  212f							; score pointers contain:
   1730  212f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1731  212f							; swap lo2->temp1
   1732  212f							; swap lo4->temp3
   1733  212f							; swap lo6->temp5
   1734  212f
   1735  212f		       a5 ca		      lda	scorepointers+5
   1736  2131		       85 cf		      sta	temp5
   1737  2133		       a5 c6		      lda	scorepointers+1
   1738  2135		       85 cb		      sta	temp1
   1739  2137		       a5 c8		      lda	scorepointers+3
   1740  2139		       85 cd		      sta	temp3
   1741  213b
   1742  213b		       a9 ff		      lda	#>scoretable
   1743  213d		       85 c6		      sta	scorepointers+1
   1744  213f		       85 c8		      sta	scorepointers+3
   1745  2141		       85 ca		      sta	scorepointers+5
   1746  2143		       85 cc		      sta	temp2
   1747  2145		       85 ce		      sta	temp4
   1748  2147		       85 d0		      sta	temp6
   1749  2149
   1750  2149		       60		      rts
   1751  214a
   1752  214a
   1753  214a
   1754  214a							;-------------------------------------------------------------------------
   1755  214a							;----------------------Kernel Routine-------------------------------------
   1756  214a							;-------------------------------------------------------------------------
   1757  214a
   1758  214a
   1759  214a							;-------------------------------------------------------------------------
   1760  214a							; repeat $f147-*
   1761  214a							; brk
   1762  214a							; repend
   1763  214a							;	org $F240
   1764  214a
   1765  214a				   SwitchDrawP0K1		;	72
   1766  214a		       a5 a4		      lda	P0Bottom
   1767  214c		       85 cf		      sta	P0Top	;+6	 2
   1768  214e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1769  2151
   1770  2151				   WaitDrawP0K1 		;	74
      0  2151					      SLEEP	4	;+4	 2
      1  2151				   .CYCLES    SET	4
      2  2151
      3  2151				  -	      IF	.CYCLES < 2
      4  2151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2151				  -	      ERR
      6  2151					      ENDIF
      7  2151
      8  2151				  -	      IF	.CYCLES & 1
      9  2151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2151				  -	      nop	0
     11  2151				  -	      ELSE
     12  2151				  -	      bit	VSYNC
     13  2151				  -	      ENDIF
     14  2151				  -.CYCLES    SET	.CYCLES - 3
     15  2151					      ENDIF
     16  2151
     17  2151					      REPEAT	.CYCLES / 2
     18  2151		       ea		      nop
     17  2151					      REPEND
     18  2152		       ea		      nop
     19  2153					      REPEND
   1772  2153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1773  2156
   1774  2156				   SkipDrawP1K1 		;	11
   1775  2156		       a9 00		      lda	#0
   1776  2158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
   1777  215a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
   1778  215d
   1779  215d							;-------------------------------------------------------------------------
   1780  215d
   1781  215d				   KernelRoutine
   1782  215d					      ifnconst	screenheight
      0  215d					      sleep	12
      1  215d				   .CYCLES    SET	12
      2  215d
      3  215d				  -	      IF	.CYCLES < 2
      4  215d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215d				  -	      ERR
      6  215d					      ENDIF
      7  215d
      8  215d				  -	      IF	.CYCLES & 1
      9  215d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215d				  -	      nop	0
     11  215d				  -	      ELSE
     12  215d				  -	      bit	VSYNC
     13  215d				  -	      ENDIF
     14  215d				  -.CYCLES    SET	.CYCLES - 3
     15  215d					      ENDIF
     16  215d
     17  215d					      REPEAT	.CYCLES / 2
     18  215d		       ea		      nop
     17  215d					      REPEND
     18  215e		       ea		      nop
     17  215e					      REPEND
     18  215f		       ea		      nop
     17  215f					      REPEND
     18  2160		       ea		      nop
     17  2160					      REPEND
     18  2161		       ea		      nop
     17  2161					      REPEND
     18  2162		       ea		      nop
     19  2163					      REPEND
   1784  2163							; jsr wastetime ; waste 12 cycles
   1785  2163				  -	      else
   1786  2163				  -	      sleep	6
   1787  2163					      endif
   1788  2163		       ba		      tsx
   1789  2164		       86 f6		      stx	stack1
   1790  2166		       a2 1f		      ldx	#ENABL
   1791  2168		       9a		      txs		;+9	 9
   1792  2169
   1793  2169		       a2 00		      ldx	#0
   1794  216b		       a5 c4		      lda	pfheight
   1795  216d		       10 01		      bpl	asdhj
   1796  216f		       24		      .byte.b	$24
   1797  2170				   asdhj
   1798  2170		       aa		      tax
   1799  2171
   1800  2171							; ldx pfheight
   1801  2171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
   1802  2174
   1803  2174				  -	      ifconst	screenheight
   1804  2174				  -	      sec
   1805  2174				  -	      if	screenheight == 84
   1806  2174				  -	      sbc	pfsub+1,x
   1807  2174				  -	      else
   1808  2174				  -	      sbc	pfsub,x
   1809  2174				  -	      endif
   1810  2174					      endif
   1811  2174
   1812  2174		       85 ba		      sta	pfpixelheight
   1813  2176
   1814  2176				  -	      ifconst	screenheight
   1815  2176				  -	      ldy	#screenheight
   1816  2176					      else
   1817  2176		       a0 58		      ldy	#88
   1818  2178					      endif
   1819  2178
   1820  2178							;	lda #$02
   1821  2178							;	sta COLUBK		;+5	18
   1822  2178
   1823  2178							; sleep 25
      0  2178					      sleep	2
      1  2178				   .CYCLES    SET	2
      2  2178
      3  2178				  -	      IF	.CYCLES < 2
      4  2178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2178				  -	      ERR
      6  2178					      ENDIF
      7  2178
      8  2178				  -	      IF	.CYCLES & 1
      9  2178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2178				  -	      nop	0
     11  2178				  -	      ELSE
     12  2178				  -	      bit	VSYNC
     13  2178				  -	      ENDIF
     14  2178				  -.CYCLES    SET	.CYCLES - 3
     15  2178					      ENDIF
     16  2178
     17  2178					      REPEAT	.CYCLES / 2
     18  2178		       ea		      nop
     19  2179					      REPEND
   1825  2179				   KernelLoopa		;	50
      0  2179					      SLEEP	7	;+4	54
      1  2179				   .CYCLES    SET	7
      2  2179
      3  2179				  -	      IF	.CYCLES < 2
      4  2179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2179				  -	      ERR
      6  2179					      ENDIF
      7  2179
      8  2179					      IF	.CYCLES & 1
      9  2179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2179		       04 00		      nop	0
     11  217b				  -	      ELSE
     12  217b				  -	      bit	VSYNC
     13  217b					      ENDIF
     14  217b				   .CYCLES    SET	.CYCLES - 3
     15  217b					      ENDIF
     16  217b
     17  217b					      REPEAT	.CYCLES / 2
     18  217b		       ea		      nop
     17  217b					      REPEND
     18  217c		       ea		      nop
     19  217d					      REPEND
   1827  217d				   KernelLoopb		;	54
      0  217d					      SLEEP	2	;+12	66
      1  217d				   .CYCLES    SET	2
      2  217d
      3  217d				  -	      IF	.CYCLES < 2
      4  217d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217d				  -	      ERR
      6  217d					      ENDIF
      7  217d
      8  217d				  -	      IF	.CYCLES & 1
      9  217d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217d				  -	      nop	0
     11  217d				  -	      ELSE
     12  217d				  -	      bit	VSYNC
     13  217d				  -	      ENDIF
     14  217d				  -.CYCLES    SET	.CYCLES - 3
     15  217d					      ENDIF
     16  217d
     17  217d					      REPEAT	.CYCLES / 2
     18  217d		       ea		      nop
     19  217e					      REPEND
   1829  217e		       c4 cf		      cpy	P0Top	;+3	69
   1830  2180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
   1831  2182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
   1832  2184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
   1833  2186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
   1834  2188				   BackFromSwitchDrawP0K1
   1835  2188
   1836  2188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
   1837  218a							;		to a value greater than maximum Y value initially
   1838  218a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
   1839  218c		       b1 cc		      lda	(P1display),Y	;+5	15
   1840  218e		       8d 1c 00 	      sta.w	GRP1	;+4	19
   1841  2191				   BackFromSkipDrawP1
   1842  2191
   1843  2191							;fuck	
   1844  2191		       84 cb		      sty	temp1
   1845  2193		       a4 ba		      ldy	pfpixelheight
   1846  2195		       b3 bb		      lax	(PF1pointer),y
   1847  2197		       86 0e		      stx	PF1	;+7	26
   1848  2199		       b1 bd		      lda	(PF2pointer),y
   1849  219b		       85 0f		      sta	PF2	;+7	33
   1850  219d							;sleep 6
   1851  219d		       86 b7		      stx	PF1temp2
   1852  219f		       85 b9		      sta	PF2temp2
   1853  21a1		       88		      dey
   1854  21a2		       30 35		      bmi	pagewraphandler
   1855  21a4		       b1 bb		      lda	(PF1pointer),y
   1856  21a6				   cyclebalance
   1857  21a6		       85 b6		      sta	PF1temp1
   1858  21a8		       b1 bd		      lda	(PF2pointer),y
   1859  21aa		       85 b8		      sta	PF2temp1
   1860  21ac		       a4 cb		      ldy	temp1
   1861  21ae
   1862  21ae		       a2 1f		      ldx	#ENABL
   1863  21b0		       9a		      txs
   1864  21b1		       c4 8c		      cpy	bally
   1865  21b3		       08		      php		;+6	39	VDEL ball
   1866  21b4
   1867  21b4
   1868  21b4		       c4 8b		      cpy	missile1y
   1869  21b6		       08		      php		;+6	71
   1870  21b7
   1871  21b7		       c4 8a		      cpy	missile0y
   1872  21b9		       08		      php		;+6	 1
   1873  21ba
   1874  21ba
   1875  21ba		       88		      dey		;+2	15
   1876  21bb
   1877  21bb		       c4 ce		      cpy	RepoLine	;+3	18
   1878  21bd		       f0 62		      beq	RepoKernel	;+2	20
   1879  21bf							;	SLEEP 20		;+23	43
      0  21bf					      sleep	6
      1  21bf				   .CYCLES    SET	6
      2  21bf
      3  21bf				  -	      IF	.CYCLES < 2
      4  21bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21bf				  -	      ERR
      6  21bf					      ENDIF
      7  21bf
      8  21bf				  -	      IF	.CYCLES & 1
      9  21bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21bf				  -	      nop	0
     11  21bf				  -	      ELSE
     12  21bf				  -	      bit	VSYNC
     13  21bf				  -	      ENDIF
     14  21bf				  -.CYCLES    SET	.CYCLES - 3
     15  21bf					      ENDIF
     16  21bf
     17  21bf					      REPEAT	.CYCLES / 2
     18  21bf		       ea		      nop
     17  21bf					      REPEND
     18  21c0		       ea		      nop
     17  21c0					      REPEND
     18  21c1		       ea		      nop
     19  21c2					      REPEND
   1881  21c2
   1882  21c2				   newrepo		; since we have time here, store next repoline
   1883  21c2		       a6 83		      ldx	SpriteIndex
   1884  21c4		       b5 9c		      lda	SpriteGfxIndex-1,x
   1885  21c6		       aa		      tax
   1886  21c7		       b5 8e		      lda	NewSpriteY,x
   1887  21c9		       85 d0		      sta	temp6
      0  21cb					      sleep	4
      1  21cb				   .CYCLES    SET	4
      2  21cb
      3  21cb				  -	      IF	.CYCLES < 2
      4  21cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21cb				  -	      ERR
      6  21cb					      ENDIF
      7  21cb
      8  21cb				  -	      IF	.CYCLES & 1
      9  21cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21cb				  -	      nop	0
     11  21cb				  -	      ELSE
     12  21cb				  -	      bit	VSYNC
     13  21cb				  -	      ENDIF
     14  21cb				  -.CYCLES    SET	.CYCLES - 3
     15  21cb					      ENDIF
     16  21cb
     17  21cb					      REPEAT	.CYCLES / 2
     18  21cb		       ea		      nop
     17  21cb					      REPEND
     18  21cc		       ea		      nop
     19  21cd					      REPEND
   1889  21cd
   1890  21cd				   BackFromRepoKernel
   1891  21cd		       98		      tya		;+2	45
   1892  21ce		       25 c4		      and	pfheight	;+2	47
   1893  21d0		       d0 a7		      bne	KernelLoopa	;+2	49
   1894  21d2		       c6 ba		      dec	pfpixelheight
   1895  21d4		       10 a7		      bpl	KernelLoopb	;+3	54
   1896  21d6							;	bmi donewkernel		;+3	54
   1897  21d6							;	bne KernelLoopb+1		;+3	54
   1898  21d6
   1899  21d6				   donewkernel
   1900  21d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
   1901  21d9
   1902  21d9				   pagewraphandler
   1903  21d9		       4c a6 f1 	      jmp	cyclebalance
   1904  21dc
   1905  21dc							;-------------------------------------------------------------------------
   1906  21dc
   1907  21dc							; room here for score?
   1908  21dc
   1909  21dc				   setscorepointers
   1910  21dc		       a7 d4		      lax	score+2
   1911  21de		       20 f8 f1 	      jsr	scorepointerset
   1912  21e1		       84 ca		      sty	scorepointers+5
   1913  21e3		       86 c7		      stx	scorepointers+2
   1914  21e5		       a7 d3		      lax	score+1
   1915  21e7		       20 f8 f1 	      jsr	scorepointerset
   1916  21ea		       84 c9		      sty	scorepointers+4
   1917  21ec		       86 c6		      stx	scorepointers+1
   1918  21ee		       a7 d2		      lax	score
   1919  21f0		       20 f8 f1 	      jsr	scorepointerset
   1920  21f3		       84 c8		      sty	scorepointers+3
   1921  21f5		       86 c5		      stx	scorepointers
   1922  21f7				   wastetime
   1923  21f7		       60		      rts
   1924  21f8
   1925  21f8				   scorepointerset
   1926  21f8		       29 0f		      and	#$0F
   1927  21fa		       0a		      asl
   1928  21fb		       0a		      asl
   1929  21fc		       0a		      asl
   1930  21fd		       69 74		      adc	#<scoretable
   1931  21ff		       a8		      tay
   1932  2200		       8a		      txa
   1933  2201		       29 f0		      and	#$F0
   1934  2203		       4a		      lsr
   1935  2204		       69 74		      adc	#<scoretable
   1936  2206		       aa		      tax
   1937  2207		       60		      rts
   1938  2208							;	align 256
   1939  2208
   1940  2208				   SwitchDrawP0KR		;	45
   1941  2208		       a5 a4		      lda	P0Bottom
   1942  220a		       85 cf		      sta	P0Top	;+6	51
   1943  220c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1944  220f
   1945  220f				   WaitDrawP0KR 		;	47
      0  220f					      SLEEP	4	;+4	51
      1  220f				   .CYCLES    SET	4
      2  220f
      3  220f				  -	      IF	.CYCLES < 2
      4  220f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  220f				  -	      ERR
      6  220f					      ENDIF
      7  220f
      8  220f				  -	      IF	.CYCLES & 1
      9  220f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  220f				  -	      nop	0
     11  220f				  -	      ELSE
     12  220f				  -	      bit	VSYNC
     13  220f				  -	      ENDIF
     14  220f				  -.CYCLES    SET	.CYCLES - 3
     15  220f					      ENDIF
     16  220f
     17  220f					      REPEAT	.CYCLES / 2
     18  220f		       ea		      nop
     17  220f					      REPEND
     18  2210		       ea		      nop
     19  2211					      REPEND
   1947  2211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1948  2214
   1949  2214							;-----------------------------------------------------------
   1950  2214
   1951  2214				   noUpdateXKR
   1952  2214		       a2 01		      ldx	#1
   1953  2216		       cc cf 00 	      cpy.w	P0Top
   1954  2219		       4c 2b f2 	      JMP	retXKR
   1955  221c
   1956  221c				   skipthis
   1957  221c		       a2 01		      ldx	#1
   1958  221e		       4c 6d f2 	      jmp	goback
   1959  2221
   1960  2221				   RepoKernel		;	22	crosses page boundary
   1961  2221		       98		      tya
   1962  2222		       25 c4		      and	pfheight	;+2	26
   1963  2224		       d0 ee		      bne	noUpdateXKR	;+2	28
   1964  2226		       aa		      tax
   1965  2227							;	dex			;+2	30
   1966  2227		       c6 ba		      dec	pfpixelheight
   1967  2229							;	stx Temp		;+3	35
   1968  2229							;	SLEEP 3
   1969  2229
   1970  2229		       c4 cf		      cpy	P0Top	;+3	42
   1971  222b				   retXKR
   1972  222b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
   1973  222d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
   1974  222f		       b1 a2		      lda	(player0pointer),Y	;+5	51
   1975  2231		       85 1b		      sta	GRP0	;+3	54	VDEL
   1976  2233				   BackFromSwitchDrawP0KR
   1977  2233		       38		      sec		;+2	56
   1978  2234
   1979  2234
   1980  2234
   1981  2234		       b5 b8		      lda	PF2temp1,X
   1982  2236		       b4 b6		      ldy	PF1temp1,X
   1983  2238
   1984  2238		       a6 83		      ldx	SpriteIndex	;+3	 2
   1985  223a
   1986  223a		       85 0f		      sta	PF2	;+7	63
   1987  223c
   1988  223c		       b5 9d		      lda	SpriteGfxIndex,x
   1989  223e		       84 0e		      sty	PF1	;+7	70	too early?
   1990  2240		       aa		      tax
   1991  2241		       a9 00		      lda	#0
   1992  2243		       85 1c		      sta	GRP1	;+5	75	to display player 0
   1993  2245		       b5 85		      lda	NewSpriteX,X	;+4	 6
   1994  2247
   1995  2247				   DivideBy15LoopK		;	 6	(carry set above)
   1996  2247		       e9 0f		      sbc	#15
   1997  2249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
   1998  224b
   1999  224b		       aa		      tax		;+2	12/17/...62
   2000  224c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
   2001  224f
   2002  224f		       85 21		      sta	HMP1	;+3	20/25/...70
   2003  2251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
   2004  2253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   2005  2255							;sta HMOVE			;+3	 3
   2006  2255
   2007  2255		       a2 1f		      ldx	#ENABL
   2008  2257		       9a		      txs		;+4	25
   2009  2258		       a4 ce		      ldy	RepoLine	; restore y
   2010  225a		       c4 8c		      cpy	bally
   2011  225c		       08		      php		;+6	 9	VDEL ball
   2012  225d
   2013  225d		       c4 8b		      cpy	missile1y
   2014  225f		       08		      php		;+6	15
   2015  2260
   2016  2260		       c4 8a		      cpy	missile0y
   2017  2262		       08		      php		;+6	21
   2018  2263
   2019  2263
   2020  2263
   2021  2263
   2022  2263
   2023  2263							;15 cycles
   2024  2263		       98		      tya
   2025  2264		       25 c4		      and	pfheight
   2026  2266							;eor #1
   2027  2266		       29 fe		      and	#$FE
   2028  2268		       d0 b2		      bne	skipthis
   2029  226a		       aa		      tax
      0  226b					      sleep	4
      1  226b				   .CYCLES    SET	4
      2  226b
      3  226b				  -	      IF	.CYCLES < 2
      4  226b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  226b				  -	      ERR
      6  226b					      ENDIF
      7  226b
      8  226b				  -	      IF	.CYCLES & 1
      9  226b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  226b				  -	      nop	0
     11  226b				  -	      ELSE
     12  226b				  -	      bit	VSYNC
     13  226b				  -	      ENDIF
     14  226b				  -.CYCLES    SET	.CYCLES - 3
     15  226b					      ENDIF
     16  226b
     17  226b					      REPEAT	.CYCLES / 2
     18  226b		       ea		      nop
     17  226b					      REPEND
     18  226c		       ea		      nop
     19  226d					      REPEND
   2031  226d							;	sleep 2
   2032  226d				   goback
   2033  226d
   2034  226d		       88		      dey
   2035  226e		       c4 cf		      cpy	P0Top	;+3	52
   2036  2270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
   2037  2272		       10 67		      bpl	WaitDrawP0KV	;+2	56
   2038  2274		       b1 a2		      lda	(player0pointer),Y	;+5	61
   2039  2276		       85 1b		      sta	GRP0	;+3	64	VDEL
   2040  2278				   BackFromSwitchDrawP0KV
   2041  2278
   2042  2278							; sleep 3
   2043  2278
   2044  2278		       b5 b8		      lda	PF2temp1,X
   2045  227a		       85 0f		      sta	PF2	;+7	 5
   2046  227c		       b5 b6		      lda	PF1temp1,X
   2047  227e		       85 0e		      sta	PF1	;+7	74 
   2048  2280		       85 2a		      sta	HMOVE
   2049  2282
   2050  2282		       a9 00		      lda	#0
   2051  2284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
   2052  2286
   2053  2286		       a2 1f		      ldx	#ENABL
   2054  2288		       9a		      txs		;+4	 8
   2055  2289
   2056  2289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
   2057  228b							;--now, set all new variables and return to main kernel loop
   2058  228b
   2059  228b
   2060  228b							;
   2061  228b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
   2062  228d		       aa		      tax		;+2	33
   2063  228e							;
   2064  228e
   2065  228e
   2066  228e
   2067  228e		       b5 93		      lda	NewNUSIZ,X
   2068  2290		       85 05		      sta	NUSIZ1	;+7	20
   2069  2292		       85 0c		      sta	REFP1
   2070  2294		       b5 98		      lda	NewCOLUP1,X
   2071  2296		       85 07		      sta	COLUP1	;+7	27
   2072  2298
   2073  2298							;	lda SpriteGfxIndex,X	;+4	31
   2074  2298							;	tax				;+2	33
   2075  2298							;fuck2
   2076  2298		       b5 8e		      lda	NewSpriteY,X	;+4	46
   2077  229a		       38		      sec		;+2	38
   2078  229b		       f5 b1		      sbc	spriteheight,X	;+4	42
   2079  229d		       85 a5		      sta	P1Bottom	;+3	45
   2080  229f
      0  229f					      sleep	6
      1  229f				   .CYCLES    SET	6
      2  229f
      3  229f				  -	      IF	.CYCLES < 2
      4  229f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  229f				  -	      ERR
      6  229f					      ENDIF
      7  229f
      8  229f				  -	      IF	.CYCLES & 1
      9  229f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  229f				  -	      nop	0
     11  229f				  -	      ELSE
     12  229f				  -	      bit	VSYNC
     13  229f				  -	      ENDIF
     14  229f				  -.CYCLES    SET	.CYCLES - 3
     15  229f					      ENDIF
     16  229f
     17  229f					      REPEAT	.CYCLES / 2
     18  229f		       ea		      nop
     17  229f					      REPEND
     18  22a0		       ea		      nop
     17  22a0					      REPEND
     18  22a1		       ea		      nop
     19  22a2					      REPEND
   2082  22a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
   2083  22a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
   2084  22a6		       85 cc		      sta	P1display	;+3	55
   2085  22a8		       b5 ab		      lda	player1pointerhi,X
   2086  22aa		       85 cd		      sta	P1display+1	;+7	62
   2087  22ac
   2088  22ac
   2089  22ac		       c4 8c		      cpy	bally
   2090  22ae		       08		      php		;+6	68	VDELed
   2091  22af
   2092  22af		       c4 8b		      cpy	missile1y
   2093  22b1		       08		      php		;+6	74
   2094  22b2
   2095  22b2		       c4 8a		      cpy	missile0y
   2096  22b4		       08		      php		;+6	 4
   2097  22b5
   2098  22b5
   2099  22b5
   2100  22b5							; lda SpriteGfxIndex-1,x
   2101  22b5							; sleep 3
   2102  22b5		       c6 83		      dec	SpriteIndex	;+5	13
   2103  22b7							; tax
   2104  22b7							; lda NewSpriteY,x
   2105  22b7							; sta RepoLine
   2106  22b7
   2107  22b7							; 10 cycles below...
   2108  22b7		       10 05		      bpl	SetNextLine
   2109  22b9		       a9 ff		      lda	#255
   2110  22bb		       4c c1 f2 	      jmp	SetLastLine
   2111  22be				   SetNextLine
   2112  22be							;	lda NewSpriteY-1,x
   2113  22be		       ad d0 00 	      lda.w	temp6
   2114  22c1				   SetLastLine
   2115  22c1		       85 ce		      sta	RepoLine
   2116  22c3
   2117  22c3		       98		      tya
   2118  22c4		       25 c4		      and	pfheight
   2119  22c6		       d0 06		      bne	nodec
   2120  22c8		       c6 ba		      dec	pfpixelheight
   2121  22ca		       88		      dey		;+2	30
   2122  22cb
   2123  22cb							; 10 cycles 
   2124  22cb
   2125  22cb
   2126  22cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
   2127  22ce
   2128  22ce				   nodec
      0  22ce					      sleep	4
      1  22ce				   .CYCLES    SET	4
      2  22ce
      3  22ce				  -	      IF	.CYCLES < 2
      4  22ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22ce				  -	      ERR
      6  22ce					      ENDIF
      7  22ce
      8  22ce				  -	      IF	.CYCLES & 1
      9  22ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22ce				  -	      nop	0
     11  22ce				  -	      ELSE
     12  22ce				  -	      bit	VSYNC
     13  22ce				  -	      ENDIF
     14  22ce				  -.CYCLES    SET	.CYCLES - 3
     15  22ce					      ENDIF
     16  22ce
     17  22ce					      REPEAT	.CYCLES / 2
     18  22ce		       ea		      nop
     17  22ce					      REPEND
     18  22cf		       ea		      nop
     19  22d0					      REPEND
   2130  22d0		       88		      dey
   2131  22d1		       4c cd f1 	      jmp	BackFromRepoKernel
   2132  22d4
   2133  22d4							;-------------------------------------------------------------------------
   2134  22d4
   2135  22d4
   2136  22d4				   SwitchDrawP0KV		;	69
   2137  22d4		       a5 a4		      lda	P0Bottom
   2138  22d6		       85 cf		      sta	P0Top	;+6	75
   2139  22d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2140  22db
   2141  22db				   WaitDrawP0KV 		;	71
      0  22db					      SLEEP	4	;+4	75
      1  22db				   .CYCLES    SET	4
      2  22db
      3  22db				  -	      IF	.CYCLES < 2
      4  22db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22db				  -	      ERR
      6  22db					      ENDIF
      7  22db
      8  22db				  -	      IF	.CYCLES & 1
      9  22db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22db				  -	      nop	0
     11  22db				  -	      ELSE
     12  22db				  -	      bit	VSYNC
     13  22db				  -	      ENDIF
     14  22db				  -.CYCLES    SET	.CYCLES - 3
     15  22db					      ENDIF
     16  22db
     17  22db					      REPEAT	.CYCLES / 2
     18  22db		       ea		      nop
     17  22db					      REPEND
     18  22dc		       ea		      nop
     19  22dd					      REPEND
   2143  22dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2144  22e0
   2145  22e0							;-------------------------------------------------------------------------
   2146  22e0
   2147  22e0				   DoneWithKernel
   2148  22e0
   2149  22e0				   BottomOfKernelLoop
   2150  22e0
   2151  22e0		       85 02		      sta	WSYNC
   2152  22e2		       a6 f6		      ldx	stack1
   2153  22e4		       9a		      txs
   2154  22e5		       20 04 f1 	      jsr	sixdigscore	; set up score
   2155  22e8
   2156  22e8
   2157  22e8		       85 02		      sta	WSYNC
   2158  22ea		       a2 00		      ldx	#0
   2159  22ec		       85 2b		      sta	HMCLR
   2160  22ee		       86 1b		      STx	GRP0
   2161  22f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2162  22f2
   2163  22f2		       a0 07		      LDY	#7
   2164  22f4		       84 25		      STy	VDELP0
   2165  22f6		       84 26		      STy	VDELP1
   2166  22f8		       a9 10		      LDA	#$10
   2167  22fa		       85 21		      STA	HMP1
   2168  22fc		       a5 d5		      LDA	scorecolor
   2169  22fe		       85 06		      STA	COLUP0
   2170  2300		       85 07		      STA	COLUP1
   2171  2302
   2172  2302		       a9 03		      LDA	#$03
   2173  2304		       85 04		      STA	NUSIZ0
   2174  2306		       85 05		      STA	NUSIZ1
   2175  2308
   2176  2308		       85 10		      STA	RESP0
   2177  230a		       85 11		      STA	RESP1
   2178  230c
      0  230c					      sleep	9
      1  230c				   .CYCLES    SET	9
      2  230c
      3  230c				  -	      IF	.CYCLES < 2
      4  230c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  230c				  -	      ERR
      6  230c					      ENDIF
      7  230c
      8  230c					      IF	.CYCLES & 1
      9  230c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  230c		       04 00		      nop	0
     11  230e				  -	      ELSE
     12  230e				  -	      bit	VSYNC
     13  230e					      ENDIF
     14  230e				   .CYCLES    SET	.CYCLES - 3
     15  230e					      ENDIF
     16  230e
     17  230e					      REPEAT	.CYCLES / 2
     18  230e		       ea		      nop
     17  230e					      REPEND
     18  230f		       ea		      nop
     17  230f					      REPEND
     18  2310		       ea		      nop
     19  2311					      REPEND
   2180  2311		       b1 c5		      lda	(scorepointers),y
   2181  2313		       85 1b		      sta	GRP0
   2182  2315					      ifconst	pfscore
   2183  2315		       a5 c0		      lda	pfscorecolor
   2184  2317		       85 08		      sta	COLUPF
   2185  2319				  -	      else
   2186  2319				  -	      sleep	6
   2187  2319					      endif
   2188  2319
   2189  2319		       85 2a		      STA	HMOVE
   2190  231b		       b1 cd		      lda	(scorepointers+8),y
   2191  231d							; sta WSYNC
   2192  231d							;sleep 2
   2193  231d		       4c 2b f3 	      jmp	beginscore
   2194  2320
   2195  2320
   2196  2320				   loop2
   2197  2320		       b1 c5		      lda	(scorepointers),y	;+5  68  204
   2198  2322		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
   2199  2324					      ifconst	pfscore
   2200  2324		       ad c1 00 	      lda.w	pfscore1
   2201  2327		       85 0e		      sta	PF1
   2202  2329				  -	      else
   2203  2329				  -	      sleep	7
   2204  2329					      endif
   2205  2329							; cycle 0
   2206  2329		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
   2207  232b				   beginscore
   2208  232b		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
   2209  232d		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
   2210  232f		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
   2211  2331		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
   2212  2333		       9a		      txs
   2213  2334		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  2336					      sleep	3
      1  2336				   .CYCLES    SET	3
      2  2336
      3  2336				  -	      IF	.CYCLES < 2
      4  2336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2336				  -	      ERR
      6  2336					      ENDIF
      7  2336
      8  2336					      IF	.CYCLES & 1
      9  2336					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2336		       04 00		      nop	0
     11  2338				  -	      ELSE
     12  2338				  -	      bit	VSYNC
     13  2338					      ENDIF
     14  2338				   .CYCLES    SET	.CYCLES - 3
     15  2338					      ENDIF
     16  2338
     17  2338				  -	      REPEAT	.CYCLES / 2
     18  2338				  -	      nop
     19  2338					      REPEND
   2215  2338					      ifconst	pfscore
   2216  2338		       a5 c2		      lda	pfscore2
   2217  233a		       85 0e		      sta	PF1
   2218  233c				  -	      else
   2219  233c				  -	      sleep	6
   2220  233c					      endif
   2221  233c		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
   2222  233e		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
   2223  2340		       ba		      tsx
   2224  2341		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
   2225  2343		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
   2226  2345		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
   2227  2347		       88		      dey
   2228  2348		       10 d6		      bpl	loop2	;+2  60  180
   2229  234a		       a6 f6		      ldx	stack1
   2230  234c		       9a		      txs
   2231  234d
   2232  234d
   2233  234d							; lda scorepointers+1
   2234  234d		       a4 cb		      ldy	temp1
   2235  234f							; sta temp1
   2236  234f		       84 c6		      sty	scorepointers+1
   2237  2351
   2238  2351		       a9 00		      LDA	#0
   2239  2353		       85 1b		      STA	GRP0
   2240  2355		       85 1c		      STA	GRP1
   2241  2357		       85 0e		      sta	PF1
   2242  2359		       85 25		      STA	VDELP0
   2243  235b		       85 26		      STA	VDELP1	;do we need these
   2244  235d		       85 04		      STA	NUSIZ0
   2245  235f		       85 05		      STA	NUSIZ1
   2246  2361
   2247  2361							; lda scorepointers+3
   2248  2361		       a4 cd		      ldy	temp3
   2249  2363							; sta temp3
   2250  2363		       84 c8		      sty	scorepointers+3
   2251  2365
   2252  2365							; lda scorepointers+5
   2253  2365		       a4 cf		      ldy	temp5
   2254  2367							; sta temp5
   2255  2367		       84 ca		      sty	scorepointers+5
   2256  2369
   2257  2369
   2258  2369							;-------------------------------------------------------------------------
   2259  2369							;------------------------Overscan Routine---------------------------------
   2260  2369							;-------------------------------------------------------------------------
   2261  2369
   2262  2369				   OverscanRoutine
   2263  2369
   2264  2369
   2265  2369
   2266  2369				   skipscore
   2267  2369		       a9 02		      lda	#2
   2268  236b		       85 02		      sta	WSYNC
   2269  236d		       85 01		      sta	VBLANK	;turn on VBLANK
   2270  236f
   2271  236f
   2272  236f
   2273  236f
   2274  236f
   2275  236f							;-------------------------------------------------------------------------
   2276  236f							;----------------------------End Main Routines----------------------------
   2277  236f							;-------------------------------------------------------------------------
   2278  236f
   2279  236f
   2280  236f							;*************************************************************************
   2281  236f
   2282  236f							;-------------------------------------------------------------------------
   2283  236f							;----------------------Begin Subroutines----------------------------------
   2284  236f							;-------------------------------------------------------------------------
   2285  236f
   2286  236f
   2287  236f
   2288  236f
   2289  236f				   KernelCleanupSubroutine
   2290  236f
   2291  236f		       a2 04		      ldx	#4
   2292  2371				   AdjustYValuesDownLoop
   2293  2371		       b5 8e		      lda	NewSpriteY,X
   2294  2373		       38		      sec
   2295  2374		       e9 02		      sbc	#2
   2296  2376		       95 8e		      sta	NewSpriteY,X
   2297  2378		       ca		      dex
   2298  2379		       10 f6		      bpl	AdjustYValuesDownLoop
   2299  237b
   2300  237b
      0  237b					      RETURN
      1  237b				  -	      ifnconst	bankswitch
      2  237b				  -	      rts
      3  237b					      else
      4  237b		       4c dd ff 	      jmp	BS_return
      5  237e					      endif
   2302  237e							;rts
   2303  237e
   2304  237e				   SetupP1Subroutine
   2305  237e							; flickersort algorithm
   2306  237e							; count 4-0
   2307  237e							; table2=table1 (?)
   2308  237e							; detect overlap of sprites in table 2
   2309  237e							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
   2310  237e							; if no overlap, do regular sort in table 2 and table 1
   2311  237e				   fsstart
   2312  237e		       a2 ff		      ldx	#255
   2313  2380				   copytable
   2314  2380		       e8		      inx
   2315  2381		       b5 f1		      lda	spritesort,x
   2316  2383		       95 9d		      sta	SpriteGfxIndex,x
   2317  2385		       e0 04		      cpx	#4
   2318  2387		       d0 f7		      bne	copytable
   2319  2389
   2320  2389		       86 cd		      stx	temp3	; highest displayed sprite
   2321  238b		       ca		      dex
   2322  238c		       86 cc		      stx	temp2
   2323  238e				   sortloop
   2324  238e		       a6 cc		      ldx	temp2
   2325  2390		       b5 f1		      lda	spritesort,x
   2326  2392		       aa		      tax
   2327  2393		       b5 8e		      lda	NewSpriteY,x
   2328  2395		       85 cb		      sta	temp1
   2329  2397
   2330  2397		       a6 cc		      ldx	temp2
   2331  2399		       b5 f2		      lda	spritesort+1,x
   2332  239b		       aa		      tax
   2333  239c		       b5 8e		      lda	NewSpriteY,x
   2334  239e		       38		      sec
   2335  239f		       18		      clc
   2336  23a0		       e5 cb		      sbc	temp1
   2337  23a2		       90 0e		      bcc	largerXislower
   2338  23a4
   2339  23a4							; larger x is higher (A>=temp1)
   2340  23a4		       d5 b1		      cmp	spriteheight,x
   2341  23a6		       b0 2f		      bcs	countdown
   2342  23a8							; overlap with x+1>x
   2343  23a8							; 
   2344  23a8							; stick x at end of gfxtable, dec counter
   2345  23a8				   overlapping
   2346  23a8		       c6 cd		      dec	temp3
   2347  23aa		       a6 cc		      ldx	temp2
   2348  23ac							; inx
   2349  23ac		       20 eb f3 	      jsr	shiftnumbers
   2350  23af		       4c cd f3 	      jmp	skipswapGfxtable
   2351  23b2
   2352  23b2				   largerXislower		; (temp1>A)
   2353  23b2		       a8		      tay
   2354  23b3		       a6 cc		      ldx	temp2
   2355  23b5		       b5 f1		      lda	spritesort,x
   2356  23b7		       aa		      tax
   2357  23b8		       98		      tya
   2358  23b9		       49 ff		      eor	#$FF
   2359  23bb		       e9 01		      sbc	#1
   2360  23bd		       90 e9		      bcc	overlapping
   2361  23bf		       d5 b1		      cmp	spriteheight,x
   2362  23c1		       b0 0a		      bcs	notoverlapping
   2363  23c3
   2364  23c3		       c6 cd		      dec	temp3
   2365  23c5		       a6 cc		      ldx	temp2
   2366  23c7							; inx
   2367  23c7		       20 eb f3 	      jsr	shiftnumbers
   2368  23ca		       4c cd f3 	      jmp	skipswapGfxtable
   2369  23cd				   notoverlapping
   2370  23cd							; ldx temp2 ; swap display table
   2371  23cd							; ldy SpriteGfxIndex+1,x
   2372  23cd							; lda SpriteGfxIndex,x
   2373  23cd							; sty SpriteGfxIndex,x
   2374  23cd							; sta SpriteGfxIndex+1,x 
   2375  23cd
   2376  23cd				   skipswapGfxtable
   2377  23cd		       a6 cc		      ldx	temp2	; swap sort table
   2378  23cf		       b4 f2		      ldy	spritesort+1,x
   2379  23d1		       b5 f1		      lda	spritesort,x
   2380  23d3		       94 f1		      sty	spritesort,x
   2381  23d5		       95 f2		      sta	spritesort+1,x
   2382  23d7
   2383  23d7				   countdown
   2384  23d7		       c6 cc		      dec	temp2
   2385  23d9		       10 b3		      bpl	sortloop
   2386  23db
   2387  23db				   checktoohigh
   2388  23db		       a6 cd		      ldx	temp3
   2389  23dd		       b5 9d		      lda	SpriteGfxIndex,x
   2390  23df		       aa		      tax
   2391  23e0		       b5 8e		      lda	NewSpriteY,x
   2392  23e2				  -	      ifconst	screenheight
   2393  23e2				  -	      cmp	#screenheight-3
   2394  23e2					      else
   2395  23e2		       c9 55		      cmp	#$55
   2396  23e4					      endif
   2397  23e4		       90 04		      bcc	nonetoohigh
   2398  23e6		       c6 cd		      dec	temp3
   2399  23e8		       d0 f1		      bne	checktoohigh
   2400  23ea
   2401  23ea				   nonetoohigh
   2402  23ea		       60		      rts
   2403  23eb
   2404  23eb
   2405  23eb				   shiftnumbers
   2406  23eb							; stick current x at end, shift others down
   2407  23eb							; if x=4: don't do anything
   2408  23eb							; if x=3: swap 3 and 4
   2409  23eb							; if x=2: 2=3, 3=4, 4=2
   2410  23eb							; if x=1: 1=2, 2=3, 3=4, 4=1
   2411  23eb							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   2412  23eb							; ldy SpriteGfxIndex,x
   2413  23eb				   swaploop
   2414  23eb		       e0 04		      cpx	#4
   2415  23ed		       f0 08		      beq	shiftdone
   2416  23ef		       b5 9e		      lda	SpriteGfxIndex+1,x
   2417  23f1		       95 9d		      sta	SpriteGfxIndex,x
   2418  23f3		       e8		      inx
   2419  23f4		       4c eb f3 	      jmp	swaploop
   2420  23f7				   shiftdone
   2421  23f7							; sty SpriteGfxIndex,x
   2422  23f7		       60		      rts
   2423  23f8
   2424  23f8				  -	      ifconst	debugscore
   2425  23f8				  -debugcycles
   2426  23f8				  -	      ldx	#14
   2427  23f8				  -	      lda	INTIM	; display # cycles left in the score
   2428  23f8				  -
   2429  23f8				  -	      ifconst	mincycles
   2430  23f8				  -	      lda	mincycles
   2431  23f8				  -	      cmp	INTIM
   2432  23f8				  -	      lda	mincycles
   2433  23f8				  -	      bcc	nochange
   2434  23f8				  -	      lda	INTIM
   2435  23f8				  -	      sta	mincycles
   2436  23f8				  -nochange
   2437  23f8				  -	      endif
   2438  23f8				  -
   2439  23f8				  -			;   cmp #$2B
   2440  23f8				  -			;   bcs no_cycles_left
   2441  23f8				  -	      bmi	cycles_left
   2442  23f8				  -	      ldx	#64
   2443  23f8				  -	      eor	#$ff	;make negative
   2444  23f8				  -cycles_left
   2445  23f8				  -	      stx	scorecolor
   2446  23f8				  -	      and	#$7f	; clear sign bit
   2447  23f8				  -	      tax
   2448  23f8				  -	      lda	scorebcd,x
   2449  23f8				  -	      sta	score+2
   2450  23f8				  -	      lda	scorebcd1,x
   2451  23f8				  -	      sta	score+1
   2452  23f8				  -	      rts
   2453  23f8				  -scorebcd
   2454  23f8				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2455  23f8				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2456  23f8				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2457  23f8				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2458  23f8				  -scorebcd1
   2459  23f8				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2460  23f8				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2461  23f8				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2462  23f8				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2463  23f8					      endif
   2464  23f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2465  23f8
   2466  23f8				   start
   2467  23f8		       78		      sei
   2468  23f9		       d8		      cld
   2469  23fa		       a0 00		      ldy	#0
   2470  23fc		       a5 d0		      lda	$D0
   2471  23fe		       c9 2c		      cmp	#$2C	;check RAM location #1
   2472  2400		       d0 07		      bne	MachineIs2600
   2473  2402		       a5 d1		      lda	$D1
   2474  2404		       c9 a9		      cmp	#$A9	;check RAM location #2
   2475  2406		       d0 01		      bne	MachineIs2600
   2476  2408		       88		      dey
   2477  2409				   MachineIs2600
   2478  2409		       a2 00		      ldx	#0
   2479  240b		       8a		      txa
   2480  240c				   clearmem
   2481  240c		       e8		      inx
   2482  240d		       9a		      txs
   2483  240e		       48		      pha
   2484  240f		       d0 fb		      bne	clearmem
   2485  2411		       84 cb		      sty	temp1
   2486  2413				  -	      ifnconst	multisprite
   2487  2413				  -	      ifconst	pfrowheight
   2488  2413				  -	      lda	#pfrowheight
   2489  2413				  -	      else
   2490  2413				  -	      ifconst	pfres
   2491  2413				  -	      lda	#(96/pfres)
   2492  2413				  -	      else
   2493  2413				  -	      lda	#8
   2494  2413				  -	      endif
   2495  2413				  -	      endif
   2496  2413				  -	      sta	playfieldpos
   2497  2413					      endif
   2498  2413		       a2 05		      ldx	#5
   2499  2415				   initscore
   2500  2415		       a9 74		      lda	#<scoretable
   2501  2417		       95 c5		      sta	scorepointers,x
   2502  2419		       ca		      dex
   2503  241a		       10 f9		      bpl	initscore
   2504  241c		       a9 01		      lda	#1
   2505  241e		       85 0a		      sta	CTRLPF
   2506  2420		       0d 84 02 	      ora	INTIM
   2507  2423		       85 d6		      sta	rand
   2508  2425
   2509  2425					      ifconst	multisprite
   2510  2425		       20 1f f0 	      jsr	multisprite_setup
   2511  2428					      endif
   2512  2428
   2513  2428				  -	      ifnconst	bankswitch
   2514  2428				  -	      jmp	game
   2515  2428					      else
   2516  2428		       a9 cf		      lda	#>(game-1)
   2517  242a		       48		      pha
   2518  242b		       a9 ff		      lda	#<(game-1)
   2519  242d		       48		      pha
   2520  242e		       48		      pha
   2521  242f		       48		      pha
   2522  2430		       a2 01		      ldx	#1
   2523  2432		       4c eb ff 	      jmp	BS_jsr
   2524  2435					      endif
   2525  2435							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2526  2435
   2527  2435							;standard routines needed for pretty much all games
   2528  2435							; just the random number generator is left - maybe we should remove this asm file altogether?
   2529  2435							; repositioning code and score pointer setup moved to overscan
   2530  2435							; read switches, joysticks now compiler generated (more efficient)
   2531  2435
   2532  2435				   randomize
   2533  2435		       a5 d6		      lda	rand
   2534  2437		       4a		      lsr
   2535  2438				  -	      ifconst	rand16
   2536  2438				  -	      rol	rand16
   2537  2438					      endif
   2538  2438		       90 02		      bcc	noeor
   2539  243a		       49 b4		      eor	#$B4
   2540  243c				   noeor
   2541  243c		       85 d6		      sta	rand
   2542  243e				  -	      ifconst	rand16
   2543  243e				  -	      eor	rand16
   2544  243e					      endif
      0  243e					      RETURN
      1  243e				  -	      ifnconst	bankswitch
      2  243e				  -	      rts
      3  243e					      else
      4  243e		       4c dd ff 	      jmp	BS_return
      5  2441					      endif
   2546  2441							;bB.asm
   2547  2441							; bB.asm file is split here
   2548  2441				  -	      if	(<*) > (<(*+8))
   2549  2441				  -	      repeat	($100-<*)
   2550  2441				  -	      .byte	0
   2551  2441				  -	      repend
   2552  2441					      endif
   2553  2441					      if	(<*) < 90
   2554  2441					      repeat	(90-<*)
   2555  2441		       00		      .byte.b	0
   2554  2441					      repend
   2555  2442		       00		      .byte.b	0
   2554  2442					      repend
   2555  2443		       00		      .byte.b	0
   2554  2443					      repend
   2555  2444		       00		      .byte.b	0
   2554  2444					      repend
   2555  2445		       00		      .byte.b	0
   2554  2445					      repend
   2555  2446		       00		      .byte.b	0
   2554  2446					      repend
   2555  2447		       00		      .byte.b	0
   2554  2447					      repend
   2555  2448		       00		      .byte.b	0
   2554  2448					      repend
   2555  2449		       00		      .byte.b	0
   2554  2449					      repend
   2555  244a		       00		      .byte.b	0
   2554  244a					      repend
   2555  244b		       00		      .byte.b	0
   2554  244b					      repend
   2555  244c		       00		      .byte.b	0
   2554  244c					      repend
   2555  244d		       00		      .byte.b	0
   2554  244d					      repend
   2555  244e		       00		      .byte.b	0
   2554  244e					      repend
   2555  244f		       00		      .byte.b	0
   2554  244f					      repend
   2555  2450		       00		      .byte.b	0
   2554  2450					      repend
   2555  2451		       00		      .byte.b	0
   2554  2451					      repend
   2555  2452		       00		      .byte.b	0
   2554  2452					      repend
   2555  2453		       00		      .byte.b	0
   2554  2453					      repend
   2555  2454		       00		      .byte.b	0
   2554  2454					      repend
   2555  2455		       00		      .byte.b	0
   2554  2455					      repend
   2555  2456		       00		      .byte.b	0
   2554  2456					      repend
   2555  2457		       00		      .byte.b	0
   2554  2457					      repend
   2555  2458		       00		      .byte.b	0
   2554  2458					      repend
   2555  2459		       00		      .byte.b	0
   2556  245a					      repend
   2557  245a					      endif
   2558  245a				   player1then_0
   2559  245a		       00		      .byte.b	0
   2560  245b		       00		      .byte.b	%00000000
   2561  245c		       82		      .byte.b	%10000010
   2562  245d		       44		      .byte.b	%01000100
   2563  245e		       fe		      .byte.b	%11111110
   2564  245f		       fe		      .byte.b	%11111110
   2565  2460		       ba		      .byte.b	%10111010
   2566  2461		       7c		      .byte.b	%01111100
   2567  2462		       82		      .byte.b	%10000010
   2568  2463				  -	      if	(<*) > (<(*+8))
   2569  2463				  -	      repeat	($100-<*)
   2570  2463				  -	      .byte	0
   2571  2463				  -	      repend
   2572  2463					      endif
   2573  2463				  -	      if	(<*) < 90
   2574  2463				  -	      repeat	(90-<*)
   2575  2463				  -	      .byte	0
   2576  2463				  -	      repend
   2577  2463					      endif
   2578  2463				   player3then_0
   2579  2463		       00		      .byte.b	0
   2580  2464		       00		      .byte.b	%00000000
   2581  2465		       28		      .byte.b	%00101000
   2582  2466		       44		      .byte.b	%01000100
   2583  2467		       fe		      .byte.b	%11111110
   2584  2468		       fe		      .byte.b	%11111110
   2585  2469		       ba		      .byte.b	%10111010
   2586  246a		       7c		      .byte.b	%01111100
   2587  246b		       44		      .byte.b	%01000100
   2588  246c				  -	      if	(<*) > (<(*+7))
   2589  246c				  -	      repeat	($100-<*)
   2590  246c				  -	      .byte	0
   2591  246c				  -	      repend
   2592  246c					      endif
   2593  246c				  -	      if	(<*) < 90
   2594  246c				  -	      repeat	(90-<*)
   2595  246c				  -	      .byte	0
   2596  246c				  -	      repend
   2597  246c					      endif
   2598  246c				   playerL048_2
   2599  246c		       00		      .byte.b	%00000000
   2600  246d		       00		      .byte.b	%00000000
   2601  246e		       10		      .byte.b	%00010000
   2602  246f		       20		      .byte.b	%00100000
   2603  2470		       10		      .byte.b	%00010000
   2604  2471		       08		      .byte.b	%00001000
   2605  2472		       10		      .byte.b	%00010000
   2606  2473		       00		      .byte.b	%00000000
   2607  2474				  -	      if	(<*) > (<(*+8))
   2608  2474				  -	      repeat	($100-<*)
   2609  2474				  -	      .byte	0
   2610  2474				  -	      repend
   2611  2474					      endif
   2612  2474				  -	      if	(<*) < 90
   2613  2474				  -	      repeat	(90-<*)
   2614  2474				  -	      .byte	0
   2615  2474				  -	      repend
   2616  2474					      endif
   2617  2474				   player32then_0
   2618  2474		       00		      .byte.b	0
   2619  2475		       00		      .byte.b	%00000000
   2620  2476		       92		      .byte.b	%10010010
   2621  2477		       54		      .byte.b	%01010100
   2622  2478		       00		      .byte.b	%00000000
   2623  2479		       d6		      .byte.b	%11010110
   2624  247a		       00		      .byte.b	%00000000
   2625  247b		       54		      .byte.b	%01010100
   2626  247c		       92		      .byte.b	%10010010
   2627  247d				  -	      if	(<*) > (<(*+8))
   2628  247d				  -	      repeat	($100-<*)
   2629  247d				  -	      .byte	0
   2630  247d				  -	      repend
   2631  247d					      endif
   2632  247d				  -	      if	(<*) < 90
   2633  247d				  -	      repeat	(90-<*)
   2634  247d				  -	      .byte	0
   2635  247d				  -	      repend
   2636  247d					      endif
   2637  247d				   playerL062_0
   2638  247d		       00		      .byte.b	0
   2639  247e		       00		      .byte.b	%00000000
   2640  247f		       82		      .byte.b	%10000010
   2641  2480		       44		      .byte.b	%01000100
   2642  2481		       fe		      .byte.b	%11111110
   2643  2482		       fe		      .byte.b	%11111110
   2644  2483		       ba		      .byte.b	%10111010
   2645  2484		       7c		      .byte.b	%01111100
   2646  2485		       82		      .byte.b	%10000010
   2647  2486				  -	      if	(<*) > (<(*+7))
   2648  2486				  -	      repeat	($100-<*)
   2649  2486				  -	      .byte	0
   2650  2486				  -	      repend
   2651  2486					      endif
   2652  2486				  -	      if	(<*) < 90
   2653  2486				  -	      repeat	(90-<*)
   2654  2486				  -	      .byte	0
   2655  2486				  -	      repend
   2656  2486					      endif
   2657  2486				   playerL065_1
   2658  2486		       fe		      .byte.b	%11111110
   2659  2487		       fe		      .byte.b	%11111110
   2660  2488		       7c		      .byte.b	%01111100
   2661  2489		       10		      .byte.b	%00010000
   2662  248a		       00		      .byte.b	%00000000
   2663  248b		       00		      .byte.b	%00000000
   2664  248c		       00		      .byte.b	%00000000
   2665  248d		       00		      .byte.b	%00000000
   2666  248e				  -	      if	(<*) > (<(*+7))
   2667  248e				  -	      repeat	($100-<*)
   2668  248e				  -	      .byte	0
   2669  248e				  -	      repend
   2670  248e					      endif
   2671  248e				  -	      if	(<*) < 90
   2672  248e				  -	      repeat	(90-<*)
   2673  248e				  -	      .byte	0
   2674  248e				  -	      repend
   2675  248e					      endif
   2676  248e				   playerL071_3
   2677  248e		       00		      .byte.b	%00000000
   2678  248f		       00		      .byte.b	%00000000
   2679  2490		       00		      .byte.b	%00000000
   2680  2491		       10		      .byte.b	%00010000
   2681  2492		       10		      .byte.b	%00010000
   2682  2493		       00		      .byte.b	%00000000
   2683  2494		       00		      .byte.b	%00000000
   2684  2495		       00		      .byte.b	%00000000
   2685  2496				  -	      if	(<*) > (<(*+7))
   2686  2496				  -	      repeat	($100-<*)
   2687  2496				  -	      .byte	0
   2688  2496				  -	      repend
   2689  2496					      endif
   2690  2496				  -	      if	(<*) < 90
   2691  2496				  -	      repeat	(90-<*)
   2692  2496				  -	      .byte	0
   2693  2496				  -	      repend
   2694  2496					      endif
   2695  2496				   player46then_1
   2696  2496		       b6		      .byte.b	%10110110
   2697  2497		       4a		      .byte.b	%01001010
   2698  2498		       24		      .byte.b	%00100100
   2699  2499		       90		      .byte.b	%10010000
   2700  249a		       44		      .byte.b	%01000100
   2701  249b		       00		      .byte.b	%00000000
   2702  249c		       00		      .byte.b	%00000000
   2703  249d		       00		      .byte.b	%00000000
   2704  249e				  -	      if	(<*) > (<(*+7))
   2705  249e				  -	      repeat	($100-<*)
   2706  249e				  -	      .byte	0
   2707  249e				  -	      repend
   2708  249e					      endif
   2709  249e				  -	      if	(<*) < 90
   2710  249e				  -	      repeat	(90-<*)
   2711  249e				  -	      .byte	0
   2712  249e				  -	      repend
   2713  249e					      endif
   2714  249e				   player47then_1
   2715  249e		       ea		      .byte.b	%11101010
   2716  249f		       14		      .byte.b	%00010100
   2717  24a0		       40		      .byte.b	%01000000
   2718  24a1		       04		      .byte.b	%00000100
   2719  24a2		       20		      .byte.b	%00100000
   2720  24a3		       00		      .byte.b	%00000000
   2721  24a4		       00		      .byte.b	%00000000
   2722  24a5		       00		      .byte.b	%00000000
   2723  24a6				  -	      if	(<*) > (<(*+24))
   2724  24a6				  -	      repeat	($100-<*)
   2725  24a6				  -	      .byte	0
   2726  24a6				  -	      repend
   2727  24a6					      endif
   2728  24a6				  -	      if	(<*) < 90
   2729  24a6				  -	      repeat	(90-<*)
   2730  24a6				  -	      .byte	0
   2731  24a6				  -	      repend
   2732  24a6					      endif
   2733  24a6				   playerL083_2
   2734  24a6		       00		      .byte.b	%00000000
   2735  24a7		       00		      .byte.b	%00000000
   2736  24a8		       00		      .byte.b	%00000000
   2737  24a9		       00		      .byte.b	%00000000
   2738  24aa		       00		      .byte.b	%00000000
   2739  24ab		       f8		      .byte.b	%11111000
   2740  24ac		       80		      .byte.b	%10000000
   2741  24ad		       c0		      .byte.b	%11000000
   2742  24ae		       80		      .byte.b	%10000000
   2743  24af		       f8		      .byte.b	%11111000
   2744  24b0		       00		      .byte.b	%00000000
   2745  24b1		       88		      .byte.b	%10001000
   2746  24b2		       88		      .byte.b	%10001000
   2747  24b3		       a8		      .byte.b	%10101000
   2748  24b4		       f8		      .byte.b	%11111000
   2749  24b5		       00		      .byte.b	%00000000
   2750  24b6		       88		      .byte.b	%10001000
   2751  24b7		       f8		      .byte.b	%11111000
   2752  24b8		       88		      .byte.b	%10001000
   2753  24b9		       f8		      .byte.b	%11111000
   2754  24ba		       00		      .byte.b	%00000000
   2755  24bb		       f8		      .byte.b	%11111000
   2756  24bc		       88		      .byte.b	%10001000
   2757  24bd		       80		      .byte.b	%10000000
   2758  24be		       f8		      .byte.b	%11111000
   2759  24bf				  -	      if	(<*) > (<(*+24))
   2760  24bf				  -	      repeat	($100-<*)
   2761  24bf				  -	      .byte	0
   2762  24bf				  -	      repend
   2763  24bf					      endif
   2764  24bf				  -	      if	(<*) < 90
   2765  24bf				  -	      repeat	(90-<*)
   2766  24bf				  -	      .byte	0
   2767  24bf				  -	      repend
   2768  24bf					      endif
   2769  24bf				   playerL084_3
   2770  24bf		       00		      .byte.b	%00000000
   2771  24c0		       00		      .byte.b	%00000000
   2772  24c1		       00		      .byte.b	%00000000
   2773  24c2		       00		      .byte.b	%00000000
   2774  24c3		       00		      .byte.b	%00000000
   2775  24c4		       88		      .byte.b	%10001000
   2776  24c5		       f0		      .byte.b	%11110000
   2777  24c6		       88		      .byte.b	%10001000
   2778  24c7		       f8		      .byte.b	%11111000
   2779  24c8		       00		      .byte.b	%00000000
   2780  24c9		       f8		      .byte.b	%11111000
   2781  24ca		       80		      .byte.b	%10000000
   2782  24cb		       c0		      .byte.b	%11000000
   2783  24cc		       80		      .byte.b	%10000000
   2784  24cd		       f8		      .byte.b	%11111000
   2785  24ce		       00		      .byte.b	%00000000
   2786  24cf		       20		      .byte.b	%00100000
   2787  24d0		       50		      .byte.b	%01010000
   2788  24d1		       88		      .byte.b	%10001000
   2789  24d2		       88		      .byte.b	%10001000
   2790  24d3		       00		      .byte.b	%00000000
   2791  24d4		       f8		      .byte.b	%11111000
   2792  24d5		       88		      .byte.b	%10001000
   2793  24d6		       88		      .byte.b	%10001000
   2794  24d7		       f8		      .byte.b	%11111000
   2795  24d8					      if	ECHOFIRST
      2716 bytes of ROM space left in bank 2
   2796  24d8					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   2797  24d8					      endif
   2798  24d8		       00 01	   ECHOFIRST  =	1
   2799  24d8
   2800  24d8
   2801  24d8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2802  24d8
   2803  24d8							; feel free to modify the score graphics - just keep each digit 8 high
   2804  24d8							; and keep the conditional compilation stuff intact
   2805  24d8				  -	      ifconst	ROM2k
   2806  24d8				  -	      ORG	$F7AC-8
   2807  24d8					      else
   2808  24d8					      ifconst	bankswitch
   2809  24d8					      if	bankswitch == 8
   2810  2f74					      ORG	$2F94-bscode_length
   2811  2f74					      RORG	$FF94-bscode_length
   2812  2f74					      endif
   2813  2f74				  -	      if	bankswitch == 16
   2814  2f74				  -	      ORG	$4F94-bscode_length
   2815  2f74				  -	      RORG	$FF94-bscode_length
   2816  2f74					      endif
   2817  2f74				  -	      if	bankswitch == 32
   2818  2f74				  -	      ORG	$8F94-bscode_length
   2819  2f74				  -	      RORG	$FF94-bscode_length
   2820  2f74					      endif
   2821  2f74				  -	      if	bankswitch == 64
   2822  2f74				  -	      ORG	$10F80-bscode_length
   2823  2f74				  -	      RORG	$1FF80-bscode_length
   2824  2f74					      endif
   2825  2f74				  -	      else
   2826  2f74				  -	      ORG	$FF9C
   2827  2f74					      endif
   2828  2f74					      endif
   2829  2f74
   2830  2f74							; font equates
   2831  2f74		       00 01	   .21stcentury =	1
   2832  2f74		       00 02	   alarmclock =	2
   2833  2f74		       00 03	   handwritten =	3
   2834  2f74		       00 04	   interrupted =	4
   2835  2f74		       00 05	   retroputer =	5
   2836  2f74		       00 06	   whimsey    =	6
   2837  2f74		       00 07	   tiny       =	7
   2838  2f74		       00 08	   hex	      =	8
   2839  2f74
   2840  2f74				  -	      ifconst	font
   2841  2f74				  -	      if	font == hex
   2842  2f74				  -	      ORG	. - 48
   2843  2f74				  -	      endif
   2844  2f74					      endif
   2845  2f74
   2846  2f74				   scoretable
   2847  2f74
   2848  2f74				  -	      ifconst	font
   2849  2f74				  -	      if	font == .21stcentury
   2850  2f74				  -	      include	"score_graphics.asm.21stcentury"
   2851  2f74				  -	      endif
   2852  2f74				  -	      if	font == alarmclock
   2853  2f74				  -	      include	"score_graphics.asm.alarmclock"
   2854  2f74				  -	      endif
   2855  2f74				  -	      if	font == handwritten
   2856  2f74				  -	      include	"score_graphics.asm.handwritten"
   2857  2f74				  -	      endif
   2858  2f74				  -	      if	font == interrupted
   2859  2f74				  -	      include	"score_graphics.asm.interrupted"
   2860  2f74				  -	      endif
   2861  2f74				  -	      if	font == retroputer
   2862  2f74				  -	      include	"score_graphics.asm.retroputer"
   2863  2f74				  -	      endif
   2864  2f74				  -	      if	font == whimsey
   2865  2f74				  -	      include	"score_graphics.asm.whimsey"
   2866  2f74				  -	      endif
   2867  2f74				  -	      if	font == tiny
   2868  2f74				  -	      include	"score_graphics.asm.tiny"
   2869  2f74				  -	      endif
   2870  2f74				  -	      if	font == hex
   2871  2f74				  -	      include	"score_graphics.asm.hex"
   2872  2f74				  -	      endif
   2873  2f74					      else		; default font
   2874  2f74
   2875  2f74		       3c		      .byte.b	%00111100
   2876  2f75		       66		      .byte.b	%01100110
   2877  2f76		       66		      .byte.b	%01100110
   2878  2f77		       66		      .byte.b	%01100110
   2879  2f78		       66		      .byte.b	%01100110
   2880  2f79		       66		      .byte.b	%01100110
   2881  2f7a		       66		      .byte.b	%01100110
   2882  2f7b		       3c		      .byte.b	%00111100
   2883  2f7c
   2884  2f7c		       7e		      .byte.b	%01111110
   2885  2f7d		       18		      .byte.b	%00011000
   2886  2f7e		       18		      .byte.b	%00011000
   2887  2f7f		       18		      .byte.b	%00011000
   2888  2f80		       18		      .byte.b	%00011000
   2889  2f81		       38		      .byte.b	%00111000
   2890  2f82		       18		      .byte.b	%00011000
   2891  2f83		       08		      .byte.b	%00001000
   2892  2f84
   2893  2f84		       7e		      .byte.b	%01111110
   2894  2f85		       60		      .byte.b	%01100000
   2895  2f86		       60		      .byte.b	%01100000
   2896  2f87		       3c		      .byte.b	%00111100
   2897  2f88		       06		      .byte.b	%00000110
   2898  2f89		       06		      .byte.b	%00000110
   2899  2f8a		       46		      .byte.b	%01000110
   2900  2f8b		       3c		      .byte.b	%00111100
   2901  2f8c
   2902  2f8c		       3c		      .byte.b	%00111100
   2903  2f8d		       46		      .byte.b	%01000110
   2904  2f8e		       06		      .byte.b	%00000110
   2905  2f8f		       06		      .byte.b	%00000110
   2906  2f90		       1c		      .byte.b	%00011100
   2907  2f91		       06		      .byte.b	%00000110
   2908  2f92		       46		      .byte.b	%01000110
   2909  2f93		       3c		      .byte.b	%00111100
   2910  2f94
   2911  2f94		       0c		      .byte.b	%00001100
   2912  2f95		       0c		      .byte.b	%00001100
   2913  2f96		       7e		      .byte.b	%01111110
   2914  2f97		       4c		      .byte.b	%01001100
   2915  2f98		       4c		      .byte.b	%01001100
   2916  2f99		       2c		      .byte.b	%00101100
   2917  2f9a		       1c		      .byte.b	%00011100
   2918  2f9b		       0c		      .byte.b	%00001100
   2919  2f9c
   2920  2f9c		       3c		      .byte.b	%00111100
   2921  2f9d		       46		      .byte.b	%01000110
   2922  2f9e		       06		      .byte.b	%00000110
   2923  2f9f		       06		      .byte.b	%00000110
   2924  2fa0		       3c		      .byte.b	%00111100
   2925  2fa1		       60		      .byte.b	%01100000
   2926  2fa2		       60		      .byte.b	%01100000
   2927  2fa3		       7e		      .byte.b	%01111110
   2928  2fa4
   2929  2fa4		       3c		      .byte.b	%00111100
   2930  2fa5		       66		      .byte.b	%01100110
   2931  2fa6		       66		      .byte.b	%01100110
   2932  2fa7		       66		      .byte.b	%01100110
   2933  2fa8		       7c		      .byte.b	%01111100
   2934  2fa9		       60		      .byte.b	%01100000
   2935  2faa		       62		      .byte.b	%01100010
   2936  2fab		       3c		      .byte.b	%00111100
   2937  2fac
   2938  2fac		       30		      .byte.b	%00110000
   2939  2fad		       30		      .byte.b	%00110000
   2940  2fae		       30		      .byte.b	%00110000
   2941  2faf		       18		      .byte.b	%00011000
   2942  2fb0		       0c		      .byte.b	%00001100
   2943  2fb1		       06		      .byte.b	%00000110
   2944  2fb2		       42		      .byte.b	%01000010
   2945  2fb3		       3e		      .byte.b	%00111110
   2946  2fb4
   2947  2fb4		       3c		      .byte.b	%00111100
   2948  2fb5		       66		      .byte.b	%01100110
   2949  2fb6		       66		      .byte.b	%01100110
   2950  2fb7		       66		      .byte.b	%01100110
   2951  2fb8		       3c		      .byte.b	%00111100
   2952  2fb9		       66		      .byte.b	%01100110
   2953  2fba		       66		      .byte.b	%01100110
   2954  2fbb		       3c		      .byte.b	%00111100
   2955  2fbc
   2956  2fbc		       3c		      .byte.b	%00111100
   2957  2fbd		       46		      .byte.b	%01000110
   2958  2fbe		       06		      .byte.b	%00000110
   2959  2fbf		       3e		      .byte.b	%00111110
   2960  2fc0		       66		      .byte.b	%01100110
   2961  2fc1		       66		      .byte.b	%01100110
   2962  2fc2		       66		      .byte.b	%01100110
   2963  2fc3		       3c		      .byte.b	%00111100
   2964  2fc4
   2965  2fc4					      ifnconst	DPC_kernel_options
   2966  2fc4
   2967  2fc4		       00		      .byte.b	%00000000
   2968  2fc5		       00		      .byte.b	%00000000
   2969  2fc6		       00		      .byte.b	%00000000
   2970  2fc7		       00		      .byte.b	%00000000
   2971  2fc8		       00		      .byte.b	%00000000
   2972  2fc9		       00		      .byte.b	%00000000
   2973  2fca		       00		      .byte.b	%00000000
   2974  2fcb		       00		      .byte.b	%00000000
   2975  2fcc
   2976  2fcc					      endif
   2977  2fcc
   2978  2fcc					      endif
   2979  2fcc
   2980  2fcc				  -	      ifconst	ROM2k
   2981  2fcc				  -	      ORG	$F7FC
   2982  2fcc					      else
   2983  2fcc					      ifconst	bankswitch
   2984  2fcc					      if	bankswitch == 8
   2985  2fd4					      ORG	$2FF4-bscode_length
   2986  2fd4					      RORG	$FFF4-bscode_length
   2987  2fd4					      endif
   2988  2fd4				  -	      if	bankswitch == 16
   2989  2fd4				  -	      ORG	$4FF4-bscode_length
   2990  2fd4				  -	      RORG	$FFF4-bscode_length
   2991  2fd4					      endif
   2992  2fd4				  -	      if	bankswitch == 32
   2993  2fd4				  -	      ORG	$8FF4-bscode_length
   2994  2fd4				  -	      RORG	$FFF4-bscode_length
   2995  2fd4					      endif
   2996  2fd4				  -	      if	bankswitch == 64
   2997  2fd4				  -	      ORG	$10FE0-bscode_length
   2998  2fd4				  -	      RORG	$1FFE0-bscode_length
   2999  2fd4					      endif
   3000  2fd4				  -	      else
   3001  2fd4				  -	      ORG	$FFFC
   3002  2fd4					      endif
   3003  2fd4					      endif
   3004  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3005  2fd4
   3006  2fd4							; every bank has this stuff at the same place
   3007  2fd4							; this code can switch to/from any bank at any entry point
   3008  2fd4							; and can preserve register values
   3009  2fd4							; note: lines not starting with a space are not placed in all banks
   3010  2fd4							;
   3011  2fd4							; line below tells the compiler how long this is - do not remove
   3012  2fd4							;size=32
   3013  2fd4
   3014  2fd4				   begin_bscode
   3015  2fd4		       a2 ff		      ldx	#$ff
   3016  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3017  2fd6				  -	      stx	FASTFETCH
   3018  2fd6					      endif
   3019  2fd6		       9a		      txs
   3020  2fd7				  -	      if	bankswitch == 64
   3021  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3022  2fd7					      else
   3023  2fd7		       a9 f3		      lda	#>(start-1)
   3024  2fd9					      endif
   3025  2fd9		       48		      pha
   3026  2fda		       a9 f7		      lda	#<(start-1)
   3027  2fdc		       48		      pha
   3028  2fdd
   3029  2fdd				   BS_return
   3030  2fdd		       48		      pha
   3031  2fde		       8a		      txa
   3032  2fdf		       48		      pha
   3033  2fe0		       ba		      tsx
   3034  2fe1
   3035  2fe1					      if	bankswitch != 64
   3036  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   3037  2fe3
   3038  2fe3		       2a		      rol
   3039  2fe4		       2a		      rol
   3040  2fe5		       2a		      rol
   3041  2fe6		       2a		      rol
   3042  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3043  2fe9		       aa		      tax
   3044  2fea		       e8		      inx
   3045  2feb				  -	      else
   3046  2feb				  -	      lda	4,x	; get high byte of return address
   3047  2feb				  -	      tay
   3048  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3049  2feb				  -	      sta	4,x
   3050  2feb				  -	      tya
   3051  2feb				  -	      lsr
   3052  2feb				  -	      lsr
   3053  2feb				  -	      lsr
   3054  2feb				  -	      lsr
   3055  2feb				  -	      tax
   3056  2feb				  -	      inx
   3057  2feb					      endif
   3058  2feb
   3059  2feb				   BS_jsr
   3060  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   3061  2fee		       68		      pla
   3062  2fef		       aa		      tax
   3063  2ff0		       68		      pla
   3064  2ff1		       60		      rts
   3065  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3066  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3067  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3068  2ff2					      endif
   3069  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3070  2ff2
   3071  2ff2					      ifconst	bankswitch
   3072  2ff2					      if	bankswitch == 8
   3073  2ffc					      ORG	$2FFC
   3074  2ffc					      RORG	$FFFC
   3075  2ffc					      endif
   3076  2ffc				  -	      if	bankswitch == 16
   3077  2ffc				  -	      ORG	$4FFC
   3078  2ffc				  -	      RORG	$FFFC
   3079  2ffc					      endif
   3080  2ffc				  -	      if	bankswitch == 32
   3081  2ffc				  -	      ORG	$8FFC
   3082  2ffc				  -	      RORG	$FFFC
   3083  2ffc					      endif
   3084  2ffc				  -	      if	bankswitch == 64
   3085  2ffc				  -	      ORG	$10FF0
   3086  2ffc				  -	      RORG	$1FFF0
   3087  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3088  2ffc				  -	      ORG	$10FF8
   3089  2ffc				  -	      RORG	$1FFF8
   3090  2ffc				  -	      ifconst	superchip
   3091  2ffc				  -	      .byte	"E","F","S","C"
   3092  2ffc				  -	      else
   3093  2ffc				  -	      .byte	"E","F","E","F"
   3094  2ffc				  -	      endif
   3095  2ffc				  -	      ORG	$10FFC
   3096  2ffc				  -	      RORG	$1FFFC
   3097  2ffc					      endif
   3098  2ffc				  -	      else
   3099  2ffc				  -	      ifconst	ROM2k
   3100  2ffc				  -	      ORG	$F7FC
   3101  2ffc				  -	      else
   3102  2ffc				  -	      ORG	$FFFC
   3103  2ffc				  -	      endif
   3104  2ffc					      endif
   3105  2ffc		       f8 f3		      .word.w	(start & $ffff)
   3106  2ffe		       f8 f3		      .word.w	(start & $ffff)
