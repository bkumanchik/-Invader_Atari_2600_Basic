------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_18.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_18.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_18.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  3000 ????				      include	"multisprite.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????	       00 80	   missile0x  =	$80
      4  3000 ????	       00 81	   missile1x  =	$81
      5  3000 ????	       00 82	   ballx      =	$82
      6  3000 ????
      7  3000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  3000 ????
      9  3000 ????	       00 83	   SpriteIndex =	$83
     10  3000 ????
     11  3000 ????	       00 84	   player0x   =	$84
     12  3000 ????	       00 85	   NewSpriteX =	$85	;		X position
     13  3000 ????	       00 85	   player1x   =	$85
     14  3000 ????	       00 86	   player2x   =	$86
     15  3000 ????	       00 87	   player3x   =	$87
     16  3000 ????	       00 88	   player4x   =	$88
     17  3000 ????	       00 89	   player5x   =	$89
     18  3000 ????
     19  3000 ????	       00 8a	   objecty    =	$8A
     20  3000 ????	       00 8a	   missile0y  =	$8A
     21  3000 ????	       00 8b	   missile1y  =	$8B
     22  3000 ????	       00 8c	   bally      =	$8C
     23  3000 ????
     24  3000 ????	       00 8d	   player0y   =	$8D
     25  3000 ????	       00 8e	   NewSpriteY =	$8E	;		Y position
     26  3000 ????	       00 8e	   player1y   =	$8E
     27  3000 ????	       00 8f	   player2y   =	$8F
     28  3000 ????	       00 90	   player3y   =	$90
     29  3000 ????	       00 91	   player4y   =	$91
     30  3000 ????	       00 92	   player5y   =	$92
     31  3000 ????
     32  3000 ????	       00 93	   NewNUSIZ   =	$93
     33  3000 ????	       00 93	   _NUSIZ1    =	$93
     34  3000 ????	       00 94	   NUSIZ2     =	$94
     35  3000 ????	       00 95	   NUSIZ3     =	$95
     36  3000 ????	       00 96	   NUSIZ4     =	$96
     37  3000 ????	       00 97	   NUSIZ5     =	$97
     38  3000 ????
     39  3000 ????	       00 98	   NewCOLUP1  =	$98
     40  3000 ????	       00 98	   _COLUP1    =	$98
     41  3000 ????	       00 99	   COLUP2     =	$99
     42  3000 ????	       00 9a	   COLUP3     =	$9A
     43  3000 ????	       00 9b	   COLUP4     =	$9B
     44  3000 ????	       00 9c	   COLUP5     =	$9C
     45  3000 ????
     46  3000 ????	       00 9d	   SpriteGfxIndex =	$9D
     47  3000 ????
     48  3000 ????	       00 a2	   player0pointer =	$A2
     49  3000 ????	       00 a2	   player0pointerlo =	$A2
     50  3000 ????	       00 a3	   player0pointerhi =	$A3
     51  3000 ????
     52  3000 ????						;P0Top = temp5
     53  3000 ????	       00 cf	   P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  3000 ????	       00 a4	   P0Bottom   =	$A4
     55  3000 ????	       00 a5	   P1Bottom   =	$A5
     56  3000 ????
     57  3000 ????	       00 a6	   player1pointerlo =	$A6
     58  3000 ????	       00 a7	   player2pointerlo =	$A7
     59  3000 ????	       00 a8	   player3pointerlo =	$A8
     60  3000 ????	       00 a9	   player4pointerlo =	$A9
     61  3000 ????	       00 aa	   player5pointerlo =	$AA
     62  3000 ????
     63  3000 ????	       00 ab	   player1pointerhi =	$AB
     64  3000 ????	       00 ac	   player2pointerhi =	$AC
     65  3000 ????	       00 ad	   player3pointerhi =	$AD
     66  3000 ????	       00 ae	   player4pointerhi =	$AE
     67  3000 ????	       00 af	   player5pointerhi =	$AF
     68  3000 ????
     69  3000 ????	       00 b0	   player0height =	$B0
     70  3000 ????	       00 b1	   spriteheight =	$B1	; heights of multiplexed player sprite
     71  3000 ????	       00 b1	   player1height =	$B1
     72  3000 ????	       00 b2	   player2height =	$B2
     73  3000 ????	       00 b3	   player3height =	$B3
     74  3000 ????	       00 b4	   player4height =	$B4
     75  3000 ????	       00 b5	   player5height =	$B5
     76  3000 ????
     77  3000 ????	       00 b6	   PF1temp1   =	$B6
     78  3000 ????	       00 b7	   PF1temp2   =	$B7
     79  3000 ????	       00 b8	   PF2temp1   =	$B8
     80  3000 ????	       00 b9	   PF2temp2   =	$B9
     81  3000 ????
     82  3000 ????	       00 ba	   pfpixelheight =	$BA
     83  3000 ????
     84  3000 ????						; playfield is now a pointer to graphics
     85  3000 ????	       00 bb	   playfield  =	$BB
     86  3000 ????	       00 bb	   PF1pointer =	$BB
     87  3000 ????
     88  3000 ????	       00 bd	   PF2pointer =	$BD
     89  3000 ????
     90  3000 ????	       00 bf	   statusbarlength =	$BF
     91  3000 ????	       00 bf	   aux3       =	$BF
     92  3000 ????
     93  3000 ????	       00 c0	   lifecolor  =	$C0
     94  3000 ????	       00 c0	   pfscorecolor =	$C0
     95  3000 ????	       00 c0	   aux4       =	$C0
     96  3000 ????
     97  3000 ????						;P1display = temp2 ; temp2 and temp3
     98  3000 ????	       00 cc	   P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  3000 ????	       00 c1	   lifepointer =	$c1
    100  3000 ????	       00 c2	   lives      =	$c2
    101  3000 ????	       00 c1	   pfscore1   =	$c1
    102  3000 ????	       00 c2	   pfscore2   =	$c2
    103  3000 ????	       00 c1	   aux5       =	$c1
    104  3000 ????	       00 c2	   aux6       =	$c2
    105  3000 ????
    106  3000 ????	       00 c3	   playfieldpos =	$C3
    107  3000 ????
    108  3000 ????						;RepoLine = temp4
    109  3000 ????	       00 ce	   RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  3000 ????
    111  3000 ????	       00 c4	   pfheight   =	$C4
    112  3000 ????	       00 c5	   scorepointers =	$C5
    113  3000 ????
    114  3000 ????	       00 cb	   temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  3000 ????	       00 cc	   temp2      =	$CC	;are obliterated when drawscreen is called.
    116  3000 ????	       00 cd	   temp3      =	$CD
    117  3000 ????	       00 ce	   temp4      =	$CE
    118  3000 ????	       00 cf	   temp5      =	$CF
    119  3000 ????	       00 d0	   temp6      =	$D0
    120  3000 ????	       00 d1	   temp7      =	$D1	; This is used to aid in bankswitching
    121  3000 ????
    122  3000 ????	       00 d2	   score      =	$D2
    123  3000 ????	       00 d5	   scorecolor =	$D5	;need to find other places for these, possibly...
    124  3000 ????	       00 d6	   rand       =	$D6
    125  3000 ????
    126  3000 ????
    127  3000 ????
    128  3000 ????	       00 d7	   A	      =	$d7
    129  3000 ????	       00 d7	   a	      =	$d7
    130  3000 ????	       00 d8	   B	      =	$d8
    131  3000 ????	       00 d8	   b	      =	$d8
    132  3000 ????	       00 d9	   C	      =	$d9
    133  3000 ????	       00 d9	   c	      =	$d9
    134  3000 ????	       00 da	   D	      =	$da
    135  3000 ????	       00 da	   d	      =	$da
    136  3000 ????	       00 db	   E	      =	$db
    137  3000 ????	       00 db	   e	      =	$db
    138  3000 ????	       00 dc	   F	      =	$dc
    139  3000 ????	       00 dc	   f	      =	$dc
    140  3000 ????	       00 dd	   G	      =	$dd
    141  3000 ????	       00 dd	   g	      =	$dd
    142  3000 ????	       00 de	   H	      =	$de
    143  3000 ????	       00 de	   h	      =	$de
    144  3000 ????	       00 df	   I	      =	$df
    145  3000 ????	       00 df	   i	      =	$df
    146  3000 ????	       00 e0	   J	      =	$e0
    147  3000 ????	       00 e0	   j	      =	$e0
    148  3000 ????	       00 e1	   K	      =	$e1
    149  3000 ????	       00 e1	   k	      =	$e1
    150  3000 ????	       00 e2	   L	      =	$e2
    151  3000 ????	       00 e2	   l	      =	$e2
    152  3000 ????	       00 e3	   M	      =	$e3
    153  3000 ????	       00 e3	   m	      =	$e3
    154  3000 ????	       00 e4	   N	      =	$e4
    155  3000 ????	       00 e4	   n	      =	$e4
    156  3000 ????	       00 e5	   O	      =	$e5
    157  3000 ????	       00 e5	   o	      =	$e5
    158  3000 ????	       00 e6	   P	      =	$e6
    159  3000 ????	       00 e6	   p	      =	$e6
    160  3000 ????	       00 e7	   Q	      =	$e7
    161  3000 ????	       00 e7	   q	      =	$e7
    162  3000 ????	       00 e8	   R	      =	$e8
    163  3000 ????	       00 e8	   r	      =	$e8
    164  3000 ????	       00 e9	   S	      =	$e9
    165  3000 ????	       00 e9	   s	      =	$e9
    166  3000 ????	       00 ea	   T	      =	$ea
    167  3000 ????	       00 ea	   t	      =	$ea
    168  3000 ????	       00 eb	   U	      =	$eb
    169  3000 ????	       00 eb	   u	      =	$eb
    170  3000 ????	       00 ec	   V	      =	$ec
    171  3000 ????	       00 ec	   v	      =	$ec
    172  3000 ????	       00 ed	   W	      =	$ed
    173  3000 ????	       00 ed	   w	      =	$ed
    174  3000 ????	       00 ee	   X	      =	$ee
    175  3000 ????	       00 ee	   x	      =	$ee
    176  3000 ????	       00 ef	   Y	      =	$ef
    177  3000 ????	       00 ef	   y	      =	$ef
    178  3000 ????	       00 f0	   Z	      =	$f0
    179  3000 ????	       00 f0	   z	      =	$f0
    180  3000 ????
    181  3000 ????	       00 f1	   spritesort =	$f1	; helps with flickersort
    182  3000 ????	       00 f2	   spritesort2 =	$f2	; helps with flickersort
    183  3000 ????	       00 f3	   spritesort3 =	$f3
    184  3000 ????	       00 f4	   spritesort4 =	$f4
    185  3000 ????	       00 f5	   spritesort5 =	$f5
    186  3000 ????
    187  3000 ????	       00 f6	   stack1     =	$f6
    188  3000 ????	       00 f7	   stack2     =	$f7
    189  3000 ????	       00 f8	   stack3     =	$f8
    190  3000 ????	       00 f9	   stack4     =	$f9
    191  3000 ????						; the stack bytes above may be used in the kernel
    192  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  3000 ????
    194  3000 ????				      MAC	return
    195  3000 ????				      ifnconst	bankswitch
    196  3000 ????				      rts
    197  3000 ????				      else
    198  3000 ????				      jmp	BS_return
    199  3000 ????				      endif
    200  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_18.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 ea	   tur_anim_delay =	t
      5  3000 ????	       00 e9	   tur_anim_frame =	s
      6  3000 ????	       00 e8	   tur_anim_playing =	r
      7  3000 ????	       00 e7	   tur_hit    =	q
      8  3000 ????	       00 e3	   tur_fired  =	m
      9  3000 ????	       00 e0	   shot_y     =	j
     10  3000 ????	       00 df	   shot_x     =	i
     11  3000 ????	       00 db	   tur_y      =	e
     12  3000 ????	       00 da	   tur_x      =	d
     13  3000 ????	       00 e5	   inv_blast_delay =	o
     14  3000 ????	       00 e4	   inv_hit    =	n
     15  3000 ????	       00 e2	   inv_fired  =	l
     16  3000 ????	       00 e1	   inv_fire_delay =	k
     17  3000 ????	       00 de	   inv_shot_y =	h
     18  3000 ????	       00 dd	   inv_shot_x =	g
     19  3000 ????	       00 dc	   inv_dir    =	f
     20  3000 ????	       00 d9	   inv_delay  =	c
     21  3000 ????	       00 d8	   inv_y      =	b
     22  3000 ????	       00 d7	   inv_x      =	a
     23  3000 ????	       00 e6	   reducing_lives =	p
     24  3000 ????	       00 00	   pfscore    =	0
     25  3000 ????
     26  3000 ????	       00 01	   bs_mask    =	1
     27  3000 ????	       00 08	   bankswitch =	8
     28  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
     29  3000 ????	       00 01	   multisprite =	1
     30  3000 ????	       00 01	   no_blank_lines =	1
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_18.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	234	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .L00 		;  includesfile multisprite_bankswitch.inc
     57  1000
     58  1000				   .L01 		;  set kernel_options no_blank_lines
     59  1000
     60  1000				   .
     61  1000							; 
     62  1000
     63  1000				   .L02 		;  set kernel multisprite
     64  1000
     65  1000				   .L03 		;  set romsize 8k
     66  1000
     67  1000				   .
     68  1000							; 
     69  1000
     70  1000				   .
     71  1000							; 
     72  1000
     73  1000				   .L04 		;  const pfscore  =  0
     74  1000
     75  1000				   .
     76  1000							; 
     77  1000
     78  1000				   .
     79  1000							; 
     80  1000
     81  1000				   .
     82  1000							; 
     83  1000
     84  1000				   .L05 		;  dim reducing_lives	=  p  :  p  =  0
     85  1000
     86  1000		       a9 00		      LDA	#0
     87  1002		       85 e6		      STA	p
     88  1004				   .
     89  1004							; 
     90  1004
     91  1004				   .L06 		;  pfscore2  =  %00101010
     92  1004
     93  1004		       a9 2a		      LDA	#%00101010
     94  1006		       85 c2		      STA	pfscore2
     95  1008				   .
     96  1008							; 
     97  1008
     98  1008				   .
     99  1008							; 
    100  1008
    101  1008				   .L07 		;  dim inv_x  =  a  :	a  =  84
    102  1008
    103  1008		       a9 54		      LDA	#84
    104  100a		       85 d7		      STA	a
    105  100c				   .L08 		;  dim inv_y  =  b  :	b  =  76
    106  100c
    107  100c		       a9 4c		      LDA	#76
    108  100e		       85 d8		      STA	b
    109  1010				   .L09 		;  dim inv_delay  =  c  :  c  =  0
    110  1010
    111  1010		       a9 00		      LDA	#0
    112  1012		       85 d9		      STA	c
    113  1014				   .L010		;  dim inv_dir  =  f  :  f  =	1
    114  1014
    115  1014		       a9 01		      LDA	#1
    116  1016		       85 dc		      STA	f
    117  1018				   .L011		;  dim inv_shot_x  =  g  :  g	=  inv_x
    118  1018
    119  1018		       a5 d7		      LDA	inv_x
    120  101a		       85 dd		      STA	g
    121  101c				   .L012		;  dim inv_shot_y  =  h  :  h	=  inv_y
    122  101c
    123  101c		       a5 d8		      LDA	inv_y
    124  101e		       85 de		      STA	h
    125  1020				   .L013		;  dim inv_fire_delay	=  k  :  k  =  0
    126  1020
    127  1020		       a9 00		      LDA	#0
    128  1022		       85 e1		      STA	k
    129  1024				   .L014		;  dim inv_fired  =  l  :  l  =  0
    130  1024
    131  1024		       a9 00		      LDA	#0
    132  1026		       85 e2		      STA	l
    133  1028				   .L015		;  dim inv_hit  =  n  :  n  =	0
    134  1028
    135  1028		       a9 00		      LDA	#0
    136  102a		       85 e4		      STA	n
    137  102c				   .L016		;  dim inv_blast_delay  =  o  :  o  =	0
    138  102c
    139  102c		       a9 00		      LDA	#0
    140  102e		       85 e5		      STA	o
    141  1030				   .
    142  1030							; 
    143  1030
    144  1030				   .
    145  1030							; 
    146  1030
    147  1030				   .L017		;  dim tur_x  =  d  :	d  =  84
    148  1030
    149  1030		       a9 54		      LDA	#84
    150  1032		       85 da		      STA	d
    151  1034				   .L018		;  dim tur_y  =  e  :	e  =  14
    152  1034
    153  1034		       a9 0e		      LDA	#14
    154  1036		       85 db		      STA	e
    155  1038				   .L019		;  dim shot_x	=  i  :  i  =  tur_x
    156  1038
    157  1038		       a5 da		      LDA	tur_x
    158  103a		       85 df		      STA	i
    159  103c				   .L020		;  dim shot_y	=  j  :  j  =  tur_y
    160  103c
    161  103c		       a5 db		      LDA	tur_y
    162  103e		       85 e0		      STA	j
    163  1040				   .L021		;  dim tur_fired  =  m  :  m  =  0
    164  1040
    165  1040		       a9 00		      LDA	#0
    166  1042		       85 e3		      STA	m
    167  1044				   .L022		;  dim tur_hit  =  q  :  q  =	0
    168  1044
    169  1044		       a9 00		      LDA	#0
    170  1046		       85 e7		      STA	q
    171  1048				   .L023		;  dim tur_anim_playing  =  r	:  r  =  0
    172  1048
    173  1048		       a9 00		      LDA	#0
    174  104a		       85 e8		      STA	r
    175  104c				   .L024		;  dim tur_anim_frame	=  s  :  s  =  0
    176  104c
    177  104c		       a9 00		      LDA	#0
    178  104e		       85 e9		      STA	s
    179  1050				   .L025		;  dim tur_anim_delay	=  t  :  t  =  0
    180  1050
    181  1050		       a9 00		      LDA	#0
    182  1052		       85 ea		      STA	t
    183  1054				   .
    184  1054							; 
    185  1054
    186  1054				   .
    187  1054							; 
    188  1054
    189  1054				   .
    190  1054							; 
    191  1054
    192  1054				   .main
    193  1054							; main
    194  1054
    195  1054				   .
    196  1054							; 
    197  1054
    198  1054				   .L026		;  gosub draw__move_turret
    199  1054
    200  1054		       20 92 d2 	      jsr	.draw__move_turret
    201  1057
    202  1057				   .L027		;  gosub draw__move_turret_shot
    203  1057
    204  1057		       20 d1 d2 	      jsr	.draw__move_turret_shot
    205  105a
    206  105a				   .L028		;  gosub draw__move_invader
    207  105a
    208  105a		       20 92 d0 	      jsr	.draw__move_invader
    209  105d
    210  105d				   .L029		;  gosub draw__move_inv_shot
    211  105d
    212  105d		       20 64 d1 	      jsr	.draw__move_inv_shot
    213  1060
    214  1060				   .L030		;  gosub col_shot_inv
    215  1060
    216  1060		       20 e3 d1 	      jsr	.col_shot_inv
    217  1063
    218  1063				   .L031		;  gosub col_inv_shot_turret
    219  1063
    220  1063		       20 38 d3 	      jsr	.col_inv_shot_turret
    221  1066
    222  1066				   .
    223  1066							; 
    224  1066
    225  1066				   .L032		;  if pfscore2  <  2 then goto game_over
    226  1066
    227  1066		       a5 c2		      LDA	pfscore2
    228  1068		       c9 02		      CMP	#2
    229  106a		       b0 03		      BCS	.skipL032
    230  106c				   .condpart0
    231  106c		       4c 92 d3 	      jmp	.game_over
    232  106f
    233  106f				   .skipL032
    234  106f				   .
    235  106f							; 
    236  106f
    237  106f				   .
    238  106f							; 
    239  106f
    240  106f				   .L033		;  pfscorecolor  =  196
    241  106f
    242  106f		       a9 c4		      LDA	#196
    243  1071		       85 c0		      STA	pfscorecolor
    244  1073				   .
    245  1073							; 
    246  1073
    247  1073				   .
    248  1073							; 
    249  1073
    250  1073				   .L034		;  scorecolor	=  152
    251  1073
    252  1073		       a9 98		      LDA	#152
    253  1075		       85 d5		      STA	scorecolor
    254  1077				   .
    255  1077							; 
    256  1077
    257  1077				   .
    258  1077							; 
    259  1077
    260  1077				   .L035		;  drawscreen
    261  1077
    262  1077		       85 d1		      sta	temp7
    263  1079		       a9 d0		      lda	#>(ret_point1-1)
    264  107b		       48		      pha
    265  107c		       a9 8e		      lda	#<(ret_point1-1)
    266  107e		       48		      pha
    267  107f		       a9 f0		      lda	#>(drawscreen-1)
    268  1081		       48		      pha
    269  1082		       a9 39		      lda	#<(drawscreen-1)
    270  1084		       48		      pha
    271  1085		       a5 d1		      lda	temp7
    272  1087		       48		      pha
    273  1088		       8a		      txa
    274  1089		       48		      pha
    275  108a		       a2 02		      ldx	#2
    276  108c		       4c eb ff 	      jmp	BS_jsr
    277  108f				   ret_point1
    278  108f				   .
    279  108f							; 
    280  108f
    281  108f				   .L036		;  goto main
    282  108f
    283  108f		       4c 54 d0 	      jmp	.main
    284  1092
    285  1092				   .
    286  1092							; 
    287  1092
    288  1092				   .
    289  1092							; 
    290  1092
    291  1092				   .
    292  1092							; 
    293  1092
    294  1092				   .
    295  1092							; 
    296  1092
    297  1092				   .
    298  1092							; 
    299  1092
    300  1092				   .
    301  1092							; 
    302  1092
    303  1092				   .
    304  1092							; 
    305  1092
    306  1092				   .draw__move_invader
    307  1092							; draw__move_invader
    308  1092
    309  1092				   .
    310  1092							; 
    311  1092
    312  1092				   .L037		;  inv_delay  =  inv_delay  +	1
    313  1092
    314  1092		       e6 d9		      INC	inv_delay
    315  1094				   .
    316  1094							; 
    317  1094
    318  1094				   .
    319  1094							; 
    320  1094
    321  1094				   .L038		;  if inv_delay  =  15  &&  inv_hit  =  0 then player0:  
    322  1094
    323  1094		       a5 d9		      LDA	inv_delay
    324  1096		       c9 0f		      CMP	#15
    325  1098		       d0 12		      BNE	.skipL038
    326  109a				   .condpart1
    327  109a		       a5 e4		      LDA	inv_hit
    328  109c		       c9 00		      CMP	#0
    329  109e		       d0 0c		      BNE	.skip1then
    330  10a0				   .condpart2
    331  10a0		       a2 5a		      LDX	#<player2then_0
    332  10a2		       86 a2		      STX	player0pointerlo
    333  10a4		       a9 f4		      LDA	#>player2then_0
    334  10a6		       85 a3		      STA	player0pointerhi
    335  10a8		       a9 09		      LDA	#9
    336  10aa		       85 b0		      STA	player0height
    337  10ac				   .skip1then
    338  10ac				   .skipL038
    339  10ac				   .
    340  10ac							; 
    341  10ac
    342  10ac				   .
    343  10ac							; 
    344  10ac
    345  10ac				   .L039		;  if inv_delay  =  30  &&  inv_hit  =  0 then player0:  
    346  10ac
    347  10ac		       a5 d9		      LDA	inv_delay
    348  10ae		       c9 1e		      CMP	#30
    349  10b0		       d0 12		      BNE	.skipL039
    350  10b2				   .condpart3
    351  10b2		       a5 e4		      LDA	inv_hit
    352  10b4		       c9 00		      CMP	#0
    353  10b6		       d0 0c		      BNE	.skip3then
    354  10b8				   .condpart4
    355  10b8		       a2 63		      LDX	#<player4then_0
    356  10ba		       86 a2		      STX	player0pointerlo
    357  10bc		       a9 f4		      LDA	#>player4then_0
    358  10be		       85 a3		      STA	player0pointerhi
    359  10c0		       a9 09		      LDA	#9
    360  10c2		       85 b0		      STA	player0height
    361  10c4				   .skip3then
    362  10c4				   .skipL039
    363  10c4				   .
    364  10c4							; 
    365  10c4
    366  10c4				   .L040		;  if inv_delay  >  30 then inv_delay	=  0
    367  10c4
    368  10c4		       a9 1e		      LDA	#30
    369  10c6		       c5 d9		      CMP	inv_delay
    370  10c8		       b0 04		      BCS	.skipL040
    371  10ca				   .condpart5
    372  10ca		       a9 00		      LDA	#0
    373  10cc		       85 d9		      STA	inv_delay
    374  10ce				   .skipL040
    375  10ce				   .
    376  10ce							; 
    377  10ce
    378  10ce				   .
    379  10ce							; 
    380  10ce
    381  10ce				   .L041		;  COLUP0  =  52
    382  10ce
    383  10ce		       a9 34		      LDA	#52
    384  10d0		       85 06		      STA	COLUP0
    385  10d2				   .
    386  10d2							; 
    387  10d2
    388  10d2				   .
    389  10d2							; 
    390  10d2
    391  10d2				   .L042		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  15 then inv_x  =  inv_x  +  1
    392  10d2
    393  10d2		       a5 e4		      LDA	inv_hit
    394  10d4		       c9 00		      CMP	#0
    395  10d6		       d0 0e		      BNE	.skipL042
    396  10d8				   .condpart6
    397  10d8		       a5 dc		      LDA	inv_dir
    398  10da		       c9 01		      CMP	#1
    399  10dc		       d0 08		      BNE	.skip6then
    400  10de				   .condpart7
    401  10de		       a5 d9		      LDA	inv_delay
    402  10e0		       c9 0f		      CMP	#15
    403  10e2		       d0 02		      BNE	.skip7then
    404  10e4				   .condpart8
    405  10e4		       e6 d7		      INC	inv_x
    406  10e6				   .skip7then
    407  10e6				   .skip6then
    408  10e6				   .skipL042
    409  10e6				   .L043		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  30 then inv_x  =  inv_x  +  1
    410  10e6
    411  10e6		       a5 e4		      LDA	inv_hit
    412  10e8		       c9 00		      CMP	#0
    413  10ea		       d0 0e		      BNE	.skipL043
    414  10ec				   .condpart9
    415  10ec		       a5 dc		      LDA	inv_dir
    416  10ee		       c9 01		      CMP	#1
    417  10f0		       d0 08		      BNE	.skip9then
    418  10f2				   .condpart10
    419  10f2		       a5 d9		      LDA	inv_delay
    420  10f4		       c9 1e		      CMP	#30
    421  10f6		       d0 02		      BNE	.skip10then
    422  10f8				   .condpart11
    423  10f8		       e6 d7		      INC	inv_x
    424  10fa				   .skip10then
    425  10fa				   .skip9then
    426  10fa				   .skipL043
    427  10fa				   .
    428  10fa							; 
    429  10fa
    430  10fa				   .L044		;  if inv_x  >  143 then inv_dir  =  0  :  inv_x  =  143  :  inv_y  =	inv_y  -  5
    431  10fa
    432  10fa		       a9 8f		      LDA	#143
    433  10fc		       c5 d7		      CMP	inv_x
    434  10fe		       b0 0f		      BCS	.skipL044
    435  1100				   .condpart12
    436  1100		       a9 00		      LDA	#0
    437  1102		       85 dc		      STA	inv_dir
    438  1104		       a9 8f		      LDA	#143
    439  1106		       85 d7		      STA	inv_x
    440  1108		       a5 d8		      LDA	inv_y
    441  110a		       38		      SEC
    442  110b		       e9 05		      SBC	#5
    443  110d		       85 d8		      STA	inv_y
    444  110f				   .skipL044
    445  110f				   .
    446  110f							; 
    447  110f
    448  110f				   .
    449  110f							; 
    450  110f
    451  110f				   .L045		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  15 then inv_x  =  inv_x  -  1
    452  110f
    453  110f		       a5 e4		      LDA	inv_hit
    454  1111		       c9 00		      CMP	#0
    455  1113		       d0 0e		      BNE	.skipL045
    456  1115				   .condpart13
    457  1115		       a5 dc		      LDA	inv_dir
    458  1117		       c9 00		      CMP	#0
    459  1119		       d0 08		      BNE	.skip13then
    460  111b				   .condpart14
    461  111b		       a5 d9		      LDA	inv_delay
    462  111d		       c9 0f		      CMP	#15
    463  111f		       d0 02		      BNE	.skip14then
    464  1121				   .condpart15
    465  1121		       c6 d7		      DEC	inv_x
    466  1123				   .skip14then
    467  1123				   .skip13then
    468  1123				   .skipL045
    469  1123				   .L046		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  30 then inv_x  =  inv_x  -  1
    470  1123
    471  1123		       a5 e4		      LDA	inv_hit
    472  1125		       c9 00		      CMP	#0
    473  1127		       d0 0e		      BNE	.skipL046
    474  1129				   .condpart16
    475  1129		       a5 dc		      LDA	inv_dir
    476  112b		       c9 00		      CMP	#0
    477  112d		       d0 08		      BNE	.skip16then
    478  112f				   .condpart17
    479  112f		       a5 d9		      LDA	inv_delay
    480  1131		       c9 1e		      CMP	#30
    481  1133		       d0 02		      BNE	.skip17then
    482  1135				   .condpart18
    483  1135		       c6 d7		      DEC	inv_x
    484  1137				   .skip17then
    485  1137				   .skip16then
    486  1137				   .skipL046
    487  1137				   .
    488  1137							; 
    489  1137
    490  1137				   .L047		;  if inv_x  <  26 then inv_dir  =  1	:  inv_x  =  26  :  inv_y  =  inv_y  -	5
    491  1137
    492  1137		       a5 d7		      LDA	inv_x
    493  1139		       c9 1a		      CMP	#26
    494  113b		       b0 0f		      BCS	.skipL047
    495  113d				   .condpart19
    496  113d		       a9 01		      LDA	#1
    497  113f		       85 dc		      STA	inv_dir
    498  1141		       a9 1a		      LDA	#26
    499  1143		       85 d7		      STA	inv_x
    500  1145		       a5 d8		      LDA	inv_y
    501  1147		       38		      SEC
    502  1148		       e9 05		      SBC	#5
    503  114a		       85 d8		      STA	inv_y
    504  114c				   .skipL047
    505  114c				   .
    506  114c							; 
    507  114c
    508  114c				   .
    509  114c							; 
    510  114c
    511  114c				   .L048		;  player0x  =  inv_x	-  8  :  player0y  =  inv_y
    512  114c
    513  114c		       a5 d7		      LDA	inv_x
    514  114e		       38		      SEC
    515  114f		       e9 08		      SBC	#8
    516  1151		       85 84		      STA	player0x
    517  1153		       a5 d8		      LDA	inv_y
    518  1155		       85 8d		      STA	player0y
    519  1157				   .L049		;  return
    520  1157
    521  1157		       ba		      tsx
    522  1158		       b5 02		      lda	2,x	; check return address
    523  115a		       49 d1		      eor	#(>*)	; vs. current PCH
    524  115c		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    525  115e		       f0 03		      beq	*+5	; if equal, do normal return
    526  1160		       4c dd ff 	      JMP	BS_return
    527  1163		       60		      RTS
    528  1164				   .
    529  1164							; 
    530  1164
    531  1164				   .
    532  1164							; 
    533  1164
    534  1164				   .
    535  1164							; 
    536  1164
    537  1164				   .
    538  1164							; 
    539  1164
    540  1164				   .draw__move_inv_shot
    541  1164							; draw__move_inv_shot
    542  1164
    543  1164				   .
    544  1164							; 
    545  1164
    546  1164				   .L050		;  player2:
    547  1164
    548  1164		       a2 6c		      LDX	#<playerL050_2
    549  1166		       86 a7		      STX	player2pointerlo
    550  1168		       a9 f4		      LDA	#>playerL050_2
    551  116a		       85 ac		      STA	player2pointerhi
    552  116c		       a9 09		      LDA	#9
    553  116e		       85 b2		      STA	player2height
    554  1170				   .
    555  1170							; 
    556  1170
    557  1170				   .L051		;  COLUP2  =  14
    558  1170
    559  1170		       a9 0e		      LDA	#14
    560  1172		       85 99		      STA	COLUP2
    561  1174				   .
    562  1174							; 
    563  1174
    564  1174				   .L052		;  inv_fire_delay  =  inv_fire_delay  +  1
    565  1174
    566  1174		       e6 e1		      INC	inv_fire_delay
    567  1176				   .
    568  1176							; 
    569  1176
    570  1176				   .L053		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_shot_x  =  inv_x  :  inv_shot_y  =	inv_y  -  9
    571  1176
    572  1176		       a5 e2		      LDA	inv_fired
    573  1178		       c9 00		      CMP	#0
    574  117a		       d0 11		      BNE	.skipL053
    575  117c				   .condpart20
    576  117c		       a5 e1		      LDA	inv_fire_delay
    577  117e		       c9 b4		      CMP	#180
    578  1180		       d0 0b		      BNE	.skip20then
    579  1182				   .condpart21
    580  1182		       a5 d7		      LDA	inv_x
    581  1184		       85 dd		      STA	inv_shot_x
    582  1186		       a5 d8		      LDA	inv_y
    583  1188		       38		      SEC
    584  1189		       e9 09		      SBC	#9
    585  118b		       85 de		      STA	inv_shot_y
    586  118d				   .skip20then
    587  118d				   .skipL053
    588  118d				   .L054		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then player2x  =  inv_shot_x  :  player2y  =  inv_shot_y
    589  118d
    590  118d		       a5 e2		      LDA	inv_fired
    591  118f		       c9 00		      CMP	#0
    592  1191		       d0 0e		      BNE	.skipL054
    593  1193				   .condpart22
    594  1193		       a5 e1		      LDA	inv_fire_delay
    595  1195		       c9 b4		      CMP	#180
    596  1197		       d0 08		      BNE	.skip22then
    597  1199				   .condpart23
    598  1199		       a5 dd		      LDA	inv_shot_x
    599  119b		       85 86		      STA	player2x
    600  119d		       a5 de		      LDA	inv_shot_y
    601  119f		       85 8f		      STA	player2y
    602  11a1				   .skip22then
    603  11a1				   .skipL054
    604  11a1				   .L055		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_fired  =  1
    605  11a1
    606  11a1		       a5 e2		      LDA	inv_fired
    607  11a3		       c9 00		      CMP	#0
    608  11a5		       d0 0a		      BNE	.skipL055
    609  11a7				   .condpart24
    610  11a7		       a5 e1		      LDA	inv_fire_delay
    611  11a9		       c9 b4		      CMP	#180
    612  11ab		       d0 04		      BNE	.skip24then
    613  11ad				   .condpart25
    614  11ad		       a9 01		      LDA	#1
    615  11af		       85 e2		      STA	inv_fired
    616  11b1				   .skip24then
    617  11b1				   .skipL055
    618  11b1				   .
    619  11b1							; 
    620  11b1
    621  11b1				   .L056		;  if inv_fired  =  1 then inv_shot_y	=  inv_shot_y  -  2  :	player2y  =  inv_shot_y
    622  11b1
    623  11b1		       a5 e2		      LDA	inv_fired
    624  11b3		       c9 01		      CMP	#1
    625  11b5		       d0 0b		      BNE	.skipL056
    626  11b7				   .condpart26
    627  11b7		       a5 de		      LDA	inv_shot_y
    628  11b9		       38		      SEC
    629  11ba		       e9 02		      SBC	#2
    630  11bc		       85 de		      STA	inv_shot_y
    631  11be		       a5 de		      LDA	inv_shot_y
    632  11c0		       85 8f		      STA	player2y
    633  11c2				   .skipL056
    634  11c2				   .
    635  11c2							; 
    636  11c2
    637  11c2				   .L057		;  if inv_shot_y  <  12 then inv_fired  =  0  :  inv_fire_delay  =  0	:  inv_shot_y  =  88  :  player2y  =  inv_shot_y
    638  11c2
    639  11c2		       a5 de		      LDA	inv_shot_y
    640  11c4		       c9 0c		      CMP	#12
    641  11c6		       b0 0e		      BCS	.skipL057
    642  11c8				   .condpart27
    643  11c8		       a9 00		      LDA	#0
    644  11ca		       85 e2		      STA	inv_fired
    645  11cc		       85 e1		      STA	inv_fire_delay
    646  11ce		       a9 58		      LDA	#88
    647  11d0		       85 de		      STA	inv_shot_y
    648  11d2		       a5 de		      LDA	inv_shot_y
    649  11d4		       85 8f		      STA	player2y
    650  11d6				   .skipL057
    651  11d6				   .
    652  11d6							; 
    653  11d6
    654  11d6				   .L058		;  return
    655  11d6
    656  11d6		       ba		      tsx
    657  11d7		       b5 02		      lda	2,x	; check return address
    658  11d9		       49 d1		      eor	#(>*)	; vs. current PCH
    659  11db		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    660  11dd		       f0 03		      beq	*+5	; if equal, do normal return
    661  11df		       4c dd ff 	      JMP	BS_return
    662  11e2		       60		      RTS
    663  11e3				   .
    664  11e3							; 
    665  11e3
    666  11e3				   .
    667  11e3							; 
    668  11e3
    669  11e3				   .
    670  11e3							; 
    671  11e3
    672  11e3				   .
    673  11e3							; 
    674  11e3
    675  11e3				   .col_shot_inv
    676  11e3							; col_shot_inv
    677  11e3
    678  11e3				   .L059		;  if shot_x  +  3  >=  inv_x	&&  shot_x  +  3  <=  inv_x  +	6  &&  shot_y  >  inv_y then inv_hit  =  1
    679  11e3
    680  11e3							; complex condition detected
    681  11e3		       a5 df		      LDA	shot_x
    682  11e5		       18		      CLC
    683  11e6		       69 03		      ADC	#3
    684  11e8							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
    685  11e8		       c5 d7		      CMP	inv_x
    686  11ea		       90 1d		      BCC	.skipL059
    687  11ec				   .condpart28
    688  11ec							; complex condition detected
    689  11ec		       a5 d7		      LDA	inv_x
    690  11ee		       18		      CLC
    691  11ef		       69 06		      ADC	#6
    692  11f1		       48		      PHA
    693  11f2		       a5 df		      LDA	shot_x
    694  11f4		       18		      CLC
    695  11f5		       69 03		      ADC	#3
    696  11f7		       48		      PHA
    697  11f8		       ba		      TSX
    698  11f9		       68		      PLA
    699  11fa		       68		      PLA
    700  11fb							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
    701  11fb		       d5 01		      CMP	1,x
    702  11fd		       90 0a		      BCC	.skip28then
    703  11ff				   .condpart29
    704  11ff		       a5 d8		      LDA	inv_y
    705  1201		       c5 e0		      CMP	shot_y
    706  1203		       b0 04		      BCS	.skip29then
    707  1205				   .condpart30
    708  1205		       a9 01		      LDA	#1
    709  1207		       85 e4		      STA	inv_hit
    710  1209				   .skip29then
    711  1209				   .skip28then
    712  1209				   .skipL059
    713  1209				   .
    714  1209							; 
    715  1209
    716  1209				   .L060		;  if inv_hit	=  1 then inv_blast_delay  =  inv_blast_delay  +  1
    717  1209
    718  1209		       a5 e4		      LDA	inv_hit
    719  120b		       c9 01		      CMP	#1
    720  120d		       d0 02		      BNE	.skipL060
    721  120f				   .condpart31
    722  120f		       e6 e5		      INC	inv_blast_delay
    723  1211				   .skipL060
    724  1211				   .
    725  1211							; 
    726  1211
    727  1211				   .L061		;  if inv_blast_delay	>  30 then score  =  score  +  10  :  inv_hit  =  0  :	gosub reset_blast
    728  1211
    729  1211		       a9 1e		      LDA	#30
    730  1213		       c5 e5		      CMP	inv_blast_delay
    731  1215		       b0 1c		      BCS	.skipL061
    732  1217				   .condpart32
    733  1217		       f8		      SED
    734  1218		       18		      CLC
    735  1219		       a5 d4		      LDA	score+2
    736  121b		       69 10		      ADC	#$10
    737  121d		       85 d4		      STA	score+2
    738  121f		       a5 d3		      LDA	score+1
    739  1221		       69 00		      ADC	#$00
    740  1223		       85 d3		      STA	score+1
    741  1225		       a5 d2		      LDA	score
    742  1227		       69 00		      ADC	#$00
    743  1229		       85 d2		      STA	score
    744  122b		       d8		      CLD
    745  122c		       a9 00		      LDA	#0
    746  122e		       85 e4		      STA	inv_hit
    747  1230		       20 52 d2 	      jsr	.reset_blast
    748  1233
    749  1233				   .skipL061
    750  1233				   .
    751  1233							; 
    752  1233
    753  1233				   .L062		;  if inv_hit	=  1 then player0:  
    754  1233
    755  1233		       a5 e4		      LDA	inv_hit
    756  1235		       c9 01		      CMP	#1
    757  1237		       d0 0c		      BNE	.skipL062
    758  1239				   .condpart33
    759  1239		       a2 74		      LDX	#<player33then_0
    760  123b		       86 a2		      STX	player0pointerlo
    761  123d		       a9 f4		      LDA	#>player33then_0
    762  123f		       85 a3		      STA	player0pointerhi
    763  1241		       a9 09		      LDA	#9
    764  1243		       85 b0		      STA	player0height
    765  1245				   .skipL062
    766  1245				   .
    767  1245							; 
    768  1245
    769  1245				   .L063		;  return
    770  1245
    771  1245		       ba		      tsx
    772  1246		       b5 02		      lda	2,x	; check return address
    773  1248		       49 d2		      eor	#(>*)	; vs. current PCH
    774  124a		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    775  124c		       f0 03		      beq	*+5	; if equal, do normal return
    776  124e		       4c dd ff 	      JMP	BS_return
    777  1251		       60		      RTS
    778  1252				   .
    779  1252							; 
    780  1252
    781  1252				   .
    782  1252							; 
    783  1252
    784  1252				   .
    785  1252							; 
    786  1252
    787  1252				   .
    788  1252							; 
    789  1252
    790  1252				   .reset_blast
    791  1252							; reset_blast
    792  1252
    793  1252				   .L064		;  player0:  
    794  1252
    795  1252		       a2 7d		      LDX	#<playerL064_0
    796  1254		       86 a2		      STX	player0pointerlo
    797  1256		       a9 f4		      LDA	#>playerL064_0
    798  1258		       85 a3		      STA	player0pointerhi
    799  125a		       a9 09		      LDA	#9
    800  125c		       85 b0		      STA	player0height
    801  125e				   .
    802  125e							; 
    803  125e
    804  125e				   .
    805  125e							; 
    806  125e
    807  125e				   .L065		;  inv_blast_delay  =	0  :  inv_x  =	 ( rand & 117 )   +  26  :  inv_y  =  76
    808  125e
    809  125e		       a9 00		      LDA	#0
    810  1260		       85 e5		      STA	inv_blast_delay
    811  1262							; complex statement detected
    812  1262		       85 d1		      sta	temp7
    813  1264		       a9 d2		      lda	#>(ret_point2-1)
    814  1266		       48		      pha
    815  1267		       a9 79		      lda	#<(ret_point2-1)
    816  1269		       48		      pha
    817  126a		       a9 f4		      lda	#>(randomize-1)
    818  126c		       48		      pha
    819  126d		       a9 34		      lda	#<(randomize-1)
    820  126f		       48		      pha
    821  1270		       a5 d1		      lda	temp7
    822  1272		       48		      pha
    823  1273		       8a		      txa
    824  1274		       48		      pha
    825  1275		       a2 02		      ldx	#2
    826  1277		       4c eb ff 	      jmp	BS_jsr
    827  127a				   ret_point2
    828  127a		       29 75		      AND	#117
    829  127c		       18		      CLC
    830  127d		       69 1a		      ADC	#26
    831  127f		       85 d7		      STA	inv_x
    832  1281		       a9 4c		      LDA	#76
    833  1283		       85 d8		      STA	inv_y
    834  1285				   .
    835  1285							; 
    836  1285
    837  1285				   .L066		;  return
    838  1285
    839  1285		       ba		      tsx
    840  1286		       b5 02		      lda	2,x	; check return address
    841  1288		       49 d2		      eor	#(>*)	; vs. current PCH
    842  128a		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    843  128c		       f0 03		      beq	*+5	; if equal, do normal return
    844  128e		       4c dd ff 	      JMP	BS_return
    845  1291		       60		      RTS
    846  1292				   .
    847  1292							; 
    848  1292
    849  1292				   .
    850  1292							; 
    851  1292
    852  1292				   .
    853  1292							; 
    854  1292
    855  1292				   .
    856  1292							; 
    857  1292
    858  1292				   .draw__move_turret
    859  1292							; draw__move_turret
    860  1292
    861  1292				   .L067		;  player1:
    862  1292
    863  1292		       a2 86		      LDX	#<playerL067_1
    864  1294		       86 a6		      STX	player1pointerlo
    865  1296		       a9 f4		      LDA	#>playerL067_1
    866  1298		       85 ab		      STA	player1pointerhi
    867  129a		       a9 09		      LDA	#9
    868  129c		       85 b1		      STA	player1height
    869  129e				   .
    870  129e							; 
    871  129e
    872  129e				   .
    873  129e							; 
    874  129e
    875  129e				   .L068		;  _COLUP1  =	196
    876  129e
    877  129e		       a9 c4		      LDA	#196
    878  12a0		       85 98		      STA	_COLUP1
    879  12a2				   .
    880  12a2							; 
    881  12a2
    882  12a2				   .L069		;  if joy0left  &&  tur_x  >=	26 then tur_x  =  tur_x  -  1
    883  12a2
    884  12a2		       2c 80 02 	      bit	SWCHA
    885  12a5		       70 08		      BVS	.skipL069
    886  12a7				   .condpart34
    887  12a7		       a5 da		      LDA	tur_x
    888  12a9		       c9 1a		      CMP	#26
    889  12ab		       90 02		      BCC	.skip34then
    890  12ad				   .condpart35
    891  12ad		       c6 da		      DEC	tur_x
    892  12af				   .skip34then
    893  12af				   .skipL069
    894  12af				   .L070		;  if joy0right  &&  tur_x  <=  143 then tur_x  =  tur_x  +  1
    895  12af
    896  12af		       2c 80 02 	      bit	SWCHA
    897  12b2		       30 08		      BMI	.skipL070
    898  12b4				   .condpart36
    899  12b4		       a9 8f		      LDA	#143
    900  12b6		       c5 da		      CMP	tur_x
    901  12b8		       90 02		      BCC	.skip36then
    902  12ba				   .condpart37
    903  12ba		       e6 da		      INC	tur_x
    904  12bc				   .skip36then
    905  12bc				   .skipL070
    906  12bc				   .
    907  12bc							; 
    908  12bc
    909  12bc				   .
    910  12bc							; 
    911  12bc
    912  12bc				   .
    913  12bc							; 
    914  12bc
    915  12bc				   .
    916  12bc							; 
    917  12bc
    918  12bc				   .L071		;  player1x  =  tur_x	:  player1y  =	tur_y
    919  12bc
    920  12bc		       a5 da		      LDA	tur_x
    921  12be		       85 85		      STA	player1x
    922  12c0		       a5 db		      LDA	tur_y
    923  12c2		       85 8e		      STA	player1y
    924  12c4				   .
    925  12c4							; 
    926  12c4
    927  12c4				   .L072		;  return
    928  12c4
    929  12c4		       ba		      tsx
    930  12c5		       b5 02		      lda	2,x	; check return address
    931  12c7		       49 d2		      eor	#(>*)	; vs. current PCH
    932  12c9		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    933  12cb		       f0 03		      beq	*+5	; if equal, do normal return
    934  12cd		       4c dd ff 	      JMP	BS_return
    935  12d0		       60		      RTS
    936  12d1				   .
    937  12d1							; 
    938  12d1
    939  12d1				   .
    940  12d1							; 
    941  12d1
    942  12d1				   .
    943  12d1							; 
    944  12d1
    945  12d1				   .
    946  12d1							; 
    947  12d1
    948  12d1				   .draw__move_turret_shot
    949  12d1							; draw__move_turret_shot
    950  12d1
    951  12d1				   .L073		;  player3:
    952  12d1
    953  12d1		       a2 8e		      LDX	#<playerL073_3
    954  12d3		       86 a8		      STX	player3pointerlo
    955  12d5		       a9 f4		      LDA	#>playerL073_3
    956  12d7		       85 ad		      STA	player3pointerhi
    957  12d9		       a9 09		      LDA	#9
    958  12db		       85 b3		      STA	player3height
    959  12dd				   .
    960  12dd							; 
    961  12dd
    962  12dd				   .L074		;  COLUP3  =  14
    963  12dd
    964  12dd		       a9 0e		      LDA	#14
    965  12df		       85 9a		      STA	COLUP3
    966  12e1				   .
    967  12e1							; 
    968  12e1
    969  12e1				   .L075		;  if joy0fire  &&  tur_fired	=  0 then tur_fired  =	1  :  shot_x  =  tur_x	:  shot_y  =  tur_y  +	1  :  player3x	=  shot_x  :  player3y	=  shot_y
    970  12e1
    971  12e1		       24 0c		      bit	INPT4
    972  12e3		       30 1d		      BMI	.skipL075
    973  12e5				   .condpart38
    974  12e5		       a5 e3		      LDA	tur_fired
    975  12e7		       c9 00		      CMP	#0
    976  12e9		       d0 17		      BNE	.skip38then
    977  12eb				   .condpart39
    978  12eb		       a9 01		      LDA	#1
    979  12ed		       85 e3		      STA	tur_fired
    980  12ef		       a5 da		      LDA	tur_x
    981  12f1		       85 df		      STA	shot_x
    982  12f3		       a5 db		      LDA	tur_y
    983  12f5		       18		      CLC
    984  12f6		       69 01		      ADC	#1
    985  12f8		       85 e0		      STA	shot_y
    986  12fa		       a5 df		      LDA	shot_x
    987  12fc		       85 87		      STA	player3x
    988  12fe		       a5 e0		      LDA	shot_y
    989  1300		       85 90		      STA	player3y
    990  1302				   .skip38then
    991  1302				   .skipL075
    992  1302				   .
    993  1302							; 
    994  1302
    995  1302				   .L076		;  if tur_fired  =  1 then shot_y  =  shot_y  +  2  :	player3x  =  shot_x  :	player3y  =  shot_y
    996  1302
    997  1302		       a5 e3		      LDA	tur_fired
    998  1304		       c9 01		      CMP	#1
    999  1306		       d0 0f		      BNE	.skipL076
   1000  1308				   .condpart40
   1001  1308		       a5 e0		      LDA	shot_y
   1002  130a		       18		      CLC
   1003  130b		       69 02		      ADC	#2
   1004  130d		       85 e0		      STA	shot_y
   1005  130f		       a5 df		      LDA	shot_x
   1006  1311		       85 87		      STA	player3x
   1007  1313		       a5 e0		      LDA	shot_y
   1008  1315		       85 90		      STA	player3y
   1009  1317				   .skipL076
   1010  1317				   .
   1011  1317							; 
   1012  1317
   1013  1317				   .L077		;  if shot_y  >  77  &&  ! joy0fire then tur_fired  =	0  :  shot_y  =  0  :  player3y  =  shot_y
   1014  1317
   1015  1317		       a9 4d		      LDA	#77
   1016  1319		       c5 e0		      CMP	shot_y
   1017  131b		       b0 0e		      BCS	.skipL077
   1018  131d				   .condpart41
   1019  131d		       24 0c		      bit	INPT4
   1020  131f		       10 0a		      BPL	.skip41then
   1021  1321				   .condpart42
   1022  1321		       a9 00		      LDA	#0
   1023  1323		       85 e3		      STA	tur_fired
   1024  1325		       85 e0		      STA	shot_y
   1025  1327		       a5 e0		      LDA	shot_y
   1026  1329		       85 90		      STA	player3y
   1027  132b				   .skip41then
   1028  132b				   .skipL077
   1029  132b				   .
   1030  132b							; 
   1031  132b
   1032  132b				   .L078		;  return
   1033  132b
   1034  132b		       ba		      tsx
   1035  132c		       b5 02		      lda	2,x	; check return address
   1036  132e		       49 d3		      eor	#(>*)	; vs. current PCH
   1037  1330		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1038  1332		       f0 03		      beq	*+5	; if equal, do normal return
   1039  1334		       4c dd ff 	      JMP	BS_return
   1040  1337		       60		      RTS
   1041  1338				   .
   1042  1338							; 
   1043  1338
   1044  1338				   .
   1045  1338							; 
   1046  1338
   1047  1338				   .
   1048  1338							; 
   1049  1338
   1050  1338				   .
   1051  1338							; 
   1052  1338
   1053  1338				   .col_inv_shot_turret
   1054  1338							; col_inv_shot_turret
   1055  1338
   1056  1338				   .
   1057  1338							; 
   1058  1338
   1059  1338				   .L079		;  if inv_shot_x  +  4  >=  tur_x  &&	inv_shot_x  +  2  <=  tur_x  +	6  &&  inv_shot_y  -  5  <  tur_y  - 5 then tur_hit  =	1
   1060  1338
   1061  1338							; complex condition detected
   1062  1338		       a5 dd		      LDA	inv_shot_x
   1063  133a		       18		      CLC
   1064  133b		       69 04		      ADC	#4
   1065  133d							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   1066  133d		       c5 da		      CMP	tur_x
   1067  133f		       90 2a		      BCC	.skipL079
   1068  1341				   .condpart43
   1069  1341							; complex condition detected
   1070  1341		       a5 da		      LDA	tur_x
   1071  1343		       18		      CLC
   1072  1344		       69 06		      ADC	#6
   1073  1346		       48		      PHA
   1074  1347		       a5 dd		      LDA	inv_shot_x
   1075  1349		       18		      CLC
   1076  134a		       69 02		      ADC	#2
   1077  134c		       48		      PHA
   1078  134d		       ba		      TSX
   1079  134e		       68		      PLA
   1080  134f		       68		      PLA
   1081  1350							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
   1082  1350		       d5 01		      CMP	1,x
   1083  1352		       90 17		      BCC	.skip43then
   1084  1354				   .condpart44
   1085  1354							; complex condition detected
   1086  1354		       a5 de		      LDA	inv_shot_y
   1087  1356		       38		      SEC
   1088  1357		       e9 05		      SBC	#5
   1089  1359		       48		      PHA
   1090  135a		       a5 db		      LDA	tur_y
   1091  135c		       38		      SEC
   1092  135d		       e9 05		      SBC	#5
   1093  135f		       48		      PHA
   1094  1360		       ba		      TSX
   1095  1361		       68		      PLA
   1096  1362		       68		      PLA
   1097  1363		       d5 01		      CMP	1,x
   1098  1365		       b0 04		      BCS	.skip44then
   1099  1367				   .condpart45
   1100  1367		       a9 01		      LDA	#1
   1101  1369		       85 e7		      STA	tur_hit
   1102  136b				   .skip44then
   1103  136b				   .skip43then
   1104  136b				   .skipL079
   1105  136b				   .
   1106  136b							; 
   1107  136b
   1108  136b				   .L080		;  if tur_hit	=  1 then tur_anim_playing  =  1  :  gosub play_tur_anim
   1109  136b
   1110  136b		       a5 e7		      LDA	tur_hit
   1111  136d		       c9 01		      CMP	#1
   1112  136f		       d0 07		      BNE	.skipL080
   1113  1371				   .condpart46
   1114  1371		       a9 01		      LDA	#1
   1115  1373		       85 e8		      STA	tur_anim_playing
   1116  1375		       20 85 d3 	      jsr	.play_tur_anim
   1117  1378
   1118  1378				   .skipL080
   1119  1378				   .
   1120  1378							; 
   1121  1378
   1122  1378				   .L081		;  return
   1123  1378
   1124  1378		       ba		      tsx
   1125  1379		       b5 02		      lda	2,x	; check return address
   1126  137b		       49 d3		      eor	#(>*)	; vs. current PCH
   1127  137d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1128  137f		       f0 03		      beq	*+5	; if equal, do normal return
   1129  1381		       4c dd ff 	      JMP	BS_return
   1130  1384		       60		      RTS
   1131  1385				   .
   1132  1385							; 
   1133  1385
   1134  1385				   .
   1135  1385							; 
   1136  1385
   1137  1385				   .
   1138  1385							; 
   1139  1385
   1140  1385				   .play_tur_anim
   1141  1385							; play_tur_anim
   1142  1385
   1143  1385				   .
   1144  1385							; 
   1145  1385
   1146  1385				   .
   1147  1385							; 
   1148  1385
   1149  1385				   .
   1150  1385							; 
   1151  1385
   1152  1385				   .
   1153  1385							; 
   1154  1385
   1155  1385				   .
   1156  1385							; 
   1157  1385
   1158  1385				   .
   1159  1385							; 
   1160  1385
   1161  1385				   .
   1162  1385							; 
   1163  1385
   1164  1385				   .
   1165  1385							; 
   1166  1385
   1167  1385				   .L082		;  return
   1168  1385
   1169  1385		       ba		      tsx
   1170  1386		       b5 02		      lda	2,x	; check return address
   1171  1388		       49 d3		      eor	#(>*)	; vs. current PCH
   1172  138a		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1173  138c		       f0 03		      beq	*+5	; if equal, do normal return
   1174  138e		       4c dd ff 	      JMP	BS_return
   1175  1391		       60		      RTS
   1176  1392				   .
   1177  1392							; 
   1178  1392
   1179  1392				   .
   1180  1392							; 
   1181  1392
   1182  1392				   .
   1183  1392							; 
   1184  1392
   1185  1392				   .game_over
   1186  1392							; game_over
   1187  1392
   1188  1392				   .
   1189  1392							; 
   1190  1392
   1191  1392				   .L083		;  if joy0up then reboot
   1192  1392
   1193  1392		       a9 10		      lda	#$10
   1194  1394		       2c 80 02 	      bit	SWCHA
   1195  1397		       d0 03		      BNE	.skipL083
   1196  1399				   .condpart47
   1197  1399		       6c fc ff 	      JMP	($FFFC)
   1198  139c				   .skipL083
   1199  139c				   .
   1200  139c							; 
   1201  139c
   1202  139c				   .
   1203  139c							; 
   1204  139c
   1205  139c				   .
   1206  139c							; 
   1207  139c
   1208  139c				   .L084		;  player2:
   1209  139c
   1210  139c		       a2 96		      LDX	#<playerL084_2
   1211  139e		       86 a7		      STX	player2pointerlo
   1212  13a0		       a9 f4		      LDA	#>playerL084_2
   1213  13a2		       85 ac		      STA	player2pointerhi
   1214  13a4		       a9 1a		      LDA	#26
   1215  13a6		       85 b2		      STA	player2height
   1216  13a8				   .
   1217  13a8							; 
   1218  13a8
   1219  13a8				   .L085		;  player3:
   1220  13a8
   1221  13a8		       a2 af		      LDX	#<playerL085_3
   1222  13aa		       86 a8		      STX	player3pointerlo
   1223  13ac		       a9 f4		      LDA	#>playerL085_3
   1224  13ae		       85 ad		      STA	player3pointerhi
   1225  13b0		       a9 1a		      LDA	#26
   1226  13b2		       85 b3		      STA	player3height
   1227  13b4				   .
   1228  13b4							; 
   1229  13b4
   1230  13b4				   .L086		;  player0x  =  0  :  player0y  =  0
   1231  13b4
   1232  13b4		       a9 00		      LDA	#0
   1233  13b6		       85 84		      STA	player0x
   1234  13b8		       85 8d		      STA	player0y
   1235  13ba				   .L087		;  player1x  =  0  :  player1y  =  0
   1236  13ba
   1237  13ba		       a9 00		      LDA	#0
   1238  13bc		       85 85		      STA	player1x
   1239  13be		       85 8e		      STA	player1y
   1240  13c0				   .L088		;  COLUP0  =  0
   1241  13c0
   1242  13c0		       a9 00		      LDA	#0
   1243  13c2		       85 06		      STA	COLUP0
   1244  13c4				   .L089		;  COLUP1  =  0
   1245  13c4
   1246  13c4		       a9 00		      LDA	#0
   1247  13c6		       85 07		      STA	COLUP1
   1248  13c8				   .
   1249  13c8							; 
   1250  13c8
   1251  13c8				   .L090		;  player2x  =  85  :	player2y  =  66
   1252  13c8
   1253  13c8		       a9 55		      LDA	#85
   1254  13ca		       85 86		      STA	player2x
   1255  13cc		       a9 42		      LDA	#66
   1256  13ce		       85 8f		      STA	player2y
   1257  13d0				   .L091		;  player3x  =  85  :	player3y  =  39
   1258  13d0
   1259  13d0		       a9 55		      LDA	#85
   1260  13d2		       85 87		      STA	player3x
   1261  13d4		       a9 27		      LDA	#39
   1262  13d6		       85 90		      STA	player3y
   1263  13d8				   .
   1264  13d8							; 
   1265  13d8
   1266  13d8				   .L092		;  drawscreen
   1267  13d8
   1268  13d8		       85 d1		      sta	temp7
   1269  13da		       a9 d3		      lda	#>(ret_point3-1)
   1270  13dc		       48		      pha
   1271  13dd		       a9 ef		      lda	#<(ret_point3-1)
   1272  13df		       48		      pha
   1273  13e0		       a9 f0		      lda	#>(drawscreen-1)
   1274  13e2		       48		      pha
   1275  13e3		       a9 39		      lda	#<(drawscreen-1)
   1276  13e5		       48		      pha
   1277  13e6		       a5 d1		      lda	temp7
   1278  13e8		       48		      pha
   1279  13e9		       8a		      txa
   1280  13ea		       48		      pha
   1281  13eb		       a2 02		      ldx	#2
   1282  13ed		       4c eb ff 	      jmp	BS_jsr
   1283  13f0				   ret_point3
   1284  13f0				   .
   1285  13f0							; 
   1286  13f0
   1287  13f0				   .L093		;  goto game_over
   1288  13f0
   1289  13f0		       4c 92 d3 	      jmp	.game_over
   1290  13f3
   1291  13f3					      if	ECHO1
      3041 bytes of ROM space left in bank 1
   1292  13f3					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1293  13f3					      endif
   1294  13f3		       00 01	   ECHO1      =	1
   1295  1fd4					      ORG	$1FF4-bscode_length
   1296  1fd4					      RORG	$DFF4-bscode_length
   1297  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1298  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1299  1fd6				  -	      stx	FASTFETCH
   1300  1fd6					      endif
   1301  1fd6		       9a		      txs
   1302  1fd7				  -	      if	bankswitch == 64
   1303  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1304  1fd7					      else
   1305  1fd7		       a9 f3		      lda	#>(start-1)
   1306  1fd9					      endif
   1307  1fd9		       48		      pha
   1308  1fda		       a9 f7		      lda	#<(start-1)
   1309  1fdc		       48		      pha
   1310  1fdd		       48		      pha
   1311  1fde		       8a		      txa
   1312  1fdf		       48		      pha
   1313  1fe0		       ba		      tsx
   1314  1fe1					      if	bankswitch != 64
   1315  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1316  1fe3		       2a		      rol
   1317  1fe4		       2a		      rol
   1318  1fe5		       2a		      rol
   1319  1fe6		       2a		      rol
   1320  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1321  1fe9		       aa		      tax
   1322  1fea		       e8		      inx
   1323  1feb				  -	      else
   1324  1feb				  -	      lda	4,x	; get high byte of return address
   1325  1feb				  -	      tay
   1326  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1327  1feb				  -	      sta	4,x
   1328  1feb				  -	      tya
   1329  1feb				  -	      lsr
   1330  1feb				  -	      lsr
   1331  1feb				  -	      lsr
   1332  1feb				  -	      lsr
   1333  1feb				  -	      tax
   1334  1feb				  -	      inx
   1335  1feb					      endif
   1336  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1337  1fee		       68		      pla
   1338  1fef		       aa		      tax
   1339  1ff0		       68		      pla
   1340  1ff1		       60		      rts
   1341  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1342  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1343  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1344  1ff2					      endif
   1345  1ffc					      ORG	$1FFC
   1346  1ffc					      RORG	$DFFC
   1347  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
   1348  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
   1349  2000					      ORG	$2000
   1350  2000					      RORG	$F000
   1351  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1352  2000
   1353  2000				   FineAdjustTableBegin
   1354  2000		       60		      .byte.b	%01100000	;left 6
   1355  2001		       50		      .byte.b	%01010000
   1356  2002		       40		      .byte.b	%01000000
   1357  2003		       30		      .byte.b	%00110000
   1358  2004		       20		      .byte.b	%00100000
   1359  2005		       10		      .byte.b	%00010000
   1360  2006		       00		      .byte.b	%00000000	;left 0
   1361  2007		       f0		      .byte.b	%11110000
   1362  2008		       e0		      .byte.b	%11100000
   1363  2009		       d0		      .byte.b	%11010000
   1364  200a		       c0		      .byte.b	%11000000
   1365  200b		       b0		      .byte.b	%10110000
   1366  200c		       a0		      .byte.b	%10100000
   1367  200d		       90		      .byte.b	%10010000
   1368  200e		       80		      .byte.b	%10000000	;right 8
   1369  200e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
   1370  200f
   1371  200f				   PFStart
   1372  200f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
   1373  2017				   blank_pf
   1374  2017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
   1375  201f							; .byte 43,21,0,10,0,0,0,5
   1376  201f				  -	      ifconst	screenheight
   1377  201f				  -pfsub
   1378  201f				  -	      .byte	8,4,2,2,1,0,0,1,0
   1379  201f					      endif
   1380  201f							;--set initial P1 positions
   1381  201f				   multisprite_setup
   1382  201f		       a9 0f		      lda	#15
   1383  2021		       85 c4		      sta	pfheight
   1384  2023
   1385  2023		       a2 04		      ldx	#4
   1386  2025							; stx temp3
   1387  2025				   SetCopyHeight
   1388  2025							;	lda #76
   1389  2025							;	sta NewSpriteX,X
   1390  2025							;	lda CopyColorData,X
   1391  2025							;	sta NewCOLUP1,X
   1392  2025							;lda SpriteHeightTable,X
   1393  2025							; sta spriteheight,x
   1394  2025		       8a		      txa
   1395  2026		       95 9d		      sta	SpriteGfxIndex,X
   1396  2028		       95 f1		      sta	spritesort,X
   1397  202a		       ca		      dex
   1398  202b		       10 f8		      bpl	SetCopyHeight
   1399  202d
   1400  202d
   1401  202d
   1402  202d							; since we can't turn off pf, point PF to zeros here
   1403  202d		       a9 f0		      lda	#>blank_pf
   1404  202f		       85 be		      sta	PF2pointer+1
   1405  2031		       85 bc		      sta	PF1pointer+1
   1406  2033		       a9 17		      lda	#<blank_pf
   1407  2035		       85 bd		      sta	PF2pointer
   1408  2037		       85 bb		      sta	PF1pointer
   1409  2039		       60		      rts
   1410  203a
   1411  203a				   drawscreen
   1412  203a				  -	      ifconst	debugscore
   1413  203a				  -	      jsr	debugcycles
   1414  203a					      endif
   1415  203a
   1416  203a				   WaitForOverscanEnd
   1417  203a		       ad 84 02 	      lda	INTIM
   1418  203d		       30 fb		      bmi	WaitForOverscanEnd
   1419  203f
   1420  203f		       a9 02		      lda	#2
   1421  2041		       85 02		      sta	WSYNC
   1422  2043		       85 00		      sta	VSYNC
   1423  2045		       85 02		      sta	WSYNC
   1424  2047		       85 02		      sta	WSYNC
   1425  2049		       4a		      lsr
   1426  204a		       85 27		      sta	VDELBL
   1427  204c		       85 25		      sta	VDELP0
   1428  204e		       85 02		      sta	WSYNC
   1429  2050		       85 00		      sta	VSYNC	;turn off VSYNC
   1430  2052				  -	      ifconst	overscan_time
   1431  2052				  -	      lda	#overscan_time+5+128
   1432  2052					      else
   1433  2052		       a9 aa		      lda	#42+128
   1434  2054					      endif
   1435  2054		       8d 96 02 	      sta	TIM64T
   1436  2057
   1437  2057							; run possible vblank bB code
   1438  2057				  -	      ifconst	vblank_bB_code
   1439  2057				  -	      jsr	vblank_bB_code
   1440  2057					      endif
   1441  2057
   1442  2057		       20 dc f1 	      jsr	setscorepointers
   1443  205a		       20 7e f3 	      jsr	SetupP1Subroutine
   1444  205d
   1445  205d							;-------------
   1446  205d
   1447  205d
   1448  205d
   1449  205d
   1450  205d
   1451  205d							;--position P0, M0, M1, BL
   1452  205d
   1453  205d		       20 b5 f0 	      jsr	PrePositionAllObjects
   1454  2060
   1455  2060							;--set up player 0 pointer
   1456  2060
   1457  2060		       c6 8d		      dec	player0y
   1458  2062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
   1459  2064		       38		      sec
   1460  2065		       e5 8d		      sbc	player0y
   1461  2067		       18		      clc
   1462  2068		       65 b0		      adc	player0height
   1463  206a		       85 a2		      sta	player0pointer
   1464  206c
   1465  206c		       a5 8d		      lda	player0y
   1466  206e		       85 cf		      sta	P0Top
   1467  2070		       38		      sec
   1468  2071		       e5 b0		      sbc	player0height
   1469  2073		       18		      clc
   1470  2074		       69 80		      adc	#$80
   1471  2076		       85 a4		      sta	P0Bottom
   1472  2078
   1473  2078
   1474  2078							;--some final setup
   1475  2078
   1476  2078		       a2 04		      ldx	#4
   1477  207a		       a9 80		      lda	#$80
   1478  207c				   cycle74_HMCLR
   1479  207c		       95 20		      sta	HMP0,X
   1480  207e		       ca		      dex
   1481  207f		       10 fb		      bpl	cycle74_HMCLR
   1482  2081							;	sta HMCLR
   1483  2081
   1484  2081
   1485  2081		       a9 00		      lda	#0
   1486  2083		       85 0e		      sta	PF1
   1487  2085		       85 0f		      sta	PF2
   1488  2087		       85 1b		      sta	GRP0
   1489  2089		       85 1c		      sta	GRP1
   1490  208b
   1491  208b
   1492  208b		       20 d0 f0 	      jsr	KernelSetupSubroutine
   1493  208e
   1494  208e				   WaitForVblankEnd
   1495  208e		       ad 84 02 	      lda	INTIM
   1496  2091		       30 fb		      bmi	WaitForVblankEnd
   1497  2093		       a9 00		      lda	#0
   1498  2095		       85 02		      sta	WSYNC
   1499  2097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
   1500  2099		       85 2c		      sta	CXCLR
   1501  209b
   1502  209b
   1503  209b		       4c 5d f1 	      jmp	KernelRoutine
   1504  209e
   1505  209e
   1506  209e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
   1507  209e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
   1508  209e							;if you do not wish to write to P1 during this function, make
   1509  209e							;sure Y==0 before you call it.  This function will change Y, and A
   1510  209e							;will be the value put into HMxx when returned.
   1511  209e							;Call this function with at least 11 cycles left in the scanline 
   1512  209e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
   1513  209e							;into the second scanline
   1514  209e		       38		      sec
   1515  209f		       85 02		      sta	WSYNC	;begin line 1
   1516  20a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
   1517  20a4				   DivideBy15Loop
   1518  20a4		       e9 0f		      sbc	#15
   1519  20a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
   1520  20a8
   1521  20a8		       a8		      tay		;+2	10/15/...60
   1522  20a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
   1523  20ac
   1524  20ac							;	15
   1525  20ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
   1526  20ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
   1527  20b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1528  20b2		       85 2a		      sta	HMOVE	;+3
   1529  20b4		       60		      rts		;+6	 9
   1530  20b5
   1531  20b5							;-------------------------------------------------------------------------
   1532  20b5
   1533  20b5				   PrePositionAllObjects
   1534  20b5
   1535  20b5		       a2 04		      ldx	#4
   1536  20b7		       a5 82		      lda	ballx
   1537  20b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1538  20bc
   1539  20bc		       ca		      dex
   1540  20bd		       a5 81		      lda	missile1x
   1541  20bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1542  20c2
   1543  20c2		       ca		      dex
   1544  20c3		       a5 80		      lda	missile0x
   1545  20c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1546  20c8
   1547  20c8		       ca		      dex
   1548  20c9		       ca		      dex
   1549  20ca		       a5 84		      lda	player0x
   1550  20cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1551  20cf
   1552  20cf		       60		      rts
   1553  20d0
   1554  20d0
   1555  20d0							;-------------------------------------------------------------------------
   1556  20d0
   1557  20d0
   1558  20d0
   1559  20d0
   1560  20d0
   1561  20d0
   1562  20d0
   1563  20d0
   1564  20d0							;-------------------------------------------------------------------------
   1565  20d0
   1566  20d0
   1567  20d0				   KernelSetupSubroutine
   1568  20d0
   1569  20d0		       a2 04		      ldx	#4
   1570  20d2				   AdjustYValuesUpLoop
   1571  20d2		       b5 8e		      lda	NewSpriteY,X
   1572  20d4		       18		      clc
   1573  20d5		       69 02		      adc	#2
   1574  20d7		       95 8e		      sta	NewSpriteY,X
   1575  20d9		       ca		      dex
   1576  20da		       10 f6		      bpl	AdjustYValuesUpLoop
   1577  20dc
   1578  20dc
   1579  20dc		       a6 cd		      ldx	temp3	; first sprite displayed
   1580  20de
   1581  20de		       b5 9d		      lda	SpriteGfxIndex,x
   1582  20e0		       a8		      tay
   1583  20e1		       b9 8e 00 	      lda	NewSpriteY,y
   1584  20e4		       85 ce		      sta	RepoLine
   1585  20e6
   1586  20e6		       b5 9c		      lda	SpriteGfxIndex-1,x
   1587  20e8		       a8		      tay
   1588  20e9		       b9 8e 00 	      lda	NewSpriteY,y
   1589  20ec		       85 d0		      sta	temp6
   1590  20ee
   1591  20ee		       86 83		      stx	SpriteIndex
   1592  20f0
   1593  20f0
   1594  20f0
   1595  20f0		       a9 ff		      lda	#255
   1596  20f2		       85 a5		      sta	P1Bottom
   1597  20f4
   1598  20f4		       a5 8d		      lda	player0y
   1599  20f6				  -	      ifconst	screenheight
   1600  20f6				  -	      cmp	#screenheight+1
   1601  20f6					      else
   1602  20f6		       c9 59		      cmp	#$59
   1603  20f8					      endif
   1604  20f8		       90 04		      bcc	nottoohigh
   1605  20fa		       a5 a4		      lda	P0Bottom
   1606  20fc		       85 cf		      sta	P0Top
   1607  20fe
   1608  20fe
   1609  20fe
   1610  20fe				   nottoohigh
   1611  20fe		       60		      rts
   1612  20ff
   1613  20ff							;-------------------------------------------------------------------------
   1614  20ff
   1615  20ff
   1616  20ff
   1617  20ff
   1618  20ff
   1619  20ff							;*************************************************************************
   1620  20ff
   1621  20ff							;-------------------------------------------------------------------------
   1622  20ff							;-------------------------Data Below--------------------------------------
   1623  20ff							;-------------------------------------------------------------------------
   1624  20ff
   1625  20ff				   MaskTable
   1626  20ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
   1627  2104
   1628  2104							; shove 6-digit score routine here
   1629  2104
   1630  2104				   sixdigscore
   1631  2104		       a9 00		      lda	#0
   1632  2106							;	sta COLUBK
   1633  2106		       85 0d		      sta	PF0
   1634  2108		       85 0e		      sta	PF1
   1635  210a		       85 0f		      sta	PF2
   1636  210c		       85 1f		      sta	ENABL
   1637  210e		       85 1d		      sta	ENAM0
   1638  2110		       85 1e		      sta	ENAM1
   1639  2112							;end of kernel here
   1640  2112
   1641  2112
   1642  2112							; 6 digit score routine
   1643  2112							; lda #0
   1644  2112							; sta PF1
   1645  2112							; sta PF2
   1646  2112							; tax
   1647  2112
   1648  2112		       85 02		      sta	WSYNC	;,x
   1649  2114
   1650  2114							;		  STA WSYNC ;first one, need one more
   1651  2114		       85 0b		      sta	REFP0
   1652  2116		       85 0c		      sta	REFP1
   1653  2118		       85 1b		      STA	GRP0
   1654  211a		       85 1c		      STA	GRP1
   1655  211c		       85 2b		      sta	HMCLR
   1656  211e
   1657  211e							; restore P0pointer
   1658  211e
   1659  211e		       a5 a2		      lda	player0pointer
   1660  2120		       18		      clc
   1661  2121		       65 8d		      adc	player0y
   1662  2123		       38		      sec
   1663  2124		       e5 b0		      sbc	player0height
   1664  2126		       85 a2		      sta	player0pointer
   1665  2128		       e6 8d		      inc	player0y
   1666  212a
   1667  212a				  -	      ifconst	vblank_time
   1668  212a				  -	      ifconst	screenheight
   1669  212a				  -	      if	screenheight == 84
   1670  212a				  -	      lda	#vblank_time+9+128+10
   1671  212a				  -	      else
   1672  212a				  -	      lda	#vblank_time+9+128+19
   1673  212a				  -	      endif
   1674  212a				  -	      else
   1675  212a				  -	      lda	#vblank_time+9+128
   1676  212a				  -	      endif
   1677  212a					      else
   1678  212a				  -	      ifconst	screenheight
   1679  212a				  -	      if	screenheight == 84
   1680  212a				  -	      lda	#52+128+10
   1681  212a				  -	      else
   1682  212a				  -	      lda	#52+128+19
   1683  212a				  -	      endif
   1684  212a					      else
   1685  212a		       a9 b4		      lda	#52+128
   1686  212c					      endif
   1687  212c					      endif
   1688  212c
   1689  212c		       8d 96 02 	      sta	TIM64T
   1690  212f				  -	      ifconst	minikernel
   1691  212f				  -	      jsr	minikernel
   1692  212f					      endif
   1693  212f				  -	      ifconst	noscore
   1694  212f				  -	      pla
   1695  212f				  -	      pla
   1696  212f				  -	      jmp	skipscore
   1697  212f					      endif
   1698  212f
   1699  212f							; score pointers contain:
   1700  212f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1701  212f							; swap lo2->temp1
   1702  212f							; swap lo4->temp3
   1703  212f							; swap lo6->temp5
   1704  212f
   1705  212f		       a5 ca		      lda	scorepointers+5
   1706  2131		       85 cf		      sta	temp5
   1707  2133		       a5 c6		      lda	scorepointers+1
   1708  2135		       85 cb		      sta	temp1
   1709  2137		       a5 c8		      lda	scorepointers+3
   1710  2139		       85 cd		      sta	temp3
   1711  213b
   1712  213b		       a9 ff		      lda	#>scoretable
   1713  213d		       85 c6		      sta	scorepointers+1
   1714  213f		       85 c8		      sta	scorepointers+3
   1715  2141		       85 ca		      sta	scorepointers+5
   1716  2143		       85 cc		      sta	temp2
   1717  2145		       85 ce		      sta	temp4
   1718  2147		       85 d0		      sta	temp6
   1719  2149
   1720  2149		       60		      rts
   1721  214a
   1722  214a
   1723  214a
   1724  214a							;-------------------------------------------------------------------------
   1725  214a							;----------------------Kernel Routine-------------------------------------
   1726  214a							;-------------------------------------------------------------------------
   1727  214a
   1728  214a
   1729  214a							;-------------------------------------------------------------------------
   1730  214a							; repeat $f147-*
   1731  214a							; brk
   1732  214a							; repend
   1733  214a							;	org $F240
   1734  214a
   1735  214a				   SwitchDrawP0K1		;	72
   1736  214a		       a5 a4		      lda	P0Bottom
   1737  214c		       85 cf		      sta	P0Top	;+6	 2
   1738  214e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1739  2151
   1740  2151				   WaitDrawP0K1 		;	74
      0  2151					      SLEEP	4	;+4	 2
      1  2151				   .CYCLES    SET	4
      2  2151
      3  2151				  -	      IF	.CYCLES < 2
      4  2151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2151				  -	      ERR
      6  2151					      ENDIF
      7  2151
      8  2151				  -	      IF	.CYCLES & 1
      9  2151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2151				  -	      nop	0
     11  2151				  -	      ELSE
     12  2151				  -	      bit	VSYNC
     13  2151				  -	      ENDIF
     14  2151				  -.CYCLES    SET	.CYCLES - 3
     15  2151					      ENDIF
     16  2151
     17  2151					      REPEAT	.CYCLES / 2
     18  2151		       ea		      nop
     17  2151					      REPEND
     18  2152		       ea		      nop
     19  2153					      REPEND
   1742  2153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1743  2156
   1744  2156				   SkipDrawP1K1 		;	11
   1745  2156		       a9 00		      lda	#0
   1746  2158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
   1747  215a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
   1748  215d
   1749  215d							;-------------------------------------------------------------------------
   1750  215d
   1751  215d				   KernelRoutine
   1752  215d					      ifnconst	screenheight
      0  215d					      sleep	12
      1  215d				   .CYCLES    SET	12
      2  215d
      3  215d				  -	      IF	.CYCLES < 2
      4  215d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215d				  -	      ERR
      6  215d					      ENDIF
      7  215d
      8  215d				  -	      IF	.CYCLES & 1
      9  215d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215d				  -	      nop	0
     11  215d				  -	      ELSE
     12  215d				  -	      bit	VSYNC
     13  215d				  -	      ENDIF
     14  215d				  -.CYCLES    SET	.CYCLES - 3
     15  215d					      ENDIF
     16  215d
     17  215d					      REPEAT	.CYCLES / 2
     18  215d		       ea		      nop
     17  215d					      REPEND
     18  215e		       ea		      nop
     17  215e					      REPEND
     18  215f		       ea		      nop
     17  215f					      REPEND
     18  2160		       ea		      nop
     17  2160					      REPEND
     18  2161		       ea		      nop
     17  2161					      REPEND
     18  2162		       ea		      nop
     19  2163					      REPEND
   1754  2163							; jsr wastetime ; waste 12 cycles
   1755  2163				  -	      else
   1756  2163				  -	      sleep	6
   1757  2163					      endif
   1758  2163		       ba		      tsx
   1759  2164		       86 f6		      stx	stack1
   1760  2166		       a2 1f		      ldx	#ENABL
   1761  2168		       9a		      txs		;+9	 9
   1762  2169
   1763  2169		       a2 00		      ldx	#0
   1764  216b		       a5 c4		      lda	pfheight
   1765  216d		       10 01		      bpl	asdhj
   1766  216f		       24		      .byte.b	$24
   1767  2170				   asdhj
   1768  2170		       aa		      tax
   1769  2171
   1770  2171							; ldx pfheight
   1771  2171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
   1772  2174
   1773  2174				  -	      ifconst	screenheight
   1774  2174				  -	      sec
   1775  2174				  -	      if	screenheight == 84
   1776  2174				  -	      sbc	pfsub+1,x
   1777  2174				  -	      else
   1778  2174				  -	      sbc	pfsub,x
   1779  2174				  -	      endif
   1780  2174					      endif
   1781  2174
   1782  2174		       85 ba		      sta	pfpixelheight
   1783  2176
   1784  2176				  -	      ifconst	screenheight
   1785  2176				  -	      ldy	#screenheight
   1786  2176					      else
   1787  2176		       a0 58		      ldy	#88
   1788  2178					      endif
   1789  2178
   1790  2178							;	lda #$02
   1791  2178							;	sta COLUBK		;+5	18
   1792  2178
   1793  2178							; sleep 25
      0  2178					      sleep	2
      1  2178				   .CYCLES    SET	2
      2  2178
      3  2178				  -	      IF	.CYCLES < 2
      4  2178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2178				  -	      ERR
      6  2178					      ENDIF
      7  2178
      8  2178				  -	      IF	.CYCLES & 1
      9  2178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2178				  -	      nop	0
     11  2178				  -	      ELSE
     12  2178				  -	      bit	VSYNC
     13  2178				  -	      ENDIF
     14  2178				  -.CYCLES    SET	.CYCLES - 3
     15  2178					      ENDIF
     16  2178
     17  2178					      REPEAT	.CYCLES / 2
     18  2178		       ea		      nop
     19  2179					      REPEND
   1795  2179				   KernelLoopa		;	50
      0  2179					      SLEEP	7	;+4	54
      1  2179				   .CYCLES    SET	7
      2  2179
      3  2179				  -	      IF	.CYCLES < 2
      4  2179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2179				  -	      ERR
      6  2179					      ENDIF
      7  2179
      8  2179					      IF	.CYCLES & 1
      9  2179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2179		       04 00		      nop	0
     11  217b				  -	      ELSE
     12  217b				  -	      bit	VSYNC
     13  217b					      ENDIF
     14  217b				   .CYCLES    SET	.CYCLES - 3
     15  217b					      ENDIF
     16  217b
     17  217b					      REPEAT	.CYCLES / 2
     18  217b		       ea		      nop
     17  217b					      REPEND
     18  217c		       ea		      nop
     19  217d					      REPEND
   1797  217d				   KernelLoopb		;	54
      0  217d					      SLEEP	2	;+12	66
      1  217d				   .CYCLES    SET	2
      2  217d
      3  217d				  -	      IF	.CYCLES < 2
      4  217d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217d				  -	      ERR
      6  217d					      ENDIF
      7  217d
      8  217d				  -	      IF	.CYCLES & 1
      9  217d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217d				  -	      nop	0
     11  217d				  -	      ELSE
     12  217d				  -	      bit	VSYNC
     13  217d				  -	      ENDIF
     14  217d				  -.CYCLES    SET	.CYCLES - 3
     15  217d					      ENDIF
     16  217d
     17  217d					      REPEAT	.CYCLES / 2
     18  217d		       ea		      nop
     19  217e					      REPEND
   1799  217e		       c4 cf		      cpy	P0Top	;+3	69
   1800  2180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
   1801  2182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
   1802  2184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
   1803  2186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
   1804  2188				   BackFromSwitchDrawP0K1
   1805  2188
   1806  2188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
   1807  218a							;		to a value greater than maximum Y value initially
   1808  218a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
   1809  218c		       b1 cc		      lda	(P1display),Y	;+5	15
   1810  218e		       8d 1c 00 	      sta.w	GRP1	;+4	19
   1811  2191				   BackFromSkipDrawP1
   1812  2191
   1813  2191							;fuck	
   1814  2191		       84 cb		      sty	temp1
   1815  2193		       a4 ba		      ldy	pfpixelheight
   1816  2195		       b3 bb		      lax	(PF1pointer),y
   1817  2197		       86 0e		      stx	PF1	;+7	26
   1818  2199		       b1 bd		      lda	(PF2pointer),y
   1819  219b		       85 0f		      sta	PF2	;+7	33
   1820  219d							;sleep 6
   1821  219d		       86 b7		      stx	PF1temp2
   1822  219f		       85 b9		      sta	PF2temp2
   1823  21a1		       88		      dey
   1824  21a2		       30 35		      bmi	pagewraphandler
   1825  21a4		       b1 bb		      lda	(PF1pointer),y
   1826  21a6				   cyclebalance
   1827  21a6		       85 b6		      sta	PF1temp1
   1828  21a8		       b1 bd		      lda	(PF2pointer),y
   1829  21aa		       85 b8		      sta	PF2temp1
   1830  21ac		       a4 cb		      ldy	temp1
   1831  21ae
   1832  21ae		       a2 1f		      ldx	#ENABL
   1833  21b0		       9a		      txs
   1834  21b1		       c4 8c		      cpy	bally
   1835  21b3		       08		      php		;+6	39	VDEL ball
   1836  21b4
   1837  21b4
   1838  21b4		       c4 8b		      cpy	missile1y
   1839  21b6		       08		      php		;+6	71
   1840  21b7
   1841  21b7		       c4 8a		      cpy	missile0y
   1842  21b9		       08		      php		;+6	 1
   1843  21ba
   1844  21ba
   1845  21ba		       88		      dey		;+2	15
   1846  21bb
   1847  21bb		       c4 ce		      cpy	RepoLine	;+3	18
   1848  21bd		       f0 62		      beq	RepoKernel	;+2	20
   1849  21bf							;	SLEEP 20		;+23	43
      0  21bf					      sleep	6
      1  21bf				   .CYCLES    SET	6
      2  21bf
      3  21bf				  -	      IF	.CYCLES < 2
      4  21bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21bf				  -	      ERR
      6  21bf					      ENDIF
      7  21bf
      8  21bf				  -	      IF	.CYCLES & 1
      9  21bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21bf				  -	      nop	0
     11  21bf				  -	      ELSE
     12  21bf				  -	      bit	VSYNC
     13  21bf				  -	      ENDIF
     14  21bf				  -.CYCLES    SET	.CYCLES - 3
     15  21bf					      ENDIF
     16  21bf
     17  21bf					      REPEAT	.CYCLES / 2
     18  21bf		       ea		      nop
     17  21bf					      REPEND
     18  21c0		       ea		      nop
     17  21c0					      REPEND
     18  21c1		       ea		      nop
     19  21c2					      REPEND
   1851  21c2
   1852  21c2				   newrepo		; since we have time here, store next repoline
   1853  21c2		       a6 83		      ldx	SpriteIndex
   1854  21c4		       b5 9c		      lda	SpriteGfxIndex-1,x
   1855  21c6		       aa		      tax
   1856  21c7		       b5 8e		      lda	NewSpriteY,x
   1857  21c9		       85 d0		      sta	temp6
      0  21cb					      sleep	4
      1  21cb				   .CYCLES    SET	4
      2  21cb
      3  21cb				  -	      IF	.CYCLES < 2
      4  21cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21cb				  -	      ERR
      6  21cb					      ENDIF
      7  21cb
      8  21cb				  -	      IF	.CYCLES & 1
      9  21cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21cb				  -	      nop	0
     11  21cb				  -	      ELSE
     12  21cb				  -	      bit	VSYNC
     13  21cb				  -	      ENDIF
     14  21cb				  -.CYCLES    SET	.CYCLES - 3
     15  21cb					      ENDIF
     16  21cb
     17  21cb					      REPEAT	.CYCLES / 2
     18  21cb		       ea		      nop
     17  21cb					      REPEND
     18  21cc		       ea		      nop
     19  21cd					      REPEND
   1859  21cd
   1860  21cd				   BackFromRepoKernel
   1861  21cd		       98		      tya		;+2	45
   1862  21ce		       25 c4		      and	pfheight	;+2	47
   1863  21d0		       d0 a7		      bne	KernelLoopa	;+2	49
   1864  21d2		       c6 ba		      dec	pfpixelheight
   1865  21d4		       10 a7		      bpl	KernelLoopb	;+3	54
   1866  21d6							;	bmi donewkernel		;+3	54
   1867  21d6							;	bne KernelLoopb+1		;+3	54
   1868  21d6
   1869  21d6				   donewkernel
   1870  21d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
   1871  21d9
   1872  21d9				   pagewraphandler
   1873  21d9		       4c a6 f1 	      jmp	cyclebalance
   1874  21dc
   1875  21dc							;-------------------------------------------------------------------------
   1876  21dc
   1877  21dc							; room here for score?
   1878  21dc
   1879  21dc				   setscorepointers
   1880  21dc		       a7 d4		      lax	score+2
   1881  21de		       20 f8 f1 	      jsr	scorepointerset
   1882  21e1		       84 ca		      sty	scorepointers+5
   1883  21e3		       86 c7		      stx	scorepointers+2
   1884  21e5		       a7 d3		      lax	score+1
   1885  21e7		       20 f8 f1 	      jsr	scorepointerset
   1886  21ea		       84 c9		      sty	scorepointers+4
   1887  21ec		       86 c6		      stx	scorepointers+1
   1888  21ee		       a7 d2		      lax	score
   1889  21f0		       20 f8 f1 	      jsr	scorepointerset
   1890  21f3		       84 c8		      sty	scorepointers+3
   1891  21f5		       86 c5		      stx	scorepointers
   1892  21f7				   wastetime
   1893  21f7		       60		      rts
   1894  21f8
   1895  21f8				   scorepointerset
   1896  21f8		       29 0f		      and	#$0F
   1897  21fa		       0a		      asl
   1898  21fb		       0a		      asl
   1899  21fc		       0a		      asl
   1900  21fd		       69 74		      adc	#<scoretable
   1901  21ff		       a8		      tay
   1902  2200		       8a		      txa
   1903  2201		       29 f0		      and	#$F0
   1904  2203		       4a		      lsr
   1905  2204		       69 74		      adc	#<scoretable
   1906  2206		       aa		      tax
   1907  2207		       60		      rts
   1908  2208							;	align 256
   1909  2208
   1910  2208				   SwitchDrawP0KR		;	45
   1911  2208		       a5 a4		      lda	P0Bottom
   1912  220a		       85 cf		      sta	P0Top	;+6	51
   1913  220c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1914  220f
   1915  220f				   WaitDrawP0KR 		;	47
      0  220f					      SLEEP	4	;+4	51
      1  220f				   .CYCLES    SET	4
      2  220f
      3  220f				  -	      IF	.CYCLES < 2
      4  220f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  220f				  -	      ERR
      6  220f					      ENDIF
      7  220f
      8  220f				  -	      IF	.CYCLES & 1
      9  220f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  220f				  -	      nop	0
     11  220f				  -	      ELSE
     12  220f				  -	      bit	VSYNC
     13  220f				  -	      ENDIF
     14  220f				  -.CYCLES    SET	.CYCLES - 3
     15  220f					      ENDIF
     16  220f
     17  220f					      REPEAT	.CYCLES / 2
     18  220f		       ea		      nop
     17  220f					      REPEND
     18  2210		       ea		      nop
     19  2211					      REPEND
   1917  2211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1918  2214
   1919  2214							;-----------------------------------------------------------
   1920  2214
   1921  2214				   noUpdateXKR
   1922  2214		       a2 01		      ldx	#1
   1923  2216		       cc cf 00 	      cpy.w	P0Top
   1924  2219		       4c 2b f2 	      JMP	retXKR
   1925  221c
   1926  221c				   skipthis
   1927  221c		       a2 01		      ldx	#1
   1928  221e		       4c 6d f2 	      jmp	goback
   1929  2221
   1930  2221				   RepoKernel		;	22	crosses page boundary
   1931  2221		       98		      tya
   1932  2222		       25 c4		      and	pfheight	;+2	26
   1933  2224		       d0 ee		      bne	noUpdateXKR	;+2	28
   1934  2226		       aa		      tax
   1935  2227							;	dex			;+2	30
   1936  2227		       c6 ba		      dec	pfpixelheight
   1937  2229							;	stx Temp		;+3	35
   1938  2229							;	SLEEP 3
   1939  2229
   1940  2229		       c4 cf		      cpy	P0Top	;+3	42
   1941  222b				   retXKR
   1942  222b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
   1943  222d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
   1944  222f		       b1 a2		      lda	(player0pointer),Y	;+5	51
   1945  2231		       85 1b		      sta	GRP0	;+3	54	VDEL
   1946  2233				   BackFromSwitchDrawP0KR
   1947  2233		       38		      sec		;+2	56
   1948  2234
   1949  2234
   1950  2234
   1951  2234		       b5 b8		      lda	PF2temp1,X
   1952  2236		       b4 b6		      ldy	PF1temp1,X
   1953  2238
   1954  2238		       a6 83		      ldx	SpriteIndex	;+3	 2
   1955  223a
   1956  223a		       85 0f		      sta	PF2	;+7	63
   1957  223c
   1958  223c		       b5 9d		      lda	SpriteGfxIndex,x
   1959  223e		       84 0e		      sty	PF1	;+7	70	too early?
   1960  2240		       aa		      tax
   1961  2241		       a9 00		      lda	#0
   1962  2243		       85 1c		      sta	GRP1	;+5	75	to display player 0
   1963  2245		       b5 85		      lda	NewSpriteX,X	;+4	 6
   1964  2247
   1965  2247				   DivideBy15LoopK		;	 6	(carry set above)
   1966  2247		       e9 0f		      sbc	#15
   1967  2249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
   1968  224b
   1969  224b		       aa		      tax		;+2	12/17/...62
   1970  224c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
   1971  224f
   1972  224f		       85 21		      sta	HMP1	;+3	20/25/...70
   1973  2251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
   1974  2253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1975  2255							;sta HMOVE			;+3	 3
   1976  2255
   1977  2255		       a2 1f		      ldx	#ENABL
   1978  2257		       9a		      txs		;+4	25
   1979  2258		       a4 ce		      ldy	RepoLine	; restore y
   1980  225a		       c4 8c		      cpy	bally
   1981  225c		       08		      php		;+6	 9	VDEL ball
   1982  225d
   1983  225d		       c4 8b		      cpy	missile1y
   1984  225f		       08		      php		;+6	15
   1985  2260
   1986  2260		       c4 8a		      cpy	missile0y
   1987  2262		       08		      php		;+6	21
   1988  2263
   1989  2263
   1990  2263
   1991  2263
   1992  2263
   1993  2263							;15 cycles
   1994  2263		       98		      tya
   1995  2264		       25 c4		      and	pfheight
   1996  2266							;eor #1
   1997  2266		       29 fe		      and	#$FE
   1998  2268		       d0 b2		      bne	skipthis
   1999  226a		       aa		      tax
      0  226b					      sleep	4
      1  226b				   .CYCLES    SET	4
      2  226b
      3  226b				  -	      IF	.CYCLES < 2
      4  226b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  226b				  -	      ERR
      6  226b					      ENDIF
      7  226b
      8  226b				  -	      IF	.CYCLES & 1
      9  226b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  226b				  -	      nop	0
     11  226b				  -	      ELSE
     12  226b				  -	      bit	VSYNC
     13  226b				  -	      ENDIF
     14  226b				  -.CYCLES    SET	.CYCLES - 3
     15  226b					      ENDIF
     16  226b
     17  226b					      REPEAT	.CYCLES / 2
     18  226b		       ea		      nop
     17  226b					      REPEND
     18  226c		       ea		      nop
     19  226d					      REPEND
   2001  226d							;	sleep 2
   2002  226d				   goback
   2003  226d
   2004  226d		       88		      dey
   2005  226e		       c4 cf		      cpy	P0Top	;+3	52
   2006  2270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
   2007  2272		       10 67		      bpl	WaitDrawP0KV	;+2	56
   2008  2274		       b1 a2		      lda	(player0pointer),Y	;+5	61
   2009  2276		       85 1b		      sta	GRP0	;+3	64	VDEL
   2010  2278				   BackFromSwitchDrawP0KV
   2011  2278
   2012  2278							; sleep 3
   2013  2278
   2014  2278		       b5 b8		      lda	PF2temp1,X
   2015  227a		       85 0f		      sta	PF2	;+7	 5
   2016  227c		       b5 b6		      lda	PF1temp1,X
   2017  227e		       85 0e		      sta	PF1	;+7	74 
   2018  2280		       85 2a		      sta	HMOVE
   2019  2282
   2020  2282		       a9 00		      lda	#0
   2021  2284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
   2022  2286
   2023  2286		       a2 1f		      ldx	#ENABL
   2024  2288		       9a		      txs		;+4	 8
   2025  2289
   2026  2289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
   2027  228b							;--now, set all new variables and return to main kernel loop
   2028  228b
   2029  228b
   2030  228b							;
   2031  228b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
   2032  228d		       aa		      tax		;+2	33
   2033  228e							;
   2034  228e
   2035  228e
   2036  228e
   2037  228e		       b5 93		      lda	NewNUSIZ,X
   2038  2290		       85 05		      sta	NUSIZ1	;+7	20
   2039  2292		       85 0c		      sta	REFP1
   2040  2294		       b5 98		      lda	NewCOLUP1,X
   2041  2296		       85 07		      sta	COLUP1	;+7	27
   2042  2298
   2043  2298							;	lda SpriteGfxIndex,X	;+4	31
   2044  2298							;	tax				;+2	33
   2045  2298							;fuck2
   2046  2298		       b5 8e		      lda	NewSpriteY,X	;+4	46
   2047  229a		       38		      sec		;+2	38
   2048  229b		       f5 b1		      sbc	spriteheight,X	;+4	42
   2049  229d		       85 a5		      sta	P1Bottom	;+3	45
   2050  229f
      0  229f					      sleep	6
      1  229f				   .CYCLES    SET	6
      2  229f
      3  229f				  -	      IF	.CYCLES < 2
      4  229f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  229f				  -	      ERR
      6  229f					      ENDIF
      7  229f
      8  229f				  -	      IF	.CYCLES & 1
      9  229f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  229f				  -	      nop	0
     11  229f				  -	      ELSE
     12  229f				  -	      bit	VSYNC
     13  229f				  -	      ENDIF
     14  229f				  -.CYCLES    SET	.CYCLES - 3
     15  229f					      ENDIF
     16  229f
     17  229f					      REPEAT	.CYCLES / 2
     18  229f		       ea		      nop
     17  229f					      REPEND
     18  22a0		       ea		      nop
     17  22a0					      REPEND
     18  22a1		       ea		      nop
     19  22a2					      REPEND
   2052  22a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
   2053  22a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
   2054  22a6		       85 cc		      sta	P1display	;+3	55
   2055  22a8		       b5 ab		      lda	player1pointerhi,X
   2056  22aa		       85 cd		      sta	P1display+1	;+7	62
   2057  22ac
   2058  22ac
   2059  22ac		       c4 8c		      cpy	bally
   2060  22ae		       08		      php		;+6	68	VDELed
   2061  22af
   2062  22af		       c4 8b		      cpy	missile1y
   2063  22b1		       08		      php		;+6	74
   2064  22b2
   2065  22b2		       c4 8a		      cpy	missile0y
   2066  22b4		       08		      php		;+6	 4
   2067  22b5
   2068  22b5
   2069  22b5
   2070  22b5							; lda SpriteGfxIndex-1,x
   2071  22b5							; sleep 3
   2072  22b5		       c6 83		      dec	SpriteIndex	;+5	13
   2073  22b7							; tax
   2074  22b7							; lda NewSpriteY,x
   2075  22b7							; sta RepoLine
   2076  22b7
   2077  22b7							; 10 cycles below...
   2078  22b7		       10 05		      bpl	SetNextLine
   2079  22b9		       a9 ff		      lda	#255
   2080  22bb		       4c c1 f2 	      jmp	SetLastLine
   2081  22be				   SetNextLine
   2082  22be							;	lda NewSpriteY-1,x
   2083  22be		       ad d0 00 	      lda.w	temp6
   2084  22c1				   SetLastLine
   2085  22c1		       85 ce		      sta	RepoLine
   2086  22c3
   2087  22c3		       98		      tya
   2088  22c4		       25 c4		      and	pfheight
   2089  22c6		       d0 06		      bne	nodec
   2090  22c8		       c6 ba		      dec	pfpixelheight
   2091  22ca		       88		      dey		;+2	30
   2092  22cb
   2093  22cb							; 10 cycles 
   2094  22cb
   2095  22cb
   2096  22cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
   2097  22ce
   2098  22ce				   nodec
      0  22ce					      sleep	4
      1  22ce				   .CYCLES    SET	4
      2  22ce
      3  22ce				  -	      IF	.CYCLES < 2
      4  22ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22ce				  -	      ERR
      6  22ce					      ENDIF
      7  22ce
      8  22ce				  -	      IF	.CYCLES & 1
      9  22ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22ce				  -	      nop	0
     11  22ce				  -	      ELSE
     12  22ce				  -	      bit	VSYNC
     13  22ce				  -	      ENDIF
     14  22ce				  -.CYCLES    SET	.CYCLES - 3
     15  22ce					      ENDIF
     16  22ce
     17  22ce					      REPEAT	.CYCLES / 2
     18  22ce		       ea		      nop
     17  22ce					      REPEND
     18  22cf		       ea		      nop
     19  22d0					      REPEND
   2100  22d0		       88		      dey
   2101  22d1		       4c cd f1 	      jmp	BackFromRepoKernel
   2102  22d4
   2103  22d4							;-------------------------------------------------------------------------
   2104  22d4
   2105  22d4
   2106  22d4				   SwitchDrawP0KV		;	69
   2107  22d4		       a5 a4		      lda	P0Bottom
   2108  22d6		       85 cf		      sta	P0Top	;+6	75
   2109  22d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2110  22db
   2111  22db				   WaitDrawP0KV 		;	71
      0  22db					      SLEEP	4	;+4	75
      1  22db				   .CYCLES    SET	4
      2  22db
      3  22db				  -	      IF	.CYCLES < 2
      4  22db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22db				  -	      ERR
      6  22db					      ENDIF
      7  22db
      8  22db				  -	      IF	.CYCLES & 1
      9  22db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22db				  -	      nop	0
     11  22db				  -	      ELSE
     12  22db				  -	      bit	VSYNC
     13  22db				  -	      ENDIF
     14  22db				  -.CYCLES    SET	.CYCLES - 3
     15  22db					      ENDIF
     16  22db
     17  22db					      REPEAT	.CYCLES / 2
     18  22db		       ea		      nop
     17  22db					      REPEND
     18  22dc		       ea		      nop
     19  22dd					      REPEND
   2113  22dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2114  22e0
   2115  22e0							;-------------------------------------------------------------------------
   2116  22e0
   2117  22e0				   DoneWithKernel
   2118  22e0
   2119  22e0				   BottomOfKernelLoop
   2120  22e0
   2121  22e0		       85 02		      sta	WSYNC
   2122  22e2		       a6 f6		      ldx	stack1
   2123  22e4		       9a		      txs
   2124  22e5		       20 04 f1 	      jsr	sixdigscore	; set up score
   2125  22e8
   2126  22e8
   2127  22e8		       85 02		      sta	WSYNC
   2128  22ea		       a2 00		      ldx	#0
   2129  22ec		       85 2b		      sta	HMCLR
   2130  22ee		       86 1b		      STx	GRP0
   2131  22f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2132  22f2
   2133  22f2		       a0 07		      LDY	#7
   2134  22f4		       84 25		      STy	VDELP0
   2135  22f6		       84 26		      STy	VDELP1
   2136  22f8		       a9 10		      LDA	#$10
   2137  22fa		       85 21		      STA	HMP1
   2138  22fc		       a5 d5		      LDA	scorecolor
   2139  22fe		       85 06		      STA	COLUP0
   2140  2300		       85 07		      STA	COLUP1
   2141  2302
   2142  2302		       a9 03		      LDA	#$03
   2143  2304		       85 04		      STA	NUSIZ0
   2144  2306		       85 05		      STA	NUSIZ1
   2145  2308
   2146  2308		       85 10		      STA	RESP0
   2147  230a		       85 11		      STA	RESP1
   2148  230c
      0  230c					      sleep	9
      1  230c				   .CYCLES    SET	9
      2  230c
      3  230c				  -	      IF	.CYCLES < 2
      4  230c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  230c				  -	      ERR
      6  230c					      ENDIF
      7  230c
      8  230c					      IF	.CYCLES & 1
      9  230c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  230c		       04 00		      nop	0
     11  230e				  -	      ELSE
     12  230e				  -	      bit	VSYNC
     13  230e					      ENDIF
     14  230e				   .CYCLES    SET	.CYCLES - 3
     15  230e					      ENDIF
     16  230e
     17  230e					      REPEAT	.CYCLES / 2
     18  230e		       ea		      nop
     17  230e					      REPEND
     18  230f		       ea		      nop
     17  230f					      REPEND
     18  2310		       ea		      nop
     19  2311					      REPEND
   2150  2311		       b1 c5		      lda	(scorepointers),y
   2151  2313		       85 1b		      sta	GRP0
   2152  2315					      ifconst	pfscore
   2153  2315		       a5 c0		      lda	pfscorecolor
   2154  2317		       85 08		      sta	COLUPF
   2155  2319				  -	      else
   2156  2319				  -	      sleep	6
   2157  2319					      endif
   2158  2319
   2159  2319		       85 2a		      STA	HMOVE
   2160  231b		       b1 cd		      lda	(scorepointers+8),y
   2161  231d							; sta WSYNC
   2162  231d							;sleep 2
   2163  231d		       4c 2b f3 	      jmp	beginscore
   2164  2320
   2165  2320
   2166  2320				   loop2
   2167  2320		       b1 c5		      lda	(scorepointers),y	;+5  68  204
   2168  2322		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
   2169  2324					      ifconst	pfscore
   2170  2324		       ad c1 00 	      lda.w	pfscore1
   2171  2327		       85 0e		      sta	PF1
   2172  2329				  -	      else
   2173  2329				  -	      sleep	7
   2174  2329					      endif
   2175  2329							; cycle 0
   2176  2329		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
   2177  232b				   beginscore
   2178  232b		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
   2179  232d		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
   2180  232f		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
   2181  2331		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
   2182  2333		       9a		      txs
   2183  2334		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  2336					      sleep	3
      1  2336				   .CYCLES    SET	3
      2  2336
      3  2336				  -	      IF	.CYCLES < 2
      4  2336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2336				  -	      ERR
      6  2336					      ENDIF
      7  2336
      8  2336					      IF	.CYCLES & 1
      9  2336					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2336		       04 00		      nop	0
     11  2338				  -	      ELSE
     12  2338				  -	      bit	VSYNC
     13  2338					      ENDIF
     14  2338				   .CYCLES    SET	.CYCLES - 3
     15  2338					      ENDIF
     16  2338
     17  2338				  -	      REPEAT	.CYCLES / 2
     18  2338				  -	      nop
     19  2338					      REPEND
   2185  2338					      ifconst	pfscore
   2186  2338		       a5 c2		      lda	pfscore2
   2187  233a		       85 0e		      sta	PF1
   2188  233c				  -	      else
   2189  233c				  -	      sleep	6
   2190  233c					      endif
   2191  233c		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
   2192  233e		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
   2193  2340		       ba		      tsx
   2194  2341		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
   2195  2343		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
   2196  2345		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
   2197  2347		       88		      dey
   2198  2348		       10 d6		      bpl	loop2	;+2  60  180
   2199  234a		       a6 f6		      ldx	stack1
   2200  234c		       9a		      txs
   2201  234d
   2202  234d
   2203  234d							; lda scorepointers+1
   2204  234d		       a4 cb		      ldy	temp1
   2205  234f							; sta temp1
   2206  234f		       84 c6		      sty	scorepointers+1
   2207  2351
   2208  2351		       a9 00		      LDA	#0
   2209  2353		       85 1b		      STA	GRP0
   2210  2355		       85 1c		      STA	GRP1
   2211  2357		       85 0e		      sta	PF1
   2212  2359		       85 25		      STA	VDELP0
   2213  235b		       85 26		      STA	VDELP1	;do we need these
   2214  235d		       85 04		      STA	NUSIZ0
   2215  235f		       85 05		      STA	NUSIZ1
   2216  2361
   2217  2361							; lda scorepointers+3
   2218  2361		       a4 cd		      ldy	temp3
   2219  2363							; sta temp3
   2220  2363		       84 c8		      sty	scorepointers+3
   2221  2365
   2222  2365							; lda scorepointers+5
   2223  2365		       a4 cf		      ldy	temp5
   2224  2367							; sta temp5
   2225  2367		       84 ca		      sty	scorepointers+5
   2226  2369
   2227  2369
   2228  2369							;-------------------------------------------------------------------------
   2229  2369							;------------------------Overscan Routine---------------------------------
   2230  2369							;-------------------------------------------------------------------------
   2231  2369
   2232  2369				   OverscanRoutine
   2233  2369
   2234  2369
   2235  2369
   2236  2369				   skipscore
   2237  2369		       a9 02		      lda	#2
   2238  236b		       85 02		      sta	WSYNC
   2239  236d		       85 01		      sta	VBLANK	;turn on VBLANK
   2240  236f
   2241  236f
   2242  236f
   2243  236f
   2244  236f
   2245  236f							;-------------------------------------------------------------------------
   2246  236f							;----------------------------End Main Routines----------------------------
   2247  236f							;-------------------------------------------------------------------------
   2248  236f
   2249  236f
   2250  236f							;*************************************************************************
   2251  236f
   2252  236f							;-------------------------------------------------------------------------
   2253  236f							;----------------------Begin Subroutines----------------------------------
   2254  236f							;-------------------------------------------------------------------------
   2255  236f
   2256  236f
   2257  236f
   2258  236f
   2259  236f				   KernelCleanupSubroutine
   2260  236f
   2261  236f		       a2 04		      ldx	#4
   2262  2371				   AdjustYValuesDownLoop
   2263  2371		       b5 8e		      lda	NewSpriteY,X
   2264  2373		       38		      sec
   2265  2374		       e9 02		      sbc	#2
   2266  2376		       95 8e		      sta	NewSpriteY,X
   2267  2378		       ca		      dex
   2268  2379		       10 f6		      bpl	AdjustYValuesDownLoop
   2269  237b
   2270  237b
      0  237b					      RETURN
      1  237b				  -	      ifnconst	bankswitch
      2  237b				  -	      rts
      3  237b					      else
      4  237b		       4c dd ff 	      jmp	BS_return
      5  237e					      endif
   2272  237e							;rts
   2273  237e
   2274  237e				   SetupP1Subroutine
   2275  237e							; flickersort algorithm
   2276  237e							; count 4-0
   2277  237e							; table2=table1 (?)
   2278  237e							; detect overlap of sprites in table 2
   2279  237e							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
   2280  237e							; if no overlap, do regular sort in table 2 and table 1
   2281  237e				   fsstart
   2282  237e		       a2 ff		      ldx	#255
   2283  2380				   copytable
   2284  2380		       e8		      inx
   2285  2381		       b5 f1		      lda	spritesort,x
   2286  2383		       95 9d		      sta	SpriteGfxIndex,x
   2287  2385		       e0 04		      cpx	#4
   2288  2387		       d0 f7		      bne	copytable
   2289  2389
   2290  2389		       86 cd		      stx	temp3	; highest displayed sprite
   2291  238b		       ca		      dex
   2292  238c		       86 cc		      stx	temp2
   2293  238e				   sortloop
   2294  238e		       a6 cc		      ldx	temp2
   2295  2390		       b5 f1		      lda	spritesort,x
   2296  2392		       aa		      tax
   2297  2393		       b5 8e		      lda	NewSpriteY,x
   2298  2395		       85 cb		      sta	temp1
   2299  2397
   2300  2397		       a6 cc		      ldx	temp2
   2301  2399		       b5 f2		      lda	spritesort+1,x
   2302  239b		       aa		      tax
   2303  239c		       b5 8e		      lda	NewSpriteY,x
   2304  239e		       38		      sec
   2305  239f		       18		      clc
   2306  23a0		       e5 cb		      sbc	temp1
   2307  23a2		       90 0e		      bcc	largerXislower
   2308  23a4
   2309  23a4							; larger x is higher (A>=temp1)
   2310  23a4		       d5 b1		      cmp	spriteheight,x
   2311  23a6		       b0 2f		      bcs	countdown
   2312  23a8							; overlap with x+1>x
   2313  23a8							; 
   2314  23a8							; stick x at end of gfxtable, dec counter
   2315  23a8				   overlapping
   2316  23a8		       c6 cd		      dec	temp3
   2317  23aa		       a6 cc		      ldx	temp2
   2318  23ac							; inx
   2319  23ac		       20 eb f3 	      jsr	shiftnumbers
   2320  23af		       4c cd f3 	      jmp	skipswapGfxtable
   2321  23b2
   2322  23b2				   largerXislower		; (temp1>A)
   2323  23b2		       a8		      tay
   2324  23b3		       a6 cc		      ldx	temp2
   2325  23b5		       b5 f1		      lda	spritesort,x
   2326  23b7		       aa		      tax
   2327  23b8		       98		      tya
   2328  23b9		       49 ff		      eor	#$FF
   2329  23bb		       e9 01		      sbc	#1
   2330  23bd		       90 e9		      bcc	overlapping
   2331  23bf		       d5 b1		      cmp	spriteheight,x
   2332  23c1		       b0 0a		      bcs	notoverlapping
   2333  23c3
   2334  23c3		       c6 cd		      dec	temp3
   2335  23c5		       a6 cc		      ldx	temp2
   2336  23c7							; inx
   2337  23c7		       20 eb f3 	      jsr	shiftnumbers
   2338  23ca		       4c cd f3 	      jmp	skipswapGfxtable
   2339  23cd				   notoverlapping
   2340  23cd							; ldx temp2 ; swap display table
   2341  23cd							; ldy SpriteGfxIndex+1,x
   2342  23cd							; lda SpriteGfxIndex,x
   2343  23cd							; sty SpriteGfxIndex,x
   2344  23cd							; sta SpriteGfxIndex+1,x 
   2345  23cd
   2346  23cd				   skipswapGfxtable
   2347  23cd		       a6 cc		      ldx	temp2	; swap sort table
   2348  23cf		       b4 f2		      ldy	spritesort+1,x
   2349  23d1		       b5 f1		      lda	spritesort,x
   2350  23d3		       94 f1		      sty	spritesort,x
   2351  23d5		       95 f2		      sta	spritesort+1,x
   2352  23d7
   2353  23d7				   countdown
   2354  23d7		       c6 cc		      dec	temp2
   2355  23d9		       10 b3		      bpl	sortloop
   2356  23db
   2357  23db				   checktoohigh
   2358  23db		       a6 cd		      ldx	temp3
   2359  23dd		       b5 9d		      lda	SpriteGfxIndex,x
   2360  23df		       aa		      tax
   2361  23e0		       b5 8e		      lda	NewSpriteY,x
   2362  23e2				  -	      ifconst	screenheight
   2363  23e2				  -	      cmp	#screenheight-3
   2364  23e2					      else
   2365  23e2		       c9 55		      cmp	#$55
   2366  23e4					      endif
   2367  23e4		       90 04		      bcc	nonetoohigh
   2368  23e6		       c6 cd		      dec	temp3
   2369  23e8		       d0 f1		      bne	checktoohigh
   2370  23ea
   2371  23ea				   nonetoohigh
   2372  23ea		       60		      rts
   2373  23eb
   2374  23eb
   2375  23eb				   shiftnumbers
   2376  23eb							; stick current x at end, shift others down
   2377  23eb							; if x=4: don't do anything
   2378  23eb							; if x=3: swap 3 and 4
   2379  23eb							; if x=2: 2=3, 3=4, 4=2
   2380  23eb							; if x=1: 1=2, 2=3, 3=4, 4=1
   2381  23eb							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   2382  23eb							; ldy SpriteGfxIndex,x
   2383  23eb				   swaploop
   2384  23eb		       e0 04		      cpx	#4
   2385  23ed		       f0 08		      beq	shiftdone
   2386  23ef		       b5 9e		      lda	SpriteGfxIndex+1,x
   2387  23f1		       95 9d		      sta	SpriteGfxIndex,x
   2388  23f3		       e8		      inx
   2389  23f4		       4c eb f3 	      jmp	swaploop
   2390  23f7				   shiftdone
   2391  23f7							; sty SpriteGfxIndex,x
   2392  23f7		       60		      rts
   2393  23f8
   2394  23f8				  -	      ifconst	debugscore
   2395  23f8				  -debugcycles
   2396  23f8				  -	      ldx	#14
   2397  23f8				  -	      lda	INTIM	; display # cycles left in the score
   2398  23f8				  -
   2399  23f8				  -	      ifconst	mincycles
   2400  23f8				  -	      lda	mincycles
   2401  23f8				  -	      cmp	INTIM
   2402  23f8				  -	      lda	mincycles
   2403  23f8				  -	      bcc	nochange
   2404  23f8				  -	      lda	INTIM
   2405  23f8				  -	      sta	mincycles
   2406  23f8				  -nochange
   2407  23f8				  -	      endif
   2408  23f8				  -
   2409  23f8				  -			;   cmp #$2B
   2410  23f8				  -			;   bcs no_cycles_left
   2411  23f8				  -	      bmi	cycles_left
   2412  23f8				  -	      ldx	#64
   2413  23f8				  -	      eor	#$ff	;make negative
   2414  23f8				  -cycles_left
   2415  23f8				  -	      stx	scorecolor
   2416  23f8				  -	      and	#$7f	; clear sign bit
   2417  23f8				  -	      tax
   2418  23f8				  -	      lda	scorebcd,x
   2419  23f8				  -	      sta	score+2
   2420  23f8				  -	      lda	scorebcd1,x
   2421  23f8				  -	      sta	score+1
   2422  23f8				  -	      rts
   2423  23f8				  -scorebcd
   2424  23f8				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2425  23f8				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2426  23f8				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2427  23f8				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2428  23f8				  -scorebcd1
   2429  23f8				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2430  23f8				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2431  23f8				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2432  23f8				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2433  23f8					      endif
   2434  23f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2435  23f8
   2436  23f8				   start
   2437  23f8		       78		      sei
   2438  23f9		       d8		      cld
   2439  23fa		       a0 00		      ldy	#0
   2440  23fc		       a5 d0		      lda	$D0
   2441  23fe		       c9 2c		      cmp	#$2C	;check RAM location #1
   2442  2400		       d0 07		      bne	MachineIs2600
   2443  2402		       a5 d1		      lda	$D1
   2444  2404		       c9 a9		      cmp	#$A9	;check RAM location #2
   2445  2406		       d0 01		      bne	MachineIs2600
   2446  2408		       88		      dey
   2447  2409				   MachineIs2600
   2448  2409		       a2 00		      ldx	#0
   2449  240b		       8a		      txa
   2450  240c				   clearmem
   2451  240c		       e8		      inx
   2452  240d		       9a		      txs
   2453  240e		       48		      pha
   2454  240f		       d0 fb		      bne	clearmem
   2455  2411		       84 cb		      sty	temp1
   2456  2413				  -	      ifnconst	multisprite
   2457  2413				  -	      ifconst	pfrowheight
   2458  2413				  -	      lda	#pfrowheight
   2459  2413				  -	      else
   2460  2413				  -	      ifconst	pfres
   2461  2413				  -	      lda	#(96/pfres)
   2462  2413				  -	      else
   2463  2413				  -	      lda	#8
   2464  2413				  -	      endif
   2465  2413				  -	      endif
   2466  2413				  -	      sta	playfieldpos
   2467  2413					      endif
   2468  2413		       a2 05		      ldx	#5
   2469  2415				   initscore
   2470  2415		       a9 74		      lda	#<scoretable
   2471  2417		       95 c5		      sta	scorepointers,x
   2472  2419		       ca		      dex
   2473  241a		       10 f9		      bpl	initscore
   2474  241c		       a9 01		      lda	#1
   2475  241e		       85 0a		      sta	CTRLPF
   2476  2420		       0d 84 02 	      ora	INTIM
   2477  2423		       85 d6		      sta	rand
   2478  2425
   2479  2425					      ifconst	multisprite
   2480  2425		       20 1f f0 	      jsr	multisprite_setup
   2481  2428					      endif
   2482  2428
   2483  2428				  -	      ifnconst	bankswitch
   2484  2428				  -	      jmp	game
   2485  2428					      else
   2486  2428		       a9 cf		      lda	#>(game-1)
   2487  242a		       48		      pha
   2488  242b		       a9 ff		      lda	#<(game-1)
   2489  242d		       48		      pha
   2490  242e		       48		      pha
   2491  242f		       48		      pha
   2492  2430		       a2 01		      ldx	#1
   2493  2432		       4c eb ff 	      jmp	BS_jsr
   2494  2435					      endif
   2495  2435							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2496  2435
   2497  2435							;standard routines needed for pretty much all games
   2498  2435							; just the random number generator is left - maybe we should remove this asm file altogether?
   2499  2435							; repositioning code and score pointer setup moved to overscan
   2500  2435							; read switches, joysticks now compiler generated (more efficient)
   2501  2435
   2502  2435				   randomize
   2503  2435		       a5 d6		      lda	rand
   2504  2437		       4a		      lsr
   2505  2438				  -	      ifconst	rand16
   2506  2438				  -	      rol	rand16
   2507  2438					      endif
   2508  2438		       90 02		      bcc	noeor
   2509  243a		       49 b4		      eor	#$B4
   2510  243c				   noeor
   2511  243c		       85 d6		      sta	rand
   2512  243e				  -	      ifconst	rand16
   2513  243e				  -	      eor	rand16
   2514  243e					      endif
      0  243e					      RETURN
      1  243e				  -	      ifnconst	bankswitch
      2  243e				  -	      rts
      3  243e					      else
      4  243e		       4c dd ff 	      jmp	BS_return
      5  2441					      endif
   2516  2441							;bB.asm
   2517  2441							; bB.asm file is split here
   2518  2441				  -	      if	(<*) > (<(*+8))
   2519  2441				  -	      repeat	($100-<*)
   2520  2441				  -	      .byte	0
   2521  2441				  -	      repend
   2522  2441					      endif
   2523  2441					      if	(<*) < 90
   2524  2441					      repeat	(90-<*)
   2525  2441		       00		      .byte.b	0
   2524  2441					      repend
   2525  2442		       00		      .byte.b	0
   2524  2442					      repend
   2525  2443		       00		      .byte.b	0
   2524  2443					      repend
   2525  2444		       00		      .byte.b	0
   2524  2444					      repend
   2525  2445		       00		      .byte.b	0
   2524  2445					      repend
   2525  2446		       00		      .byte.b	0
   2524  2446					      repend
   2525  2447		       00		      .byte.b	0
   2524  2447					      repend
   2525  2448		       00		      .byte.b	0
   2524  2448					      repend
   2525  2449		       00		      .byte.b	0
   2524  2449					      repend
   2525  244a		       00		      .byte.b	0
   2524  244a					      repend
   2525  244b		       00		      .byte.b	0
   2524  244b					      repend
   2525  244c		       00		      .byte.b	0
   2524  244c					      repend
   2525  244d		       00		      .byte.b	0
   2524  244d					      repend
   2525  244e		       00		      .byte.b	0
   2524  244e					      repend
   2525  244f		       00		      .byte.b	0
   2524  244f					      repend
   2525  2450		       00		      .byte.b	0
   2524  2450					      repend
   2525  2451		       00		      .byte.b	0
   2524  2451					      repend
   2525  2452		       00		      .byte.b	0
   2524  2452					      repend
   2525  2453		       00		      .byte.b	0
   2524  2453					      repend
   2525  2454		       00		      .byte.b	0
   2524  2454					      repend
   2525  2455		       00		      .byte.b	0
   2524  2455					      repend
   2525  2456		       00		      .byte.b	0
   2524  2456					      repend
   2525  2457		       00		      .byte.b	0
   2524  2457					      repend
   2525  2458		       00		      .byte.b	0
   2524  2458					      repend
   2525  2459		       00		      .byte.b	0
   2526  245a					      repend
   2527  245a					      endif
   2528  245a				   player2then_0
   2529  245a		       00		      .byte.b	0
   2530  245b		       00		      .byte.b	%00000000
   2531  245c		       82		      .byte.b	%10000010
   2532  245d		       44		      .byte.b	%01000100
   2533  245e		       fe		      .byte.b	%11111110
   2534  245f		       fe		      .byte.b	%11111110
   2535  2460		       ba		      .byte.b	%10111010
   2536  2461		       7c		      .byte.b	%01111100
   2537  2462		       82		      .byte.b	%10000010
   2538  2463				  -	      if	(<*) > (<(*+8))
   2539  2463				  -	      repeat	($100-<*)
   2540  2463				  -	      .byte	0
   2541  2463				  -	      repend
   2542  2463					      endif
   2543  2463				  -	      if	(<*) < 90
   2544  2463				  -	      repeat	(90-<*)
   2545  2463				  -	      .byte	0
   2546  2463				  -	      repend
   2547  2463					      endif
   2548  2463				   player4then_0
   2549  2463		       00		      .byte.b	0
   2550  2464		       00		      .byte.b	%00000000
   2551  2465		       28		      .byte.b	%00101000
   2552  2466		       44		      .byte.b	%01000100
   2553  2467		       fe		      .byte.b	%11111110
   2554  2468		       fe		      .byte.b	%11111110
   2555  2469		       ba		      .byte.b	%10111010
   2556  246a		       7c		      .byte.b	%01111100
   2557  246b		       44		      .byte.b	%01000100
   2558  246c				  -	      if	(<*) > (<(*+7))
   2559  246c				  -	      repeat	($100-<*)
   2560  246c				  -	      .byte	0
   2561  246c				  -	      repend
   2562  246c					      endif
   2563  246c				  -	      if	(<*) < 90
   2564  246c				  -	      repeat	(90-<*)
   2565  246c				  -	      .byte	0
   2566  246c				  -	      repend
   2567  246c					      endif
   2568  246c				   playerL050_2
   2569  246c		       00		      .byte.b	%00000000
   2570  246d		       00		      .byte.b	%00000000
   2571  246e		       10		      .byte.b	%00010000
   2572  246f		       20		      .byte.b	%00100000
   2573  2470		       10		      .byte.b	%00010000
   2574  2471		       08		      .byte.b	%00001000
   2575  2472		       10		      .byte.b	%00010000
   2576  2473		       00		      .byte.b	%00000000
   2577  2474				  -	      if	(<*) > (<(*+8))
   2578  2474				  -	      repeat	($100-<*)
   2579  2474				  -	      .byte	0
   2580  2474				  -	      repend
   2581  2474					      endif
   2582  2474				  -	      if	(<*) < 90
   2583  2474				  -	      repeat	(90-<*)
   2584  2474				  -	      .byte	0
   2585  2474				  -	      repend
   2586  2474					      endif
   2587  2474				   player33then_0
   2588  2474		       00		      .byte.b	0
   2589  2475		       00		      .byte.b	%00000000
   2590  2476		       92		      .byte.b	%10010010
   2591  2477		       54		      .byte.b	%01010100
   2592  2478		       00		      .byte.b	%00000000
   2593  2479		       d6		      .byte.b	%11010110
   2594  247a		       00		      .byte.b	%00000000
   2595  247b		       54		      .byte.b	%01010100
   2596  247c		       92		      .byte.b	%10010010
   2597  247d				  -	      if	(<*) > (<(*+8))
   2598  247d				  -	      repeat	($100-<*)
   2599  247d				  -	      .byte	0
   2600  247d				  -	      repend
   2601  247d					      endif
   2602  247d				  -	      if	(<*) < 90
   2603  247d				  -	      repeat	(90-<*)
   2604  247d				  -	      .byte	0
   2605  247d				  -	      repend
   2606  247d					      endif
   2607  247d				   playerL064_0
   2608  247d		       00		      .byte.b	0
   2609  247e		       00		      .byte.b	%00000000
   2610  247f		       82		      .byte.b	%10000010
   2611  2480		       44		      .byte.b	%01000100
   2612  2481		       fe		      .byte.b	%11111110
   2613  2482		       fe		      .byte.b	%11111110
   2614  2483		       ba		      .byte.b	%10111010
   2615  2484		       7c		      .byte.b	%01111100
   2616  2485		       82		      .byte.b	%10000010
   2617  2486				  -	      if	(<*) > (<(*+7))
   2618  2486				  -	      repeat	($100-<*)
   2619  2486				  -	      .byte	0
   2620  2486				  -	      repend
   2621  2486					      endif
   2622  2486				  -	      if	(<*) < 90
   2623  2486				  -	      repeat	(90-<*)
   2624  2486				  -	      .byte	0
   2625  2486				  -	      repend
   2626  2486					      endif
   2627  2486				   playerL067_1
   2628  2486		       fe		      .byte.b	%11111110
   2629  2487		       fe		      .byte.b	%11111110
   2630  2488		       7c		      .byte.b	%01111100
   2631  2489		       10		      .byte.b	%00010000
   2632  248a		       00		      .byte.b	%00000000
   2633  248b		       00		      .byte.b	%00000000
   2634  248c		       00		      .byte.b	%00000000
   2635  248d		       00		      .byte.b	%00000000
   2636  248e				  -	      if	(<*) > (<(*+7))
   2637  248e				  -	      repeat	($100-<*)
   2638  248e				  -	      .byte	0
   2639  248e				  -	      repend
   2640  248e					      endif
   2641  248e				  -	      if	(<*) < 90
   2642  248e				  -	      repeat	(90-<*)
   2643  248e				  -	      .byte	0
   2644  248e				  -	      repend
   2645  248e					      endif
   2646  248e				   playerL073_3
   2647  248e		       00		      .byte.b	%00000000
   2648  248f		       00		      .byte.b	%00000000
   2649  2490		       00		      .byte.b	%00000000
   2650  2491		       10		      .byte.b	%00010000
   2651  2492		       10		      .byte.b	%00010000
   2652  2493		       00		      .byte.b	%00000000
   2653  2494		       00		      .byte.b	%00000000
   2654  2495		       00		      .byte.b	%00000000
   2655  2496				  -	      if	(<*) > (<(*+24))
   2656  2496				  -	      repeat	($100-<*)
   2657  2496				  -	      .byte	0
   2658  2496				  -	      repend
   2659  2496					      endif
   2660  2496				  -	      if	(<*) < 90
   2661  2496				  -	      repeat	(90-<*)
   2662  2496				  -	      .byte	0
   2663  2496				  -	      repend
   2664  2496					      endif
   2665  2496				   playerL084_2
   2666  2496		       00		      .byte.b	%00000000
   2667  2497		       00		      .byte.b	%00000000
   2668  2498		       00		      .byte.b	%00000000
   2669  2499		       00		      .byte.b	%00000000
   2670  249a		       00		      .byte.b	%00000000
   2671  249b		       f8		      .byte.b	%11111000
   2672  249c		       80		      .byte.b	%10000000
   2673  249d		       c0		      .byte.b	%11000000
   2674  249e		       80		      .byte.b	%10000000
   2675  249f		       f8		      .byte.b	%11111000
   2676  24a0		       00		      .byte.b	%00000000
   2677  24a1		       88		      .byte.b	%10001000
   2678  24a2		       88		      .byte.b	%10001000
   2679  24a3		       a8		      .byte.b	%10101000
   2680  24a4		       f8		      .byte.b	%11111000
   2681  24a5		       00		      .byte.b	%00000000
   2682  24a6		       88		      .byte.b	%10001000
   2683  24a7		       f8		      .byte.b	%11111000
   2684  24a8		       88		      .byte.b	%10001000
   2685  24a9		       f8		      .byte.b	%11111000
   2686  24aa		       00		      .byte.b	%00000000
   2687  24ab		       f8		      .byte.b	%11111000
   2688  24ac		       88		      .byte.b	%10001000
   2689  24ad		       80		      .byte.b	%10000000
   2690  24ae		       f8		      .byte.b	%11111000
   2691  24af				  -	      if	(<*) > (<(*+24))
   2692  24af				  -	      repeat	($100-<*)
   2693  24af				  -	      .byte	0
   2694  24af				  -	      repend
   2695  24af					      endif
   2696  24af				  -	      if	(<*) < 90
   2697  24af				  -	      repeat	(90-<*)
   2698  24af				  -	      .byte	0
   2699  24af				  -	      repend
   2700  24af					      endif
   2701  24af				   playerL085_3
   2702  24af		       00		      .byte.b	%00000000
   2703  24b0		       00		      .byte.b	%00000000
   2704  24b1		       00		      .byte.b	%00000000
   2705  24b2		       00		      .byte.b	%00000000
   2706  24b3		       00		      .byte.b	%00000000
   2707  24b4		       88		      .byte.b	%10001000
   2708  24b5		       f0		      .byte.b	%11110000
   2709  24b6		       88		      .byte.b	%10001000
   2710  24b7		       f8		      .byte.b	%11111000
   2711  24b8		       00		      .byte.b	%00000000
   2712  24b9		       f8		      .byte.b	%11111000
   2713  24ba		       80		      .byte.b	%10000000
   2714  24bb		       c0		      .byte.b	%11000000
   2715  24bc		       80		      .byte.b	%10000000
   2716  24bd		       f8		      .byte.b	%11111000
   2717  24be		       00		      .byte.b	%00000000
   2718  24bf		       20		      .byte.b	%00100000
   2719  24c0		       50		      .byte.b	%01010000
   2720  24c1		       88		      .byte.b	%10001000
   2721  24c2		       88		      .byte.b	%10001000
   2722  24c3		       00		      .byte.b	%00000000
   2723  24c4		       f8		      .byte.b	%11111000
   2724  24c5		       88		      .byte.b	%10001000
   2725  24c6		       88		      .byte.b	%10001000
   2726  24c7		       f8		      .byte.b	%11111000
   2727  24c8					      if	ECHOFIRST
      2732 bytes of ROM space left in bank 2
   2728  24c8					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   2729  24c8					      endif
   2730  24c8		       00 01	   ECHOFIRST  =	1
   2731  24c8
   2732  24c8
   2733  24c8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2734  24c8
   2735  24c8							; feel free to modify the score graphics - just keep each digit 8 high
   2736  24c8							; and keep the conditional compilation stuff intact
   2737  24c8				  -	      ifconst	ROM2k
   2738  24c8				  -	      ORG	$F7AC-8
   2739  24c8					      else
   2740  24c8					      ifconst	bankswitch
   2741  24c8					      if	bankswitch == 8
   2742  2f74					      ORG	$2F94-bscode_length
   2743  2f74					      RORG	$FF94-bscode_length
   2744  2f74					      endif
   2745  2f74				  -	      if	bankswitch == 16
   2746  2f74				  -	      ORG	$4F94-bscode_length
   2747  2f74				  -	      RORG	$FF94-bscode_length
   2748  2f74					      endif
   2749  2f74				  -	      if	bankswitch == 32
   2750  2f74				  -	      ORG	$8F94-bscode_length
   2751  2f74				  -	      RORG	$FF94-bscode_length
   2752  2f74					      endif
   2753  2f74				  -	      if	bankswitch == 64
   2754  2f74				  -	      ORG	$10F80-bscode_length
   2755  2f74				  -	      RORG	$1FF80-bscode_length
   2756  2f74					      endif
   2757  2f74				  -	      else
   2758  2f74				  -	      ORG	$FF9C
   2759  2f74					      endif
   2760  2f74					      endif
   2761  2f74
   2762  2f74							; font equates
   2763  2f74		       00 01	   .21stcentury =	1
   2764  2f74		       00 02	   alarmclock =	2
   2765  2f74		       00 03	   handwritten =	3
   2766  2f74		       00 04	   interrupted =	4
   2767  2f74		       00 05	   retroputer =	5
   2768  2f74		       00 06	   whimsey    =	6
   2769  2f74		       00 07	   tiny       =	7
   2770  2f74		       00 08	   hex	      =	8
   2771  2f74
   2772  2f74				  -	      ifconst	font
   2773  2f74				  -	      if	font == hex
   2774  2f74				  -	      ORG	. - 48
   2775  2f74				  -	      endif
   2776  2f74					      endif
   2777  2f74
   2778  2f74				   scoretable
   2779  2f74
   2780  2f74				  -	      ifconst	font
   2781  2f74				  -	      if	font == .21stcentury
   2782  2f74				  -	      include	"score_graphics.asm.21stcentury"
   2783  2f74				  -	      endif
   2784  2f74				  -	      if	font == alarmclock
   2785  2f74				  -	      include	"score_graphics.asm.alarmclock"
   2786  2f74				  -	      endif
   2787  2f74				  -	      if	font == handwritten
   2788  2f74				  -	      include	"score_graphics.asm.handwritten"
   2789  2f74				  -	      endif
   2790  2f74				  -	      if	font == interrupted
   2791  2f74				  -	      include	"score_graphics.asm.interrupted"
   2792  2f74				  -	      endif
   2793  2f74				  -	      if	font == retroputer
   2794  2f74				  -	      include	"score_graphics.asm.retroputer"
   2795  2f74				  -	      endif
   2796  2f74				  -	      if	font == whimsey
   2797  2f74				  -	      include	"score_graphics.asm.whimsey"
   2798  2f74				  -	      endif
   2799  2f74				  -	      if	font == tiny
   2800  2f74				  -	      include	"score_graphics.asm.tiny"
   2801  2f74				  -	      endif
   2802  2f74				  -	      if	font == hex
   2803  2f74				  -	      include	"score_graphics.asm.hex"
   2804  2f74				  -	      endif
   2805  2f74					      else		; default font
   2806  2f74
   2807  2f74		       3c		      .byte.b	%00111100
   2808  2f75		       66		      .byte.b	%01100110
   2809  2f76		       66		      .byte.b	%01100110
   2810  2f77		       66		      .byte.b	%01100110
   2811  2f78		       66		      .byte.b	%01100110
   2812  2f79		       66		      .byte.b	%01100110
   2813  2f7a		       66		      .byte.b	%01100110
   2814  2f7b		       3c		      .byte.b	%00111100
   2815  2f7c
   2816  2f7c		       7e		      .byte.b	%01111110
   2817  2f7d		       18		      .byte.b	%00011000
   2818  2f7e		       18		      .byte.b	%00011000
   2819  2f7f		       18		      .byte.b	%00011000
   2820  2f80		       18		      .byte.b	%00011000
   2821  2f81		       38		      .byte.b	%00111000
   2822  2f82		       18		      .byte.b	%00011000
   2823  2f83		       08		      .byte.b	%00001000
   2824  2f84
   2825  2f84		       7e		      .byte.b	%01111110
   2826  2f85		       60		      .byte.b	%01100000
   2827  2f86		       60		      .byte.b	%01100000
   2828  2f87		       3c		      .byte.b	%00111100
   2829  2f88		       06		      .byte.b	%00000110
   2830  2f89		       06		      .byte.b	%00000110
   2831  2f8a		       46		      .byte.b	%01000110
   2832  2f8b		       3c		      .byte.b	%00111100
   2833  2f8c
   2834  2f8c		       3c		      .byte.b	%00111100
   2835  2f8d		       46		      .byte.b	%01000110
   2836  2f8e		       06		      .byte.b	%00000110
   2837  2f8f		       06		      .byte.b	%00000110
   2838  2f90		       1c		      .byte.b	%00011100
   2839  2f91		       06		      .byte.b	%00000110
   2840  2f92		       46		      .byte.b	%01000110
   2841  2f93		       3c		      .byte.b	%00111100
   2842  2f94
   2843  2f94		       0c		      .byte.b	%00001100
   2844  2f95		       0c		      .byte.b	%00001100
   2845  2f96		       7e		      .byte.b	%01111110
   2846  2f97		       4c		      .byte.b	%01001100
   2847  2f98		       4c		      .byte.b	%01001100
   2848  2f99		       2c		      .byte.b	%00101100
   2849  2f9a		       1c		      .byte.b	%00011100
   2850  2f9b		       0c		      .byte.b	%00001100
   2851  2f9c
   2852  2f9c		       3c		      .byte.b	%00111100
   2853  2f9d		       46		      .byte.b	%01000110
   2854  2f9e		       06		      .byte.b	%00000110
   2855  2f9f		       06		      .byte.b	%00000110
   2856  2fa0		       3c		      .byte.b	%00111100
   2857  2fa1		       60		      .byte.b	%01100000
   2858  2fa2		       60		      .byte.b	%01100000
   2859  2fa3		       7e		      .byte.b	%01111110
   2860  2fa4
   2861  2fa4		       3c		      .byte.b	%00111100
   2862  2fa5		       66		      .byte.b	%01100110
   2863  2fa6		       66		      .byte.b	%01100110
   2864  2fa7		       66		      .byte.b	%01100110
   2865  2fa8		       7c		      .byte.b	%01111100
   2866  2fa9		       60		      .byte.b	%01100000
   2867  2faa		       62		      .byte.b	%01100010
   2868  2fab		       3c		      .byte.b	%00111100
   2869  2fac
   2870  2fac		       30		      .byte.b	%00110000
   2871  2fad		       30		      .byte.b	%00110000
   2872  2fae		       30		      .byte.b	%00110000
   2873  2faf		       18		      .byte.b	%00011000
   2874  2fb0		       0c		      .byte.b	%00001100
   2875  2fb1		       06		      .byte.b	%00000110
   2876  2fb2		       42		      .byte.b	%01000010
   2877  2fb3		       3e		      .byte.b	%00111110
   2878  2fb4
   2879  2fb4		       3c		      .byte.b	%00111100
   2880  2fb5		       66		      .byte.b	%01100110
   2881  2fb6		       66		      .byte.b	%01100110
   2882  2fb7		       66		      .byte.b	%01100110
   2883  2fb8		       3c		      .byte.b	%00111100
   2884  2fb9		       66		      .byte.b	%01100110
   2885  2fba		       66		      .byte.b	%01100110
   2886  2fbb		       3c		      .byte.b	%00111100
   2887  2fbc
   2888  2fbc		       3c		      .byte.b	%00111100
   2889  2fbd		       46		      .byte.b	%01000110
   2890  2fbe		       06		      .byte.b	%00000110
   2891  2fbf		       3e		      .byte.b	%00111110
   2892  2fc0		       66		      .byte.b	%01100110
   2893  2fc1		       66		      .byte.b	%01100110
   2894  2fc2		       66		      .byte.b	%01100110
   2895  2fc3		       3c		      .byte.b	%00111100
   2896  2fc4
   2897  2fc4					      ifnconst	DPC_kernel_options
   2898  2fc4
   2899  2fc4		       00		      .byte.b	%00000000
   2900  2fc5		       00		      .byte.b	%00000000
   2901  2fc6		       00		      .byte.b	%00000000
   2902  2fc7		       00		      .byte.b	%00000000
   2903  2fc8		       00		      .byte.b	%00000000
   2904  2fc9		       00		      .byte.b	%00000000
   2905  2fca		       00		      .byte.b	%00000000
   2906  2fcb		       00		      .byte.b	%00000000
   2907  2fcc
   2908  2fcc					      endif
   2909  2fcc
   2910  2fcc					      endif
   2911  2fcc
   2912  2fcc				  -	      ifconst	ROM2k
   2913  2fcc				  -	      ORG	$F7FC
   2914  2fcc					      else
   2915  2fcc					      ifconst	bankswitch
   2916  2fcc					      if	bankswitch == 8
   2917  2fd4					      ORG	$2FF4-bscode_length
   2918  2fd4					      RORG	$FFF4-bscode_length
   2919  2fd4					      endif
   2920  2fd4				  -	      if	bankswitch == 16
   2921  2fd4				  -	      ORG	$4FF4-bscode_length
   2922  2fd4				  -	      RORG	$FFF4-bscode_length
   2923  2fd4					      endif
   2924  2fd4				  -	      if	bankswitch == 32
   2925  2fd4				  -	      ORG	$8FF4-bscode_length
   2926  2fd4				  -	      RORG	$FFF4-bscode_length
   2927  2fd4					      endif
   2928  2fd4				  -	      if	bankswitch == 64
   2929  2fd4				  -	      ORG	$10FE0-bscode_length
   2930  2fd4				  -	      RORG	$1FFE0-bscode_length
   2931  2fd4					      endif
   2932  2fd4				  -	      else
   2933  2fd4				  -	      ORG	$FFFC
   2934  2fd4					      endif
   2935  2fd4					      endif
   2936  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2937  2fd4
   2938  2fd4							; every bank has this stuff at the same place
   2939  2fd4							; this code can switch to/from any bank at any entry point
   2940  2fd4							; and can preserve register values
   2941  2fd4							; note: lines not starting with a space are not placed in all banks
   2942  2fd4							;
   2943  2fd4							; line below tells the compiler how long this is - do not remove
   2944  2fd4							;size=32
   2945  2fd4
   2946  2fd4				   begin_bscode
   2947  2fd4		       a2 ff		      ldx	#$ff
   2948  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   2949  2fd6				  -	      stx	FASTFETCH
   2950  2fd6					      endif
   2951  2fd6		       9a		      txs
   2952  2fd7				  -	      if	bankswitch == 64
   2953  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2954  2fd7					      else
   2955  2fd7		       a9 f3		      lda	#>(start-1)
   2956  2fd9					      endif
   2957  2fd9		       48		      pha
   2958  2fda		       a9 f7		      lda	#<(start-1)
   2959  2fdc		       48		      pha
   2960  2fdd
   2961  2fdd				   BS_return
   2962  2fdd		       48		      pha
   2963  2fde		       8a		      txa
   2964  2fdf		       48		      pha
   2965  2fe0		       ba		      tsx
   2966  2fe1
   2967  2fe1					      if	bankswitch != 64
   2968  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   2969  2fe3
   2970  2fe3		       2a		      rol
   2971  2fe4		       2a		      rol
   2972  2fe5		       2a		      rol
   2973  2fe6		       2a		      rol
   2974  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2975  2fe9		       aa		      tax
   2976  2fea		       e8		      inx
   2977  2feb				  -	      else
   2978  2feb				  -	      lda	4,x	; get high byte of return address
   2979  2feb				  -	      tay
   2980  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2981  2feb				  -	      sta	4,x
   2982  2feb				  -	      tya
   2983  2feb				  -	      lsr
   2984  2feb				  -	      lsr
   2985  2feb				  -	      lsr
   2986  2feb				  -	      lsr
   2987  2feb				  -	      tax
   2988  2feb				  -	      inx
   2989  2feb					      endif
   2990  2feb
   2991  2feb				   BS_jsr
   2992  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   2993  2fee		       68		      pla
   2994  2fef		       aa		      tax
   2995  2ff0		       68		      pla
   2996  2ff1		       60		      rts
   2997  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2998  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2999  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3000  2ff2					      endif
   3001  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3002  2ff2
   3003  2ff2					      ifconst	bankswitch
   3004  2ff2					      if	bankswitch == 8
   3005  2ffc					      ORG	$2FFC
   3006  2ffc					      RORG	$FFFC
   3007  2ffc					      endif
   3008  2ffc				  -	      if	bankswitch == 16
   3009  2ffc				  -	      ORG	$4FFC
   3010  2ffc				  -	      RORG	$FFFC
   3011  2ffc					      endif
   3012  2ffc				  -	      if	bankswitch == 32
   3013  2ffc				  -	      ORG	$8FFC
   3014  2ffc				  -	      RORG	$FFFC
   3015  2ffc					      endif
   3016  2ffc				  -	      if	bankswitch == 64
   3017  2ffc				  -	      ORG	$10FF0
   3018  2ffc				  -	      RORG	$1FFF0
   3019  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3020  2ffc				  -	      ORG	$10FF8
   3021  2ffc				  -	      RORG	$1FFF8
   3022  2ffc				  -	      ifconst	superchip
   3023  2ffc				  -	      .byte	"E","F","S","C"
   3024  2ffc				  -	      else
   3025  2ffc				  -	      .byte	"E","F","E","F"
   3026  2ffc				  -	      endif
   3027  2ffc				  -	      ORG	$10FFC
   3028  2ffc				  -	      RORG	$1FFFC
   3029  2ffc					      endif
   3030  2ffc				  -	      else
   3031  2ffc				  -	      ifconst	ROM2k
   3032  2ffc				  -	      ORG	$F7FC
   3033  2ffc				  -	      else
   3034  2ffc				  -	      ORG	$FFFC
   3035  2ffc				  -	      endif
   3036  2ffc					      endif
   3037  2ffc		       f8 f3		      .word.w	(start & $ffff)
   3038  2ffe		       f8 f3		      .word.w	(start & $ffff)
