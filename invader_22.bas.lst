------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_22.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_22.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_22.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  3000 ????				      include	"multisprite.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????	       00 80	   missile0x  =	$80
      4  3000 ????	       00 81	   missile1x  =	$81
      5  3000 ????	       00 82	   ballx      =	$82
      6  3000 ????
      7  3000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  3000 ????
      9  3000 ????	       00 83	   SpriteIndex =	$83
     10  3000 ????
     11  3000 ????	       00 84	   player0x   =	$84
     12  3000 ????	       00 85	   NewSpriteX =	$85	;		X position
     13  3000 ????	       00 85	   player1x   =	$85
     14  3000 ????	       00 86	   player2x   =	$86
     15  3000 ????	       00 87	   player3x   =	$87
     16  3000 ????	       00 88	   player4x   =	$88
     17  3000 ????	       00 89	   player5x   =	$89
     18  3000 ????
     19  3000 ????	       00 8a	   objecty    =	$8A
     20  3000 ????	       00 8a	   missile0y  =	$8A
     21  3000 ????	       00 8b	   missile1y  =	$8B
     22  3000 ????	       00 8c	   bally      =	$8C
     23  3000 ????
     24  3000 ????	       00 8d	   player0y   =	$8D
     25  3000 ????	       00 8e	   NewSpriteY =	$8E	;		Y position
     26  3000 ????	       00 8e	   player1y   =	$8E
     27  3000 ????	       00 8f	   player2y   =	$8F
     28  3000 ????	       00 90	   player3y   =	$90
     29  3000 ????	       00 91	   player4y   =	$91
     30  3000 ????	       00 92	   player5y   =	$92
     31  3000 ????
     32  3000 ????	       00 93	   NewNUSIZ   =	$93
     33  3000 ????	       00 93	   _NUSIZ1    =	$93
     34  3000 ????	       00 94	   NUSIZ2     =	$94
     35  3000 ????	       00 95	   NUSIZ3     =	$95
     36  3000 ????	       00 96	   NUSIZ4     =	$96
     37  3000 ????	       00 97	   NUSIZ5     =	$97
     38  3000 ????
     39  3000 ????	       00 98	   NewCOLUP1  =	$98
     40  3000 ????	       00 98	   _COLUP1    =	$98
     41  3000 ????	       00 99	   COLUP2     =	$99
     42  3000 ????	       00 9a	   COLUP3     =	$9A
     43  3000 ????	       00 9b	   COLUP4     =	$9B
     44  3000 ????	       00 9c	   COLUP5     =	$9C
     45  3000 ????
     46  3000 ????	       00 9d	   SpriteGfxIndex =	$9D
     47  3000 ????
     48  3000 ????	       00 a2	   player0pointer =	$A2
     49  3000 ????	       00 a2	   player0pointerlo =	$A2
     50  3000 ????	       00 a3	   player0pointerhi =	$A3
     51  3000 ????
     52  3000 ????						;P0Top = temp5
     53  3000 ????	       00 cf	   P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  3000 ????	       00 a4	   P0Bottom   =	$A4
     55  3000 ????	       00 a5	   P1Bottom   =	$A5
     56  3000 ????
     57  3000 ????	       00 a6	   player1pointerlo =	$A6
     58  3000 ????	       00 a7	   player2pointerlo =	$A7
     59  3000 ????	       00 a8	   player3pointerlo =	$A8
     60  3000 ????	       00 a9	   player4pointerlo =	$A9
     61  3000 ????	       00 aa	   player5pointerlo =	$AA
     62  3000 ????
     63  3000 ????	       00 ab	   player1pointerhi =	$AB
     64  3000 ????	       00 ac	   player2pointerhi =	$AC
     65  3000 ????	       00 ad	   player3pointerhi =	$AD
     66  3000 ????	       00 ae	   player4pointerhi =	$AE
     67  3000 ????	       00 af	   player5pointerhi =	$AF
     68  3000 ????
     69  3000 ????	       00 b0	   player0height =	$B0
     70  3000 ????	       00 b1	   spriteheight =	$B1	; heights of multiplexed player sprite
     71  3000 ????	       00 b1	   player1height =	$B1
     72  3000 ????	       00 b2	   player2height =	$B2
     73  3000 ????	       00 b3	   player3height =	$B3
     74  3000 ????	       00 b4	   player4height =	$B4
     75  3000 ????	       00 b5	   player5height =	$B5
     76  3000 ????
     77  3000 ????	       00 b6	   PF1temp1   =	$B6
     78  3000 ????	       00 b7	   PF1temp2   =	$B7
     79  3000 ????	       00 b8	   PF2temp1   =	$B8
     80  3000 ????	       00 b9	   PF2temp2   =	$B9
     81  3000 ????
     82  3000 ????	       00 ba	   pfpixelheight =	$BA
     83  3000 ????
     84  3000 ????						; playfield is now a pointer to graphics
     85  3000 ????	       00 bb	   playfield  =	$BB
     86  3000 ????	       00 bb	   PF1pointer =	$BB
     87  3000 ????
     88  3000 ????	       00 bd	   PF2pointer =	$BD
     89  3000 ????
     90  3000 ????	       00 bf	   statusbarlength =	$BF
     91  3000 ????	       00 bf	   aux3       =	$BF
     92  3000 ????
     93  3000 ????	       00 c0	   lifecolor  =	$C0
     94  3000 ????	       00 c0	   pfscorecolor =	$C0
     95  3000 ????	       00 c0	   aux4       =	$C0
     96  3000 ????
     97  3000 ????						;P1display = temp2 ; temp2 and temp3
     98  3000 ????	       00 cc	   P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  3000 ????	       00 c1	   lifepointer =	$c1
    100  3000 ????	       00 c2	   lives      =	$c2
    101  3000 ????	       00 c1	   pfscore1   =	$c1
    102  3000 ????	       00 c2	   pfscore2   =	$c2
    103  3000 ????	       00 c1	   aux5       =	$c1
    104  3000 ????	       00 c2	   aux6       =	$c2
    105  3000 ????
    106  3000 ????	       00 c3	   playfieldpos =	$C3
    107  3000 ????
    108  3000 ????						;RepoLine = temp4
    109  3000 ????	       00 ce	   RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  3000 ????
    111  3000 ????	       00 c4	   pfheight   =	$C4
    112  3000 ????	       00 c5	   scorepointers =	$C5
    113  3000 ????
    114  3000 ????	       00 cb	   temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  3000 ????	       00 cc	   temp2      =	$CC	;are obliterated when drawscreen is called.
    116  3000 ????	       00 cd	   temp3      =	$CD
    117  3000 ????	       00 ce	   temp4      =	$CE
    118  3000 ????	       00 cf	   temp5      =	$CF
    119  3000 ????	       00 d0	   temp6      =	$D0
    120  3000 ????	       00 d1	   temp7      =	$D1	; This is used to aid in bankswitching
    121  3000 ????
    122  3000 ????	       00 d2	   score      =	$D2
    123  3000 ????	       00 d5	   scorecolor =	$D5	;need to find other places for these, possibly...
    124  3000 ????	       00 d6	   rand       =	$D6
    125  3000 ????
    126  3000 ????
    127  3000 ????
    128  3000 ????	       00 d7	   A	      =	$d7
    129  3000 ????	       00 d7	   a	      =	$d7
    130  3000 ????	       00 d8	   B	      =	$d8
    131  3000 ????	       00 d8	   b	      =	$d8
    132  3000 ????	       00 d9	   C	      =	$d9
    133  3000 ????	       00 d9	   c	      =	$d9
    134  3000 ????	       00 da	   D	      =	$da
    135  3000 ????	       00 da	   d	      =	$da
    136  3000 ????	       00 db	   E	      =	$db
    137  3000 ????	       00 db	   e	      =	$db
    138  3000 ????	       00 dc	   F	      =	$dc
    139  3000 ????	       00 dc	   f	      =	$dc
    140  3000 ????	       00 dd	   G	      =	$dd
    141  3000 ????	       00 dd	   g	      =	$dd
    142  3000 ????	       00 de	   H	      =	$de
    143  3000 ????	       00 de	   h	      =	$de
    144  3000 ????	       00 df	   I	      =	$df
    145  3000 ????	       00 df	   i	      =	$df
    146  3000 ????	       00 e0	   J	      =	$e0
    147  3000 ????	       00 e0	   j	      =	$e0
    148  3000 ????	       00 e1	   K	      =	$e1
    149  3000 ????	       00 e1	   k	      =	$e1
    150  3000 ????	       00 e2	   L	      =	$e2
    151  3000 ????	       00 e2	   l	      =	$e2
    152  3000 ????	       00 e3	   M	      =	$e3
    153  3000 ????	       00 e3	   m	      =	$e3
    154  3000 ????	       00 e4	   N	      =	$e4
    155  3000 ????	       00 e4	   n	      =	$e4
    156  3000 ????	       00 e5	   O	      =	$e5
    157  3000 ????	       00 e5	   o	      =	$e5
    158  3000 ????	       00 e6	   P	      =	$e6
    159  3000 ????	       00 e6	   p	      =	$e6
    160  3000 ????	       00 e7	   Q	      =	$e7
    161  3000 ????	       00 e7	   q	      =	$e7
    162  3000 ????	       00 e8	   R	      =	$e8
    163  3000 ????	       00 e8	   r	      =	$e8
    164  3000 ????	       00 e9	   S	      =	$e9
    165  3000 ????	       00 e9	   s	      =	$e9
    166  3000 ????	       00 ea	   T	      =	$ea
    167  3000 ????	       00 ea	   t	      =	$ea
    168  3000 ????	       00 eb	   U	      =	$eb
    169  3000 ????	       00 eb	   u	      =	$eb
    170  3000 ????	       00 ec	   V	      =	$ec
    171  3000 ????	       00 ec	   v	      =	$ec
    172  3000 ????	       00 ed	   W	      =	$ed
    173  3000 ????	       00 ed	   w	      =	$ed
    174  3000 ????	       00 ee	   X	      =	$ee
    175  3000 ????	       00 ee	   x	      =	$ee
    176  3000 ????	       00 ef	   Y	      =	$ef
    177  3000 ????	       00 ef	   y	      =	$ef
    178  3000 ????	       00 f0	   Z	      =	$f0
    179  3000 ????	       00 f0	   z	      =	$f0
    180  3000 ????
    181  3000 ????	       00 f1	   spritesort =	$f1	; helps with flickersort
    182  3000 ????	       00 f2	   spritesort2 =	$f2	; helps with flickersort
    183  3000 ????	       00 f3	   spritesort3 =	$f3
    184  3000 ????	       00 f4	   spritesort4 =	$f4
    185  3000 ????	       00 f5	   spritesort5 =	$f5
    186  3000 ????
    187  3000 ????	       00 f6	   stack1     =	$f6
    188  3000 ????	       00 f7	   stack2     =	$f7
    189  3000 ????	       00 f8	   stack3     =	$f8
    190  3000 ????	       00 f9	   stack4     =	$f9
    191  3000 ????						; the stack bytes above may be used in the kernel
    192  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  3000 ????
    194  3000 ????				      MAC	return
    195  3000 ????				      ifnconst	bankswitch
    196  3000 ????				      rts
    197  3000 ????				      else
    198  3000 ????				      jmp	BS_return
    199  3000 ????				      endif
    200  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_22.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 e9	   tur_anim_frame =	s
      5  3000 ????	       00 e8	   tur_anim_playing =	r
      6  3000 ????	       00 e7	   tur_hit    =	q
      7  3000 ????	       00 e3	   tur_fired  =	m
      8  3000 ????	       00 e0	   shot_y     =	j
      9  3000 ????	       00 df	   shot_x     =	i
     10  3000 ????	       00 db	   tur_y      =	e
     11  3000 ????	       00 da	   tur_x      =	d
     12  3000 ????	       00 e5	   inv_blast_delay =	o
     13  3000 ????	       00 e4	   inv_hit    =	n
     14  3000 ????	       00 e2	   inv_fired  =	l
     15  3000 ????	       00 e1	   inv_fire_delay =	k
     16  3000 ????	       00 de	   inv_shot_y =	h
     17  3000 ????	       00 dd	   inv_shot_x =	g
     18  3000 ????	       00 dc	   inv_dir    =	f
     19  3000 ????	       00 d9	   inv_delay  =	c
     20  3000 ????	       00 d8	   inv_y      =	b
     21  3000 ????	       00 d7	   inv_x      =	a
     22  3000 ????	       00 e6	   reducing_lives =	p
     23  3000 ????	       00 ea	   sound      =	t
     24  3000 ????	       00 00	   pfscore    =	0
     25  3000 ????
     26  3000 ????	       00 01	   bs_mask    =	1
     27  3000 ????	       00 08	   bankswitch =	8
     28  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
     29  3000 ????	       00 01	   multisprite =	1
     30  3000 ????	       00 01	   no_blank_lines =	1
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_22.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	234	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .L00 		;  includesfile multisprite_bankswitch.inc
     57  1000
     58  1000				   .L01 		;  set kernel_options no_blank_lines
     59  1000
     60  1000				   .
     61  1000							; 
     62  1000
     63  1000				   .L02 		;  set kernel multisprite
     64  1000
     65  1000				   .L03 		;  set romsize 8k
     66  1000
     67  1000				   .
     68  1000							; 
     69  1000
     70  1000				   .
     71  1000							; 
     72  1000
     73  1000				   .L04 		;  const pfscore  =  0
     74  1000
     75  1000				   .
     76  1000							; 
     77  1000
     78  1000				   .
     79  1000							; 
     80  1000
     81  1000				   .
     82  1000							; 
     83  1000
     84  1000				   .L05 		;  dim sound  =  t  :	sound  =  32
     85  1000
     86  1000		       a9 20		      LDA	#32
     87  1002		       85 ea		      STA	sound
     88  1004				   .
     89  1004							; 
     90  1004
     91  1004				   .L06 		;  dim reducing_lives	=  p  :  p  =  0
     92  1004
     93  1004		       a9 00		      LDA	#0
     94  1006		       85 e6		      STA	p
     95  1008				   .
     96  1008							; 
     97  1008
     98  1008				   .L07 		;  pfscore2  =  %00101010
     99  1008
    100  1008		       a9 2a		      LDA	#%00101010
    101  100a		       85 c2		      STA	pfscore2
    102  100c				   .
    103  100c							; 
    104  100c
    105  100c				   .
    106  100c							; 
    107  100c
    108  100c				   .L08 		;  dim inv_x  =  a  :	a  =  84
    109  100c
    110  100c		       a9 54		      LDA	#84
    111  100e		       85 d7		      STA	a
    112  1010				   .L09 		;  dim inv_y  =  b  :	b  =  76
    113  1010
    114  1010		       a9 4c		      LDA	#76
    115  1012		       85 d8		      STA	b
    116  1014				   .L010		;  dim inv_delay  =  c  :  c  =  0
    117  1014
    118  1014		       a9 00		      LDA	#0
    119  1016		       85 d9		      STA	c
    120  1018				   .L011		;  dim inv_dir  =  f  :  f  =	1
    121  1018
    122  1018		       a9 01		      LDA	#1
    123  101a		       85 dc		      STA	f
    124  101c				   .L012		;  dim inv_shot_x  =  g  :  g	=  inv_x
    125  101c
    126  101c		       a5 d7		      LDA	inv_x
    127  101e		       85 dd		      STA	g
    128  1020				   .L013		;  dim inv_shot_y  =  h  :  h	=  inv_y
    129  1020
    130  1020		       a5 d8		      LDA	inv_y
    131  1022		       85 de		      STA	h
    132  1024				   .L014		;  dim inv_fire_delay	=  k  :  k  =  0
    133  1024
    134  1024		       a9 00		      LDA	#0
    135  1026		       85 e1		      STA	k
    136  1028				   .L015		;  dim inv_fired  =  l  :  l  =  0
    137  1028
    138  1028		       a9 00		      LDA	#0
    139  102a		       85 e2		      STA	l
    140  102c				   .L016		;  dim inv_hit  =  n  :  n  =	0
    141  102c
    142  102c		       a9 00		      LDA	#0
    143  102e		       85 e4		      STA	n
    144  1030				   .L017		;  dim inv_blast_delay  =  o  :  o  =	0
    145  1030
    146  1030		       a9 00		      LDA	#0
    147  1032		       85 e5		      STA	o
    148  1034				   .
    149  1034							; 
    150  1034
    151  1034				   .
    152  1034							; 
    153  1034
    154  1034				   .L018		;  dim tur_x  =  d  :	d  =  84
    155  1034
    156  1034		       a9 54		      LDA	#84
    157  1036		       85 da		      STA	d
    158  1038				   .L019		;  dim tur_y  =  e  :	e  =  14
    159  1038
    160  1038		       a9 0e		      LDA	#14
    161  103a		       85 db		      STA	e
    162  103c				   .L020		;  dim shot_x	=  i  :  i  =  tur_x
    163  103c
    164  103c		       a5 da		      LDA	tur_x
    165  103e		       85 df		      STA	i
    166  1040				   .L021		;  dim shot_y	=  j  :  j  =  tur_y
    167  1040
    168  1040		       a5 db		      LDA	tur_y
    169  1042		       85 e0		      STA	j
    170  1044				   .L022		;  dim tur_fired  =  m  :  m  =  0
    171  1044
    172  1044		       a9 00		      LDA	#0
    173  1046		       85 e3		      STA	m
    174  1048				   .L023		;  dim tur_hit  =  q  :  q  =	0
    175  1048
    176  1048		       a9 00		      LDA	#0
    177  104a		       85 e7		      STA	q
    178  104c				   .L024		;  dim tur_anim_playing  =  r	:  r  =  0
    179  104c
    180  104c		       a9 00		      LDA	#0
    181  104e		       85 e8		      STA	r
    182  1050				   .L025		;  dim tur_anim_frame	=  s  :  s  =  0
    183  1050
    184  1050		       a9 00		      LDA	#0
    185  1052		       85 e9		      STA	s
    186  1054				   .
    187  1054							; 
    188  1054
    189  1054				   .
    190  1054							; 
    191  1054
    192  1054				   .
    193  1054							; 
    194  1054
    195  1054				   .
    196  1054							; 
    197  1054
    198  1054				   .
    199  1054							; 
    200  1054
    201  1054				   .main
    202  1054							; main
    203  1054
    204  1054				   .
    205  1054							; 
    206  1054
    207  1054				   .
    208  1054							; 
    209  1054
    210  1054				   .L026		;  AUDV0  =  0
    211  1054
    212  1054		       a9 00		      LDA	#0
    213  1056		       85 19		      STA	AUDV0
    214  1058				   .
    215  1058							; 
    216  1058
    217  1058				   .
    218  1058							; 
    219  1058
    220  1058				   .
    221  1058							; 
    222  1058
    223  1058				   .L027		;  if sound  <=  31 then sound  =  sound  +  1  :  AUDC0  =  8  :  AUDV0  =  4  :  AUDF0  =  sound  - 1
    224  1058
    225  1058		       a9 1f		      LDA	#31
    226  105a		       c5 ea		      CMP	sound
    227  105c		       90 11		      BCC	.skipL027
    228  105e				   .condpart0
    229  105e		       e6 ea		      INC	sound
    230  1060		       a9 08		      LDA	#8
    231  1062		       85 15		      STA	AUDC0
    232  1064		       a9 04		      LDA	#4
    233  1066		       85 19		      STA	AUDV0
    234  1068		       a5 ea		      LDA	sound
    235  106a		       38		      SEC
    236  106b		       e9 01		      SBC	#1
    237  106d		       85 17		      STA	AUDF0
    238  106f				   .skipL027
    239  106f				   .
    240  106f							; 
    241  106f
    242  106f				   .L028		;  if sound  >=  33  &&  sound  <=  64 then sound  =  sound  +  1  :  AUDC0  =  7  :  AUDV0  =  4  :  AUDF0  =  sound	- 34
    243  106f
    244  106f		       a5 ea		      LDA	sound
    245  1071		       c9 21		      CMP	#33
    246  1073		       90 17		      BCC	.skipL028
    247  1075				   .condpart1
    248  1075		       a9 40		      LDA	#64
    249  1077		       c5 ea		      CMP	sound
    250  1079		       90 11		      BCC	.skip1then
    251  107b				   .condpart2
    252  107b		       e6 ea		      INC	sound
    253  107d		       a9 07		      LDA	#7
    254  107f		       85 15		      STA	AUDC0
    255  1081		       a9 04		      LDA	#4
    256  1083		       85 19		      STA	AUDV0
    257  1085		       a5 ea		      LDA	sound
    258  1087		       38		      SEC
    259  1088		       e9 22		      SBC	#34
    260  108a		       85 17		      STA	AUDF0
    261  108c				   .skip1then
    262  108c				   .skipL028
    263  108c				   .
    264  108c							; 
    265  108c
    266  108c				   .L029		;  if sound  >=  66  &&  sound  <=  97 then sound  =  sound  +  1  :  AUDC0  =  2  :  AUDV0  =  4  :  AUDF0  =  sound	- 67
    267  108c
    268  108c		       a5 ea		      LDA	sound
    269  108e		       c9 42		      CMP	#66
    270  1090		       90 17		      BCC	.skipL029
    271  1092				   .condpart3
    272  1092		       a9 61		      LDA	#97
    273  1094		       c5 ea		      CMP	sound
    274  1096		       90 11		      BCC	.skip3then
    275  1098				   .condpart4
    276  1098		       e6 ea		      INC	sound
    277  109a		       a9 02		      LDA	#2
    278  109c		       85 15		      STA	AUDC0
    279  109e		       a9 04		      LDA	#4
    280  10a0		       85 19		      STA	AUDV0
    281  10a2		       a5 ea		      LDA	sound
    282  10a4		       38		      SEC
    283  10a5		       e9 43		      SBC	#67
    284  10a7		       85 17		      STA	AUDF0
    285  10a9				   .skip3then
    286  10a9				   .skipL029
    287  10a9				   .
    288  10a9							; 
    289  10a9
    290  10a9				   .
    291  10a9							; 
    292  10a9
    293  10a9				   .
    294  10a9							; 
    295  10a9
    296  10a9				   .
    297  10a9							; 
    298  10a9
    299  10a9				   .
    300  10a9							; 
    301  10a9
    302  10a9				   .
    303  10a9							; 
    304  10a9
    305  10a9				   .
    306  10a9							; 
    307  10a9
    308  10a9				   .L030		;  if !joy0fire  &&  !joy0up  &&  !joy0down  &&  !joy0left  &&  !joy0right then u{3}  =  1
    309  10a9
    310  10a9		       24 0c		      bit	INPT4
    311  10ab		       10 1e		      BPL	.skipL030
    312  10ad				   .condpart5
    313  10ad		       a9 10		      lda	#$10
    314  10af		       2c 80 02 	      bit	SWCHA
    315  10b2		       f0 17		      BEQ	.skip5then
    316  10b4				   .condpart6
    317  10b4		       a9 20		      lda	#$20
    318  10b6		       2c 80 02 	      bit	SWCHA
    319  10b9		       f0 10		      BEQ	.skip6then
    320  10bb				   .condpart7
    321  10bb		       2c 80 02 	      bit	SWCHA
    322  10be		       50 0b		      BVC	.skip7then
    323  10c0				   .condpart8
    324  10c0		       2c 80 02 	      bit	SWCHA
    325  10c3		       10 06		      BPL	.skip8then
    326  10c5				   .condpart9
    327  10c5		       a5 eb		      LDA	u
    328  10c7		       09 08		      ORA	#8
    329  10c9		       85 eb		      STA	u
    330  10cb				   .skip8then
    331  10cb				   .skip7then
    332  10cb				   .skip6then
    333  10cb				   .skip5then
    334  10cb				   .skipL030
    335  10cb				   .
    336  10cb							; 
    337  10cb
    338  10cb				   .
    339  10cb							; 
    340  10cb
    341  10cb				   .L031		;  if tur_hit	=  0 then gosub draw__move_turret
    342  10cb
    343  10cb		       a5 e7		      LDA	tur_hit
    344  10cd		       c9 00		      CMP	#0
    345  10cf		       d0 03		      BNE	.skipL031
    346  10d1				   .condpart10
    347  10d1		       20 2e d3 	      jsr	.draw__move_turret
    348  10d4
    349  10d4				   .skipL031
    350  10d4				   .L032		;  if tur_hit	=  0 then gosub draw__move_turret_shot
    351  10d4
    352  10d4		       a5 e7		      LDA	tur_hit
    353  10d6		       c9 00		      CMP	#0
    354  10d8		       d0 03		      BNE	.skipL032
    355  10da				   .condpart11
    356  10da		       20 73 d3 	      jsr	.draw__move_turret_shot
    357  10dd
    358  10dd				   .skipL032
    359  10dd				   .L033		;  gosub draw__move_invader
    360  10dd
    361  10dd		       20 1e d1 	      jsr	.draw__move_invader
    362  10e0
    363  10e0				   .L034		;  gosub draw__move_inv_shot
    364  10e0
    365  10e0		       20 f0 d1 	      jsr	.draw__move_inv_shot
    366  10e3
    367  10e3				   .L035		;  gosub col_shot_inv
    368  10e3
    369  10e3		       20 6f d2 	      jsr	.col_shot_inv
    370  10e6
    371  10e6				   .L036		;  gosub col_inv_shot_turret
    372  10e6
    373  10e6		       20 e8 d3 	      jsr	.col_inv_shot_turret
    374  10e9
    375  10e9				   .L037		;  if tur_hit	=  1 then gosub play_tur_anim
    376  10e9
    377  10e9		       a5 e7		      LDA	tur_hit
    378  10eb		       c9 01		      CMP	#1
    379  10ed		       d0 03		      BNE	.skipL037
    380  10ef				   .condpart12
    381  10ef		       20 28 d4 	      jsr	.play_tur_anim
    382  10f2
    383  10f2				   .skipL037
    384  10f2				   .
    385  10f2							; 
    386  10f2
    387  10f2				   .L038		;  if pfscore2  <  2 then goto game_over
    388  10f2
    389  10f2		       a5 c2		      LDA	pfscore2
    390  10f4		       c9 02		      CMP	#2
    391  10f6		       b0 03		      BCS	.skipL038
    392  10f8				   .condpart13
    393  10f8		       4c bd d4 	      jmp	.game_over
    394  10fb
    395  10fb				   .skipL038
    396  10fb				   .
    397  10fb							; 
    398  10fb
    399  10fb				   .
    400  10fb							; 
    401  10fb
    402  10fb				   .L039		;  pfscorecolor  =  196
    403  10fb
    404  10fb		       a9 c4		      LDA	#196
    405  10fd		       85 c0		      STA	pfscorecolor
    406  10ff				   .
    407  10ff							; 
    408  10ff
    409  10ff				   .
    410  10ff							; 
    411  10ff
    412  10ff				   .L040		;  scorecolor	=  152
    413  10ff
    414  10ff		       a9 98		      LDA	#152
    415  1101		       85 d5		      STA	scorecolor
    416  1103				   .
    417  1103							; 
    418  1103
    419  1103				   .
    420  1103							; 
    421  1103
    422  1103				   .L041		;  drawscreen
    423  1103
    424  1103		       85 d1		      sta	temp7
    425  1105		       a9 d1		      lda	#>(ret_point1-1)
    426  1107		       48		      pha
    427  1108		       a9 1a		      lda	#<(ret_point1-1)
    428  110a		       48		      pha
    429  110b		       a9 f0		      lda	#>(drawscreen-1)
    430  110d		       48		      pha
    431  110e		       a9 39		      lda	#<(drawscreen-1)
    432  1110		       48		      pha
    433  1111		       a5 d1		      lda	temp7
    434  1113		       48		      pha
    435  1114		       8a		      txa
    436  1115		       48		      pha
    437  1116		       a2 02		      ldx	#2
    438  1118		       4c eb ff 	      jmp	BS_jsr
    439  111b				   ret_point1
    440  111b				   .
    441  111b							; 
    442  111b
    443  111b				   .L042		;  goto main
    444  111b
    445  111b		       4c 54 d0 	      jmp	.main
    446  111e
    447  111e				   .
    448  111e							; 
    449  111e
    450  111e				   .
    451  111e							; 
    452  111e
    453  111e				   .
    454  111e							; 
    455  111e
    456  111e				   .
    457  111e							; 
    458  111e
    459  111e				   .
    460  111e							; 
    461  111e
    462  111e				   .
    463  111e							; 
    464  111e
    465  111e				   .
    466  111e							; 
    467  111e
    468  111e				   .draw__move_invader
    469  111e							; draw__move_invader
    470  111e
    471  111e				   .
    472  111e							; 
    473  111e
    474  111e				   .L043		;  inv_delay  =  inv_delay  +	1
    475  111e
    476  111e		       e6 d9		      INC	inv_delay
    477  1120				   .
    478  1120							; 
    479  1120
    480  1120				   .
    481  1120							; 
    482  1120
    483  1120				   .L044		;  if inv_delay  =  15  &&  inv_hit  =  0 then player0:  
    484  1120
    485  1120		       a5 d9		      LDA	inv_delay
    486  1122		       c9 0f		      CMP	#15
    487  1124		       d0 12		      BNE	.skipL044
    488  1126				   .condpart14
    489  1126		       a5 e4		      LDA	inv_hit
    490  1128		       c9 00		      CMP	#0
    491  112a		       d0 0c		      BNE	.skip14then
    492  112c				   .condpart15
    493  112c		       a2 5a		      LDX	#<player15then_0
    494  112e		       86 a2		      STX	player0pointerlo
    495  1130		       a9 f4		      LDA	#>player15then_0
    496  1132		       85 a3		      STA	player0pointerhi
    497  1134		       a9 09		      LDA	#9
    498  1136		       85 b0		      STA	player0height
    499  1138				   .skip14then
    500  1138				   .skipL044
    501  1138				   .
    502  1138							; 
    503  1138
    504  1138				   .
    505  1138							; 
    506  1138
    507  1138				   .L045		;  if inv_delay  =  30  &&  inv_hit  =  0 then player0:  
    508  1138
    509  1138		       a5 d9		      LDA	inv_delay
    510  113a		       c9 1e		      CMP	#30
    511  113c		       d0 12		      BNE	.skipL045
    512  113e				   .condpart16
    513  113e		       a5 e4		      LDA	inv_hit
    514  1140		       c9 00		      CMP	#0
    515  1142		       d0 0c		      BNE	.skip16then
    516  1144				   .condpart17
    517  1144		       a2 63		      LDX	#<player17then_0
    518  1146		       86 a2		      STX	player0pointerlo
    519  1148		       a9 f4		      LDA	#>player17then_0
    520  114a		       85 a3		      STA	player0pointerhi
    521  114c		       a9 09		      LDA	#9
    522  114e		       85 b0		      STA	player0height
    523  1150				   .skip16then
    524  1150				   .skipL045
    525  1150				   .
    526  1150							; 
    527  1150
    528  1150				   .L046		;  if inv_delay  >  30 then inv_delay	=  0
    529  1150
    530  1150		       a9 1e		      LDA	#30
    531  1152		       c5 d9		      CMP	inv_delay
    532  1154		       b0 04		      BCS	.skipL046
    533  1156				   .condpart18
    534  1156		       a9 00		      LDA	#0
    535  1158		       85 d9		      STA	inv_delay
    536  115a				   .skipL046
    537  115a				   .
    538  115a							; 
    539  115a
    540  115a				   .
    541  115a							; 
    542  115a
    543  115a				   .L047		;  COLUP0  =  52
    544  115a
    545  115a		       a9 34		      LDA	#52
    546  115c		       85 06		      STA	COLUP0
    547  115e				   .
    548  115e							; 
    549  115e
    550  115e				   .
    551  115e							; 
    552  115e
    553  115e				   .L048		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  15 then inv_x  =  inv_x  +  1
    554  115e
    555  115e		       a5 e4		      LDA	inv_hit
    556  1160		       c9 00		      CMP	#0
    557  1162		       d0 0e		      BNE	.skipL048
    558  1164				   .condpart19
    559  1164		       a5 dc		      LDA	inv_dir
    560  1166		       c9 01		      CMP	#1
    561  1168		       d0 08		      BNE	.skip19then
    562  116a				   .condpart20
    563  116a		       a5 d9		      LDA	inv_delay
    564  116c		       c9 0f		      CMP	#15
    565  116e		       d0 02		      BNE	.skip20then
    566  1170				   .condpart21
    567  1170		       e6 d7		      INC	inv_x
    568  1172				   .skip20then
    569  1172				   .skip19then
    570  1172				   .skipL048
    571  1172				   .L049		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  30 then inv_x  =  inv_x  +  1
    572  1172
    573  1172		       a5 e4		      LDA	inv_hit
    574  1174		       c9 00		      CMP	#0
    575  1176		       d0 0e		      BNE	.skipL049
    576  1178				   .condpart22
    577  1178		       a5 dc		      LDA	inv_dir
    578  117a		       c9 01		      CMP	#1
    579  117c		       d0 08		      BNE	.skip22then
    580  117e				   .condpart23
    581  117e		       a5 d9		      LDA	inv_delay
    582  1180		       c9 1e		      CMP	#30
    583  1182		       d0 02		      BNE	.skip23then
    584  1184				   .condpart24
    585  1184		       e6 d7		      INC	inv_x
    586  1186				   .skip23then
    587  1186				   .skip22then
    588  1186				   .skipL049
    589  1186				   .
    590  1186							; 
    591  1186
    592  1186				   .L050		;  if inv_x  >  143 then inv_dir  =  0  :  inv_x  =  143  :  inv_y  =	inv_y  -  5
    593  1186
    594  1186		       a9 8f		      LDA	#143
    595  1188		       c5 d7		      CMP	inv_x
    596  118a		       b0 0f		      BCS	.skipL050
    597  118c				   .condpart25
    598  118c		       a9 00		      LDA	#0
    599  118e		       85 dc		      STA	inv_dir
    600  1190		       a9 8f		      LDA	#143
    601  1192		       85 d7		      STA	inv_x
    602  1194		       a5 d8		      LDA	inv_y
    603  1196		       38		      SEC
    604  1197		       e9 05		      SBC	#5
    605  1199		       85 d8		      STA	inv_y
    606  119b				   .skipL050
    607  119b				   .
    608  119b							; 
    609  119b
    610  119b				   .
    611  119b							; 
    612  119b
    613  119b				   .L051		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  15 then inv_x  =  inv_x  -  1
    614  119b
    615  119b		       a5 e4		      LDA	inv_hit
    616  119d		       c9 00		      CMP	#0
    617  119f		       d0 0e		      BNE	.skipL051
    618  11a1				   .condpart26
    619  11a1		       a5 dc		      LDA	inv_dir
    620  11a3		       c9 00		      CMP	#0
    621  11a5		       d0 08		      BNE	.skip26then
    622  11a7				   .condpart27
    623  11a7		       a5 d9		      LDA	inv_delay
    624  11a9		       c9 0f		      CMP	#15
    625  11ab		       d0 02		      BNE	.skip27then
    626  11ad				   .condpart28
    627  11ad		       c6 d7		      DEC	inv_x
    628  11af				   .skip27then
    629  11af				   .skip26then
    630  11af				   .skipL051
    631  11af				   .L052		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  30 then inv_x  =  inv_x  -  1
    632  11af
    633  11af		       a5 e4		      LDA	inv_hit
    634  11b1		       c9 00		      CMP	#0
    635  11b3		       d0 0e		      BNE	.skipL052
    636  11b5				   .condpart29
    637  11b5		       a5 dc		      LDA	inv_dir
    638  11b7		       c9 00		      CMP	#0
    639  11b9		       d0 08		      BNE	.skip29then
    640  11bb				   .condpart30
    641  11bb		       a5 d9		      LDA	inv_delay
    642  11bd		       c9 1e		      CMP	#30
    643  11bf		       d0 02		      BNE	.skip30then
    644  11c1				   .condpart31
    645  11c1		       c6 d7		      DEC	inv_x
    646  11c3				   .skip30then
    647  11c3				   .skip29then
    648  11c3				   .skipL052
    649  11c3				   .
    650  11c3							; 
    651  11c3
    652  11c3				   .L053		;  if inv_x  <  26 then inv_dir  =  1	:  inv_x  =  26  :  inv_y  =  inv_y  -	5
    653  11c3
    654  11c3		       a5 d7		      LDA	inv_x
    655  11c5		       c9 1a		      CMP	#26
    656  11c7		       b0 0f		      BCS	.skipL053
    657  11c9				   .condpart32
    658  11c9		       a9 01		      LDA	#1
    659  11cb		       85 dc		      STA	inv_dir
    660  11cd		       a9 1a		      LDA	#26
    661  11cf		       85 d7		      STA	inv_x
    662  11d1		       a5 d8		      LDA	inv_y
    663  11d3		       38		      SEC
    664  11d4		       e9 05		      SBC	#5
    665  11d6		       85 d8		      STA	inv_y
    666  11d8				   .skipL053
    667  11d8				   .
    668  11d8							; 
    669  11d8
    670  11d8				   .
    671  11d8							; 
    672  11d8
    673  11d8				   .L054		;  player0x  =  inv_x	-  8  :  player0y  =  inv_y
    674  11d8
    675  11d8		       a5 d7		      LDA	inv_x
    676  11da		       38		      SEC
    677  11db		       e9 08		      SBC	#8
    678  11dd		       85 84		      STA	player0x
    679  11df		       a5 d8		      LDA	inv_y
    680  11e1		       85 8d		      STA	player0y
    681  11e3				   .L055		;  return
    682  11e3
    683  11e3		       ba		      tsx
    684  11e4		       b5 02		      lda	2,x	; check return address
    685  11e6		       49 d1		      eor	#(>*)	; vs. current PCH
    686  11e8		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    687  11ea		       f0 03		      beq	*+5	; if equal, do normal return
    688  11ec		       4c dd ff 	      JMP	BS_return
    689  11ef		       60		      RTS
    690  11f0				   .
    691  11f0							; 
    692  11f0
    693  11f0				   .
    694  11f0							; 
    695  11f0
    696  11f0				   .
    697  11f0							; 
    698  11f0
    699  11f0				   .
    700  11f0							; 
    701  11f0
    702  11f0				   .draw__move_inv_shot
    703  11f0							; draw__move_inv_shot
    704  11f0
    705  11f0				   .
    706  11f0							; 
    707  11f0
    708  11f0				   .L056		;  player2:
    709  11f0
    710  11f0		       a2 6c		      LDX	#<playerL056_2
    711  11f2		       86 a7		      STX	player2pointerlo
    712  11f4		       a9 f4		      LDA	#>playerL056_2
    713  11f6		       85 ac		      STA	player2pointerhi
    714  11f8		       a9 09		      LDA	#9
    715  11fa		       85 b2		      STA	player2height
    716  11fc				   .
    717  11fc							; 
    718  11fc
    719  11fc				   .L057		;  COLUP2  =  14
    720  11fc
    721  11fc		       a9 0e		      LDA	#14
    722  11fe		       85 99		      STA	COLUP2
    723  1200				   .
    724  1200							; 
    725  1200
    726  1200				   .L058		;  inv_fire_delay  =  inv_fire_delay  +  1
    727  1200
    728  1200		       e6 e1		      INC	inv_fire_delay
    729  1202				   .
    730  1202							; 
    731  1202
    732  1202				   .L059		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_shot_x  =  inv_x  :  inv_shot_y  =	inv_y  -  9
    733  1202
    734  1202		       a5 e2		      LDA	inv_fired
    735  1204		       c9 00		      CMP	#0
    736  1206		       d0 11		      BNE	.skipL059
    737  1208				   .condpart33
    738  1208		       a5 e1		      LDA	inv_fire_delay
    739  120a		       c9 b4		      CMP	#180
    740  120c		       d0 0b		      BNE	.skip33then
    741  120e				   .condpart34
    742  120e		       a5 d7		      LDA	inv_x
    743  1210		       85 dd		      STA	inv_shot_x
    744  1212		       a5 d8		      LDA	inv_y
    745  1214		       38		      SEC
    746  1215		       e9 09		      SBC	#9
    747  1217		       85 de		      STA	inv_shot_y
    748  1219				   .skip33then
    749  1219				   .skipL059
    750  1219				   .L060		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then player2x  =  inv_shot_x  :  player2y  =  inv_shot_y
    751  1219
    752  1219		       a5 e2		      LDA	inv_fired
    753  121b		       c9 00		      CMP	#0
    754  121d		       d0 0e		      BNE	.skipL060
    755  121f				   .condpart35
    756  121f		       a5 e1		      LDA	inv_fire_delay
    757  1221		       c9 b4		      CMP	#180
    758  1223		       d0 08		      BNE	.skip35then
    759  1225				   .condpart36
    760  1225		       a5 dd		      LDA	inv_shot_x
    761  1227		       85 86		      STA	player2x
    762  1229		       a5 de		      LDA	inv_shot_y
    763  122b		       85 8f		      STA	player2y
    764  122d				   .skip35then
    765  122d				   .skipL060
    766  122d				   .L061		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_fired  =  1
    767  122d
    768  122d		       a5 e2		      LDA	inv_fired
    769  122f		       c9 00		      CMP	#0
    770  1231		       d0 0a		      BNE	.skipL061
    771  1233				   .condpart37
    772  1233		       a5 e1		      LDA	inv_fire_delay
    773  1235		       c9 b4		      CMP	#180
    774  1237		       d0 04		      BNE	.skip37then
    775  1239				   .condpart38
    776  1239		       a9 01		      LDA	#1
    777  123b		       85 e2		      STA	inv_fired
    778  123d				   .skip37then
    779  123d				   .skipL061
    780  123d				   .
    781  123d							; 
    782  123d
    783  123d				   .L062		;  if inv_fired  =  1 then inv_shot_y	=  inv_shot_y  -  2  :	player2y  =  inv_shot_y
    784  123d
    785  123d		       a5 e2		      LDA	inv_fired
    786  123f		       c9 01		      CMP	#1
    787  1241		       d0 0b		      BNE	.skipL062
    788  1243				   .condpart39
    789  1243		       a5 de		      LDA	inv_shot_y
    790  1245		       38		      SEC
    791  1246		       e9 02		      SBC	#2
    792  1248		       85 de		      STA	inv_shot_y
    793  124a		       a5 de		      LDA	inv_shot_y
    794  124c		       85 8f		      STA	player2y
    795  124e				   .skipL062
    796  124e				   .
    797  124e							; 
    798  124e
    799  124e				   .L063		;  if inv_shot_y  <  12 then inv_fired  =  0  :  inv_fire_delay  =  0	:  inv_shot_y  =  88  :  player2y  =  inv_shot_y
    800  124e
    801  124e		       a5 de		      LDA	inv_shot_y
    802  1250		       c9 0c		      CMP	#12
    803  1252		       b0 0e		      BCS	.skipL063
    804  1254				   .condpart40
    805  1254		       a9 00		      LDA	#0
    806  1256		       85 e2		      STA	inv_fired
    807  1258		       85 e1		      STA	inv_fire_delay
    808  125a		       a9 58		      LDA	#88
    809  125c		       85 de		      STA	inv_shot_y
    810  125e		       a5 de		      LDA	inv_shot_y
    811  1260		       85 8f		      STA	player2y
    812  1262				   .skipL063
    813  1262				   .
    814  1262							; 
    815  1262
    816  1262				   .L064		;  return
    817  1262
    818  1262		       ba		      tsx
    819  1263		       b5 02		      lda	2,x	; check return address
    820  1265		       49 d2		      eor	#(>*)	; vs. current PCH
    821  1267		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    822  1269		       f0 03		      beq	*+5	; if equal, do normal return
    823  126b		       4c dd ff 	      JMP	BS_return
    824  126e		       60		      RTS
    825  126f				   .
    826  126f							; 
    827  126f
    828  126f				   .
    829  126f							; 
    830  126f
    831  126f				   .
    832  126f							; 
    833  126f
    834  126f				   .
    835  126f							; 
    836  126f
    837  126f				   .col_shot_inv
    838  126f							; col_shot_inv
    839  126f
    840  126f				   .L065		;  if shot_x  +  3  >=  inv_x	&&  shot_x  +  3  <=  inv_x  +	6  &&  shot_y  >  inv_y  &&  u{3} then inv_hit	=  1  :  b{3}  =  0  :	sound  =  0
    841  126f
    842  126f							; complex condition detected
    843  126f		       a5 df		      LDA	shot_x
    844  1271		       18		      CLC
    845  1272		       69 03		      ADC	#3
    846  1274							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
    847  1274		       c5 d7		      CMP	inv_x
    848  1276		       90 2d		      BCC	.skipL065
    849  1278				   .condpart41
    850  1278							; complex condition detected
    851  1278		       a5 d7		      LDA	inv_x
    852  127a		       18		      CLC
    853  127b		       69 06		      ADC	#6
    854  127d		       48		      PHA
    855  127e		       a5 df		      LDA	shot_x
    856  1280		       18		      CLC
    857  1281		       69 03		      ADC	#3
    858  1283		       48		      PHA
    859  1284		       ba		      TSX
    860  1285		       68		      PLA
    861  1286		       68		      PLA
    862  1287							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
    863  1287		       d5 01		      CMP	1,x
    864  1289		       90 1a		      BCC	.skip41then
    865  128b				   .condpart42
    866  128b		       a5 d8		      LDA	inv_y
    867  128d		       c5 e0		      CMP	shot_y
    868  128f		       b0 14		      BCS	.skip42then
    869  1291				   .condpart43
    870  1291		       a5 eb		      LDA	u
    871  1293		       29 08		      AND	#8
    872  1295		       f0 0e		      BEQ	.skip43then
    873  1297				   .condpart44
    874  1297		       a9 01		      LDA	#1
    875  1299		       85 e4		      STA	inv_hit
    876  129b		       a5 d8		      LDA	b
    877  129d		       29 f7		      AND	#247
    878  129f		       85 d8		      STA	b
    879  12a1		       a9 00		      LDA	#0
    880  12a3		       85 ea		      STA	sound
    881  12a5				   .skip43then
    882  12a5				   .skip42then
    883  12a5				   .skip41then
    884  12a5				   .skipL065
    885  12a5				   .
    886  12a5							; 
    887  12a5
    888  12a5				   .L066		;  if inv_hit	=  1 then inv_blast_delay  =  inv_blast_delay  +  1
    889  12a5
    890  12a5		       a5 e4		      LDA	inv_hit
    891  12a7		       c9 01		      CMP	#1
    892  12a9		       d0 02		      BNE	.skipL066
    893  12ab				   .condpart45
    894  12ab		       e6 e5		      INC	inv_blast_delay
    895  12ad				   .skipL066
    896  12ad				   .
    897  12ad							; 
    898  12ad
    899  12ad				   .L067		;  if inv_blast_delay	>  40 then score  =  score  +  10  :  inv_hit  =  0  :	gosub reset_blast
    900  12ad
    901  12ad		       a9 28		      LDA	#40
    902  12af		       c5 e5		      CMP	inv_blast_delay
    903  12b1		       b0 1c		      BCS	.skipL067
    904  12b3				   .condpart46
    905  12b3		       f8		      SED
    906  12b4		       18		      CLC
    907  12b5		       a5 d4		      LDA	score+2
    908  12b7		       69 10		      ADC	#$10
    909  12b9		       85 d4		      STA	score+2
    910  12bb		       a5 d3		      LDA	score+1
    911  12bd		       69 00		      ADC	#$00
    912  12bf		       85 d3		      STA	score+1
    913  12c1		       a5 d2		      LDA	score
    914  12c3		       69 00		      ADC	#$00
    915  12c5		       85 d2		      STA	score
    916  12c7		       d8		      CLD
    917  12c8		       a9 00		      LDA	#0
    918  12ca		       85 e4		      STA	inv_hit
    919  12cc		       20 ee d2 	      jsr	.reset_blast
    920  12cf
    921  12cf				   .skipL067
    922  12cf				   .
    923  12cf							; 
    924  12cf
    925  12cf				   .L068		;  if inv_hit	=  1 then player0:  
    926  12cf
    927  12cf		       a5 e4		      LDA	inv_hit
    928  12d1		       c9 01		      CMP	#1
    929  12d3		       d0 0c		      BNE	.skipL068
    930  12d5				   .condpart47
    931  12d5		       a2 74		      LDX	#<player47then_0
    932  12d7		       86 a2		      STX	player0pointerlo
    933  12d9		       a9 f4		      LDA	#>player47then_0
    934  12db		       85 a3		      STA	player0pointerhi
    935  12dd		       a9 09		      LDA	#9
    936  12df		       85 b0		      STA	player0height
    937  12e1				   .skipL068
    938  12e1				   .
    939  12e1							; 
    940  12e1
    941  12e1				   .L069		;  return
    942  12e1
    943  12e1		       ba		      tsx
    944  12e2		       b5 02		      lda	2,x	; check return address
    945  12e4		       49 d2		      eor	#(>*)	; vs. current PCH
    946  12e6		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    947  12e8		       f0 03		      beq	*+5	; if equal, do normal return
    948  12ea		       4c dd ff 	      JMP	BS_return
    949  12ed		       60		      RTS
    950  12ee				   .
    951  12ee							; 
    952  12ee
    953  12ee				   .
    954  12ee							; 
    955  12ee
    956  12ee				   .
    957  12ee							; 
    958  12ee
    959  12ee				   .
    960  12ee							; 
    961  12ee
    962  12ee				   .reset_blast
    963  12ee							; reset_blast
    964  12ee
    965  12ee				   .L070		;  player0:  
    966  12ee
    967  12ee		       a2 7d		      LDX	#<playerL070_0
    968  12f0		       86 a2		      STX	player0pointerlo
    969  12f2		       a9 f4		      LDA	#>playerL070_0
    970  12f4		       85 a3		      STA	player0pointerhi
    971  12f6		       a9 09		      LDA	#9
    972  12f8		       85 b0		      STA	player0height
    973  12fa				   .
    974  12fa							; 
    975  12fa
    976  12fa				   .
    977  12fa							; 
    978  12fa
    979  12fa				   .L071		;  inv_blast_delay  =	0  :  inv_x  =	 ( rand & 117 )   +  26  :  inv_y  =  76
    980  12fa
    981  12fa		       a9 00		      LDA	#0
    982  12fc		       85 e5		      STA	inv_blast_delay
    983  12fe							; complex statement detected
    984  12fe		       85 d1		      sta	temp7
    985  1300		       a9 d3		      lda	#>(ret_point2-1)
    986  1302		       48		      pha
    987  1303		       a9 15		      lda	#<(ret_point2-1)
    988  1305		       48		      pha
    989  1306		       a9 f4		      lda	#>(randomize-1)
    990  1308		       48		      pha
    991  1309		       a9 34		      lda	#<(randomize-1)
    992  130b		       48		      pha
    993  130c		       a5 d1		      lda	temp7
    994  130e		       48		      pha
    995  130f		       8a		      txa
    996  1310		       48		      pha
    997  1311		       a2 02		      ldx	#2
    998  1313		       4c eb ff 	      jmp	BS_jsr
    999  1316				   ret_point2
   1000  1316		       29 75		      AND	#117
   1001  1318		       18		      CLC
   1002  1319		       69 1a		      ADC	#26
   1003  131b		       85 d7		      STA	inv_x
   1004  131d		       a9 4c		      LDA	#76
   1005  131f		       85 d8		      STA	inv_y
   1006  1321				   .
   1007  1321							; 
   1008  1321
   1009  1321				   .L072		;  return
   1010  1321
   1011  1321		       ba		      tsx
   1012  1322		       b5 02		      lda	2,x	; check return address
   1013  1324		       49 d3		      eor	#(>*)	; vs. current PCH
   1014  1326		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1015  1328		       f0 03		      beq	*+5	; if equal, do normal return
   1016  132a		       4c dd ff 	      JMP	BS_return
   1017  132d		       60		      RTS
   1018  132e				   .
   1019  132e							; 
   1020  132e
   1021  132e				   .
   1022  132e							; 
   1023  132e
   1024  132e				   .
   1025  132e							; 
   1026  132e
   1027  132e				   .
   1028  132e							; 
   1029  132e
   1030  132e				   .draw__move_turret
   1031  132e							; draw__move_turret
   1032  132e
   1033  132e				   .L073		;  player1:
   1034  132e
   1035  132e		       a2 86		      LDX	#<playerL073_1
   1036  1330		       86 a6		      STX	player1pointerlo
   1037  1332		       a9 f4		      LDA	#>playerL073_1
   1038  1334		       85 ab		      STA	player1pointerhi
   1039  1336		       a9 09		      LDA	#9
   1040  1338		       85 b1		      STA	player1height
   1041  133a				   .
   1042  133a							; 
   1043  133a
   1044  133a				   .
   1045  133a							; 
   1046  133a
   1047  133a				   .L074		;  _COLUP1  =	196
   1048  133a
   1049  133a		       a9 c4		      LDA	#196
   1050  133c		       85 98		      STA	_COLUP1
   1051  133e				   .
   1052  133e							; 
   1053  133e
   1054  133e				   .L075		;  if joy0left  &&  tur_x  >=	26 then tur_x  =  tur_x  -  1
   1055  133e
   1056  133e		       2c 80 02 	      bit	SWCHA
   1057  1341		       70 08		      BVS	.skipL075
   1058  1343				   .condpart48
   1059  1343		       a5 da		      LDA	tur_x
   1060  1345		       c9 1a		      CMP	#26
   1061  1347		       90 02		      BCC	.skip48then
   1062  1349				   .condpart49
   1063  1349		       c6 da		      DEC	tur_x
   1064  134b				   .skip48then
   1065  134b				   .skipL075
   1066  134b				   .L076		;  if joy0right  &&  tur_x  <=  143 then tur_x  =  tur_x  +  1
   1067  134b
   1068  134b		       2c 80 02 	      bit	SWCHA
   1069  134e		       30 08		      BMI	.skipL076
   1070  1350				   .condpart50
   1071  1350		       a9 8f		      LDA	#143
   1072  1352		       c5 da		      CMP	tur_x
   1073  1354		       90 02		      BCC	.skip50then
   1074  1356				   .condpart51
   1075  1356		       e6 da		      INC	tur_x
   1076  1358				   .skip50then
   1077  1358				   .skipL076
   1078  1358				   .
   1079  1358							; 
   1080  1358
   1081  1358				   .
   1082  1358							; 
   1083  1358
   1084  1358				   .
   1085  1358							; 
   1086  1358
   1087  1358				   .
   1088  1358							; 
   1089  1358
   1090  1358				   .L077		;  if tur_hit	=  0 then player1x  =  tur_x  :  player1y  =  tur_y
   1091  1358
   1092  1358		       a5 e7		      LDA	tur_hit
   1093  135a		       c9 00		      CMP	#0
   1094  135c		       d0 08		      BNE	.skipL077
   1095  135e				   .condpart52
   1096  135e		       a5 da		      LDA	tur_x
   1097  1360		       85 85		      STA	player1x
   1098  1362		       a5 db		      LDA	tur_y
   1099  1364		       85 8e		      STA	player1y
   1100  1366				   .skipL077
   1101  1366				   .
   1102  1366							; 
   1103  1366
   1104  1366				   .L078		;  return
   1105  1366
   1106  1366		       ba		      tsx
   1107  1367		       b5 02		      lda	2,x	; check return address
   1108  1369		       49 d3		      eor	#(>*)	; vs. current PCH
   1109  136b		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1110  136d		       f0 03		      beq	*+5	; if equal, do normal return
   1111  136f		       4c dd ff 	      JMP	BS_return
   1112  1372		       60		      RTS
   1113  1373				   .
   1114  1373							; 
   1115  1373
   1116  1373				   .
   1117  1373							; 
   1118  1373
   1119  1373				   .
   1120  1373							; 
   1121  1373
   1122  1373				   .
   1123  1373							; 
   1124  1373
   1125  1373				   .draw__move_turret_shot
   1126  1373							; draw__move_turret_shot
   1127  1373
   1128  1373				   .L079		;  player3:
   1129  1373
   1130  1373		       a2 8e		      LDX	#<playerL079_3
   1131  1375		       86 a8		      STX	player3pointerlo
   1132  1377		       a9 f4		      LDA	#>playerL079_3
   1133  1379		       85 ad		      STA	player3pointerhi
   1134  137b		       a9 09		      LDA	#9
   1135  137d		       85 b3		      STA	player3height
   1136  137f				   .
   1137  137f							; 
   1138  137f
   1139  137f				   .L080		;  COLUP3  =  14
   1140  137f
   1141  137f		       a9 0e		      LDA	#14
   1142  1381		       85 9a		      STA	COLUP3
   1143  1383				   .
   1144  1383							; 
   1145  1383
   1146  1383				   .L081		;  if joy0fire  &&  u{3}  &&  joy0fire then tur_fired	=  1  :  shot_x  =  tur_x  :  shot_y  =  tur_y	+  1  :  player3x  =  shot_x  :  player3y  =  shot_y  :  u{3}  =  0  :	sound  =  33
   1147  1383
   1148  1383		       24 0c		      bit	INPT4
   1149  1385		       30 2b		      BMI	.skipL081
   1150  1387				   .condpart53
   1151  1387		       a5 eb		      LDA	u
   1152  1389		       29 08		      AND	#8
   1153  138b		       f0 25		      BEQ	.skip53then
   1154  138d				   .condpart54
   1155  138d		       24 0c		      bit	INPT4
   1156  138f		       30 21		      BMI	.skip54then
   1157  1391				   .condpart55
   1158  1391		       a9 01		      LDA	#1
   1159  1393		       85 e3		      STA	tur_fired
   1160  1395		       a5 da		      LDA	tur_x
   1161  1397		       85 df		      STA	shot_x
   1162  1399		       a5 db		      LDA	tur_y
   1163  139b		       18		      CLC
   1164  139c		       69 01		      ADC	#1
   1165  139e		       85 e0		      STA	shot_y
   1166  13a0		       a5 df		      LDA	shot_x
   1167  13a2		       85 87		      STA	player3x
   1168  13a4		       a5 e0		      LDA	shot_y
   1169  13a6		       85 90		      STA	player3y
   1170  13a8		       a5 eb		      LDA	u
   1171  13aa		       29 f7		      AND	#247
   1172  13ac		       85 eb		      STA	u
   1173  13ae		       a9 21		      LDA	#33
   1174  13b0		       85 ea		      STA	sound
   1175  13b2				   .skip54then
   1176  13b2				   .skip53then
   1177  13b2				   .skipL081
   1178  13b2				   .
   1179  13b2							; 
   1180  13b2
   1181  13b2				   .L082		;  if tur_fired  =  1 then shot_y  =  shot_y  +  2  :	player3x  =  shot_x  :	player3y  =  shot_y
   1182  13b2
   1183  13b2		       a5 e3		      LDA	tur_fired
   1184  13b4		       c9 01		      CMP	#1
   1185  13b6		       d0 0f		      BNE	.skipL082
   1186  13b8				   .condpart56
   1187  13b8		       a5 e0		      LDA	shot_y
   1188  13ba		       18		      CLC
   1189  13bb		       69 02		      ADC	#2
   1190  13bd		       85 e0		      STA	shot_y
   1191  13bf		       a5 df		      LDA	shot_x
   1192  13c1		       85 87		      STA	player3x
   1193  13c3		       a5 e0		      LDA	shot_y
   1194  13c5		       85 90		      STA	player3y
   1195  13c7				   .skipL082
   1196  13c7				   .
   1197  13c7							; 
   1198  13c7
   1199  13c7				   .L083		;  if shot_y  >  77  &&  ! joy0fire then tur_fired  =	0  :  shot_y  =  0  :  player3y  =  shot_y
   1200  13c7
   1201  13c7		       a9 4d		      LDA	#77
   1202  13c9		       c5 e0		      CMP	shot_y
   1203  13cb		       b0 0e		      BCS	.skipL083
   1204  13cd				   .condpart57
   1205  13cd		       24 0c		      bit	INPT4
   1206  13cf		       10 0a		      BPL	.skip57then
   1207  13d1				   .condpart58
   1208  13d1		       a9 00		      LDA	#0
   1209  13d3		       85 e3		      STA	tur_fired
   1210  13d5		       85 e0		      STA	shot_y
   1211  13d7		       a5 e0		      LDA	shot_y
   1212  13d9		       85 90		      STA	player3y
   1213  13db				   .skip57then
   1214  13db				   .skipL083
   1215  13db				   .
   1216  13db							; 
   1217  13db
   1218  13db				   .L084		;  return
   1219  13db
   1220  13db		       ba		      tsx
   1221  13dc		       b5 02		      lda	2,x	; check return address
   1222  13de		       49 d3		      eor	#(>*)	; vs. current PCH
   1223  13e0		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1224  13e2		       f0 03		      beq	*+5	; if equal, do normal return
   1225  13e4		       4c dd ff 	      JMP	BS_return
   1226  13e7		       60		      RTS
   1227  13e8				   .
   1228  13e8							; 
   1229  13e8
   1230  13e8				   .
   1231  13e8							; 
   1232  13e8
   1233  13e8				   .
   1234  13e8							; 
   1235  13e8
   1236  13e8				   .
   1237  13e8							; 
   1238  13e8
   1239  13e8				   .col_inv_shot_turret
   1240  13e8							; col_inv_shot_turret
   1241  13e8
   1242  13e8				   .
   1243  13e8							; 
   1244  13e8
   1245  13e8				   .L085		;  if inv_shot_x  +  4  >=  tur_x  &&	inv_shot_x  +  2  <=  tur_x  +	6  &&  inv_shot_y  -  5  <  tur_y  - 5 then tur_hit  =	1
   1246  13e8
   1247  13e8							; complex condition detected
   1248  13e8		       a5 dd		      LDA	inv_shot_x
   1249  13ea		       18		      CLC
   1250  13eb		       69 04		      ADC	#4
   1251  13ed							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   1252  13ed		       c5 da		      CMP	tur_x
   1253  13ef		       90 2a		      BCC	.skipL085
   1254  13f1				   .condpart59
   1255  13f1							; complex condition detected
   1256  13f1		       a5 da		      LDA	tur_x
   1257  13f3		       18		      CLC
   1258  13f4		       69 06		      ADC	#6
   1259  13f6		       48		      PHA
   1260  13f7		       a5 dd		      LDA	inv_shot_x
   1261  13f9		       18		      CLC
   1262  13fa		       69 02		      ADC	#2
   1263  13fc		       48		      PHA
   1264  13fd		       ba		      TSX
   1265  13fe		       68		      PLA
   1266  13ff		       68		      PLA
   1267  1400							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
   1268  1400		       d5 01		      CMP	1,x
   1269  1402		       90 17		      BCC	.skip59then
   1270  1404				   .condpart60
   1271  1404							; complex condition detected
   1272  1404		       a5 de		      LDA	inv_shot_y
   1273  1406		       38		      SEC
   1274  1407		       e9 05		      SBC	#5
   1275  1409		       48		      PHA
   1276  140a		       a5 db		      LDA	tur_y
   1277  140c		       38		      SEC
   1278  140d		       e9 05		      SBC	#5
   1279  140f		       48		      PHA
   1280  1410		       ba		      TSX
   1281  1411		       68		      PLA
   1282  1412		       68		      PLA
   1283  1413		       d5 01		      CMP	1,x
   1284  1415		       b0 04		      BCS	.skip60then
   1285  1417				   .condpart61
   1286  1417		       a9 01		      LDA	#1
   1287  1419		       85 e7		      STA	tur_hit
   1288  141b				   .skip60then
   1289  141b				   .skip59then
   1290  141b				   .skipL085
   1291  141b				   .
   1292  141b							; 
   1293  141b
   1294  141b				   .L086		;  return
   1295  141b
   1296  141b		       ba		      tsx
   1297  141c		       b5 02		      lda	2,x	; check return address
   1298  141e		       49 d4		      eor	#(>*)	; vs. current PCH
   1299  1420		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1300  1422		       f0 03		      beq	*+5	; if equal, do normal return
   1301  1424		       4c dd ff 	      JMP	BS_return
   1302  1427		       60		      RTS
   1303  1428				   .
   1304  1428							; 
   1305  1428
   1306  1428				   .
   1307  1428							; 
   1308  1428
   1309  1428				   .
   1310  1428							; 
   1311  1428
   1312  1428				   .
   1313  1428							; 
   1314  1428
   1315  1428				   .play_tur_anim
   1316  1428							; play_tur_anim
   1317  1428
   1318  1428				   .
   1319  1428							; 
   1320  1428
   1321  1428				   .L087		;  tur_anim_frame  =  tur_anim_frame  +  1
   1322  1428
   1323  1428		       e6 e9		      INC	tur_anim_frame
   1324  142a				   .
   1325  142a							; 
   1326  142a
   1327  142a				   .L088		;  if tur_anim_frame  =  10 then player1:
   1328  142a
   1329  142a		       a5 e9		      LDA	tur_anim_frame
   1330  142c		       c9 0a		      CMP	#10
   1331  142e		       d0 0c		      BNE	.skipL088
   1332  1430				   .condpart62
   1333  1430		       a2 96		      LDX	#<player62then_1
   1334  1432		       86 a6		      STX	player1pointerlo
   1335  1434		       a9 f4		      LDA	#>player62then_1
   1336  1436		       85 ab		      STA	player1pointerhi
   1337  1438		       a9 09		      LDA	#9
   1338  143a		       85 b1		      STA	player1height
   1339  143c				   .skipL088
   1340  143c				   .
   1341  143c							; 
   1342  143c
   1343  143c				   .L089		;  if tur_anim_frame  =  20 then player1:
   1344  143c
   1345  143c		       a5 e9		      LDA	tur_anim_frame
   1346  143e		       c9 14		      CMP	#20
   1347  1440		       d0 0c		      BNE	.skipL089
   1348  1442				   .condpart63
   1349  1442		       a2 9e		      LDX	#<player63then_1
   1350  1444		       86 a6		      STX	player1pointerlo
   1351  1446		       a9 f4		      LDA	#>player63then_1
   1352  1448		       85 ab		      STA	player1pointerhi
   1353  144a		       a9 09		      LDA	#9
   1354  144c		       85 b1		      STA	player1height
   1355  144e				   .skipL089
   1356  144e				   .
   1357  144e							; 
   1358  144e
   1359  144e				   .L090		;  if tur_anim_frame  =  30 then player1:
   1360  144e
   1361  144e		       a5 e9		      LDA	tur_anim_frame
   1362  1450		       c9 1e		      CMP	#30
   1363  1452		       d0 0c		      BNE	.skipL090
   1364  1454				   .condpart64
   1365  1454		       a2 a6		      LDX	#<player64then_1
   1366  1456		       86 a6		      STX	player1pointerlo
   1367  1458		       a9 f4		      LDA	#>player64then_1
   1368  145a		       85 ab		      STA	player1pointerhi
   1369  145c		       a9 09		      LDA	#9
   1370  145e		       85 b1		      STA	player1height
   1371  1460				   .skipL090
   1372  1460				   .
   1373  1460							; 
   1374  1460
   1375  1460				   .L091		;  if tur_anim_frame  =  40 then player1:
   1376  1460
   1377  1460		       a5 e9		      LDA	tur_anim_frame
   1378  1462		       c9 28		      CMP	#40
   1379  1464		       d0 0c		      BNE	.skipL091
   1380  1466				   .condpart65
   1381  1466		       a2 ae		      LDX	#<player65then_1
   1382  1468		       86 a6		      STX	player1pointerlo
   1383  146a		       a9 f4		      LDA	#>player65then_1
   1384  146c		       85 ab		      STA	player1pointerhi
   1385  146e		       a9 09		      LDA	#9
   1386  1470		       85 b1		      STA	player1height
   1387  1472				   .skipL091
   1388  1472				   .
   1389  1472							; 
   1390  1472
   1391  1472				   .L092		;  if tur_anim_frame  =  50 then player1:
   1392  1472
   1393  1472		       a5 e9		      LDA	tur_anim_frame
   1394  1474		       c9 32		      CMP	#50
   1395  1476		       d0 0c		      BNE	.skipL092
   1396  1478				   .condpart66
   1397  1478		       a2 b6		      LDX	#<player66then_1
   1398  147a		       86 a6		      STX	player1pointerlo
   1399  147c		       a9 f4		      LDA	#>player66then_1
   1400  147e		       85 ab		      STA	player1pointerhi
   1401  1480		       a9 09		      LDA	#9
   1402  1482		       85 b1		      STA	player1height
   1403  1484				   .skipL092
   1404  1484				   .
   1405  1484							; 
   1406  1484
   1407  1484				   .L093		;  if tur_anim_frame  =  60 then player1:
   1408  1484
   1409  1484		       a5 e9		      LDA	tur_anim_frame
   1410  1486		       c9 3c		      CMP	#60
   1411  1488		       d0 0c		      BNE	.skipL093
   1412  148a				   .condpart67
   1413  148a		       a2 be		      LDX	#<player67then_1
   1414  148c		       86 a6		      STX	player1pointerlo
   1415  148e		       a9 f4		      LDA	#>player67then_1
   1416  1490		       85 ab		      STA	player1pointerhi
   1417  1492		       a9 09		      LDA	#9
   1418  1494		       85 b1		      STA	player1height
   1419  1496				   .skipL093
   1420  1496				   .
   1421  1496							; 
   1422  1496
   1423  1496				   .L094		;  if tur_anim_frame  =  60 then tur_anim_frame  =  0	:  tur_hit  =  0  :  pfscore2  =  pfscore2  /  4  :  tur_x  =  84  :  tur_y  =	14
   1424  1496
   1425  1496		       a5 e9		      LDA	tur_anim_frame
   1426  1498		       c9 3c		      CMP	#60
   1427  149a		       d0 14		      BNE	.skipL094
   1428  149c				   .condpart68
   1429  149c		       a9 00		      LDA	#0
   1430  149e		       85 e9		      STA	tur_anim_frame
   1431  14a0		       85 e7		      STA	tur_hit
   1432  14a2		       a5 c2		      LDA	pfscore2
   1433  14a4		       4a		      lsr
   1434  14a5		       4a		      lsr
   1435  14a6		       85 c2		      STA	pfscore2
   1436  14a8		       a9 54		      LDA	#84
   1437  14aa		       85 da		      STA	tur_x
   1438  14ac		       a9 0e		      LDA	#14
   1439  14ae		       85 db		      STA	tur_y
   1440  14b0				   .skipL094
   1441  14b0				   .
   1442  14b0							; 
   1443  14b0
   1444  14b0				   .L095		;  return
   1445  14b0
   1446  14b0		       ba		      tsx
   1447  14b1		       b5 02		      lda	2,x	; check return address
   1448  14b3		       49 d4		      eor	#(>*)	; vs. current PCH
   1449  14b5		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1450  14b7		       f0 03		      beq	*+5	; if equal, do normal return
   1451  14b9		       4c dd ff 	      JMP	BS_return
   1452  14bc		       60		      RTS
   1453  14bd				   .
   1454  14bd							; 
   1455  14bd
   1456  14bd				   .
   1457  14bd							; 
   1458  14bd
   1459  14bd				   .
   1460  14bd							; 
   1461  14bd
   1462  14bd				   .game_over
   1463  14bd							; game_over
   1464  14bd
   1465  14bd				   .
   1466  14bd							; 
   1467  14bd
   1468  14bd				   .L096		;  if joy0up then reboot
   1469  14bd
   1470  14bd		       a9 10		      lda	#$10
   1471  14bf		       2c 80 02 	      bit	SWCHA
   1472  14c2		       d0 03		      BNE	.skipL096
   1473  14c4				   .condpart69
   1474  14c4		       6c fc ff 	      JMP	($FFFC)
   1475  14c7				   .skipL096
   1476  14c7				   .
   1477  14c7							; 
   1478  14c7
   1479  14c7				   .L097		;  player2:
   1480  14c7
   1481  14c7		       a2 c6		      LDX	#<playerL097_2
   1482  14c9		       86 a7		      STX	player2pointerlo
   1483  14cb		       a9 f4		      LDA	#>playerL097_2
   1484  14cd		       85 ac		      STA	player2pointerhi
   1485  14cf		       a9 1a		      LDA	#26
   1486  14d1		       85 b2		      STA	player2height
   1487  14d3				   .
   1488  14d3							; 
   1489  14d3
   1490  14d3				   .L098		;  player3:
   1491  14d3
   1492  14d3		       a2 df		      LDX	#<playerL098_3
   1493  14d5		       86 a8		      STX	player3pointerlo
   1494  14d7		       a9 f4		      LDA	#>playerL098_3
   1495  14d9		       85 ad		      STA	player3pointerhi
   1496  14db		       a9 1a		      LDA	#26
   1497  14dd		       85 b3		      STA	player3height
   1498  14df				   .
   1499  14df							; 
   1500  14df
   1501  14df				   .L099		;  player0x  =  0  :  player0y  =  0
   1502  14df
   1503  14df		       a9 00		      LDA	#0
   1504  14e1		       85 84		      STA	player0x
   1505  14e3		       85 8d		      STA	player0y
   1506  14e5				   .L0100		;  player1x  =  0  :  player1y  =  0
   1507  14e5
   1508  14e5		       a9 00		      LDA	#0
   1509  14e7		       85 85		      STA	player1x
   1510  14e9		       85 8e		      STA	player1y
   1511  14eb				   .L0101		;  COLUP0  =  0
   1512  14eb
   1513  14eb		       a9 00		      LDA	#0
   1514  14ed		       85 06		      STA	COLUP0
   1515  14ef				   .L0102		;  COLUP1  =  0
   1516  14ef
   1517  14ef		       a9 00		      LDA	#0
   1518  14f1		       85 07		      STA	COLUP1
   1519  14f3				   .
   1520  14f3							; 
   1521  14f3
   1522  14f3				   .L0103		;  player2x  =  85  :	player2y  =  66
   1523  14f3
   1524  14f3		       a9 55		      LDA	#85
   1525  14f5		       85 86		      STA	player2x
   1526  14f7		       a9 42		      LDA	#66
   1527  14f9		       85 8f		      STA	player2y
   1528  14fb				   .L0104		;  player3x  =  85  :	player3y  =  39
   1529  14fb
   1530  14fb		       a9 55		      LDA	#85
   1531  14fd		       85 87		      STA	player3x
   1532  14ff		       a9 27		      LDA	#39
   1533  1501		       85 90		      STA	player3y
   1534  1503				   .
   1535  1503							; 
   1536  1503
   1537  1503				   .L0105		;  drawscreen
   1538  1503
   1539  1503		       85 d1		      sta	temp7
   1540  1505		       a9 d5		      lda	#>(ret_point3-1)
   1541  1507		       48		      pha
   1542  1508		       a9 1a		      lda	#<(ret_point3-1)
   1543  150a		       48		      pha
   1544  150b		       a9 f0		      lda	#>(drawscreen-1)
   1545  150d		       48		      pha
   1546  150e		       a9 39		      lda	#<(drawscreen-1)
   1547  1510		       48		      pha
   1548  1511		       a5 d1		      lda	temp7
   1549  1513		       48		      pha
   1550  1514		       8a		      txa
   1551  1515		       48		      pha
   1552  1516		       a2 02		      ldx	#2
   1553  1518		       4c eb ff 	      jmp	BS_jsr
   1554  151b				   ret_point3
   1555  151b				   .
   1556  151b							; 
   1557  151b
   1558  151b				   .L0106		;  goto game_over
   1559  151b
   1560  151b		       4c bd d4 	      jmp	.game_over
   1561  151e
   1562  151e					      if	ECHO1
      2742 bytes of ROM space left in bank 1
   1563  151e					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1564  151e					      endif
   1565  151e		       00 01	   ECHO1      =	1
   1566  1fd4					      ORG	$1FF4-bscode_length
   1567  1fd4					      RORG	$DFF4-bscode_length
   1568  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1569  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1570  1fd6				  -	      stx	FASTFETCH
   1571  1fd6					      endif
   1572  1fd6		       9a		      txs
   1573  1fd7				  -	      if	bankswitch == 64
   1574  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1575  1fd7					      else
   1576  1fd7		       a9 f3		      lda	#>(start-1)
   1577  1fd9					      endif
   1578  1fd9		       48		      pha
   1579  1fda		       a9 f7		      lda	#<(start-1)
   1580  1fdc		       48		      pha
   1581  1fdd		       48		      pha
   1582  1fde		       8a		      txa
   1583  1fdf		       48		      pha
   1584  1fe0		       ba		      tsx
   1585  1fe1					      if	bankswitch != 64
   1586  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1587  1fe3		       2a		      rol
   1588  1fe4		       2a		      rol
   1589  1fe5		       2a		      rol
   1590  1fe6		       2a		      rol
   1591  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1592  1fe9		       aa		      tax
   1593  1fea		       e8		      inx
   1594  1feb				  -	      else
   1595  1feb				  -	      lda	4,x	; get high byte of return address
   1596  1feb				  -	      tay
   1597  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1598  1feb				  -	      sta	4,x
   1599  1feb				  -	      tya
   1600  1feb				  -	      lsr
   1601  1feb				  -	      lsr
   1602  1feb				  -	      lsr
   1603  1feb				  -	      lsr
   1604  1feb				  -	      tax
   1605  1feb				  -	      inx
   1606  1feb					      endif
   1607  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1608  1fee		       68		      pla
   1609  1fef		       aa		      tax
   1610  1ff0		       68		      pla
   1611  1ff1		       60		      rts
   1612  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1613  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1614  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1615  1ff2					      endif
   1616  1ffc					      ORG	$1FFC
   1617  1ffc					      RORG	$DFFC
   1618  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
   1619  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
   1620  2000					      ORG	$2000
   1621  2000					      RORG	$F000
   1622  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1623  2000
   1624  2000				   FineAdjustTableBegin
   1625  2000		       60		      .byte.b	%01100000	;left 6
   1626  2001		       50		      .byte.b	%01010000
   1627  2002		       40		      .byte.b	%01000000
   1628  2003		       30		      .byte.b	%00110000
   1629  2004		       20		      .byte.b	%00100000
   1630  2005		       10		      .byte.b	%00010000
   1631  2006		       00		      .byte.b	%00000000	;left 0
   1632  2007		       f0		      .byte.b	%11110000
   1633  2008		       e0		      .byte.b	%11100000
   1634  2009		       d0		      .byte.b	%11010000
   1635  200a		       c0		      .byte.b	%11000000
   1636  200b		       b0		      .byte.b	%10110000
   1637  200c		       a0		      .byte.b	%10100000
   1638  200d		       90		      .byte.b	%10010000
   1639  200e		       80		      .byte.b	%10000000	;right 8
   1640  200e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
   1641  200f
   1642  200f				   PFStart
   1643  200f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
   1644  2017				   blank_pf
   1645  2017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
   1646  201f							; .byte 43,21,0,10,0,0,0,5
   1647  201f				  -	      ifconst	screenheight
   1648  201f				  -pfsub
   1649  201f				  -	      .byte	8,4,2,2,1,0,0,1,0
   1650  201f					      endif
   1651  201f							;--set initial P1 positions
   1652  201f				   multisprite_setup
   1653  201f		       a9 0f		      lda	#15
   1654  2021		       85 c4		      sta	pfheight
   1655  2023
   1656  2023		       a2 04		      ldx	#4
   1657  2025							; stx temp3
   1658  2025				   SetCopyHeight
   1659  2025							;	lda #76
   1660  2025							;	sta NewSpriteX,X
   1661  2025							;	lda CopyColorData,X
   1662  2025							;	sta NewCOLUP1,X
   1663  2025							;lda SpriteHeightTable,X
   1664  2025							; sta spriteheight,x
   1665  2025		       8a		      txa
   1666  2026		       95 9d		      sta	SpriteGfxIndex,X
   1667  2028		       95 f1		      sta	spritesort,X
   1668  202a		       ca		      dex
   1669  202b		       10 f8		      bpl	SetCopyHeight
   1670  202d
   1671  202d
   1672  202d
   1673  202d							; since we can't turn off pf, point PF to zeros here
   1674  202d		       a9 f0		      lda	#>blank_pf
   1675  202f		       85 be		      sta	PF2pointer+1
   1676  2031		       85 bc		      sta	PF1pointer+1
   1677  2033		       a9 17		      lda	#<blank_pf
   1678  2035		       85 bd		      sta	PF2pointer
   1679  2037		       85 bb		      sta	PF1pointer
   1680  2039		       60		      rts
   1681  203a
   1682  203a				   drawscreen
   1683  203a				  -	      ifconst	debugscore
   1684  203a				  -	      jsr	debugcycles
   1685  203a					      endif
   1686  203a
   1687  203a				   WaitForOverscanEnd
   1688  203a		       ad 84 02 	      lda	INTIM
   1689  203d		       30 fb		      bmi	WaitForOverscanEnd
   1690  203f
   1691  203f		       a9 02		      lda	#2
   1692  2041		       85 02		      sta	WSYNC
   1693  2043		       85 00		      sta	VSYNC
   1694  2045		       85 02		      sta	WSYNC
   1695  2047		       85 02		      sta	WSYNC
   1696  2049		       4a		      lsr
   1697  204a		       85 27		      sta	VDELBL
   1698  204c		       85 25		      sta	VDELP0
   1699  204e		       85 02		      sta	WSYNC
   1700  2050		       85 00		      sta	VSYNC	;turn off VSYNC
   1701  2052				  -	      ifconst	overscan_time
   1702  2052				  -	      lda	#overscan_time+5+128
   1703  2052					      else
   1704  2052		       a9 aa		      lda	#42+128
   1705  2054					      endif
   1706  2054		       8d 96 02 	      sta	TIM64T
   1707  2057
   1708  2057							; run possible vblank bB code
   1709  2057				  -	      ifconst	vblank_bB_code
   1710  2057				  -	      jsr	vblank_bB_code
   1711  2057					      endif
   1712  2057
   1713  2057		       20 dc f1 	      jsr	setscorepointers
   1714  205a		       20 7e f3 	      jsr	SetupP1Subroutine
   1715  205d
   1716  205d							;-------------
   1717  205d
   1718  205d
   1719  205d
   1720  205d
   1721  205d
   1722  205d							;--position P0, M0, M1, BL
   1723  205d
   1724  205d		       20 b5 f0 	      jsr	PrePositionAllObjects
   1725  2060
   1726  2060							;--set up player 0 pointer
   1727  2060
   1728  2060		       c6 8d		      dec	player0y
   1729  2062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
   1730  2064		       38		      sec
   1731  2065		       e5 8d		      sbc	player0y
   1732  2067		       18		      clc
   1733  2068		       65 b0		      adc	player0height
   1734  206a		       85 a2		      sta	player0pointer
   1735  206c
   1736  206c		       a5 8d		      lda	player0y
   1737  206e		       85 cf		      sta	P0Top
   1738  2070		       38		      sec
   1739  2071		       e5 b0		      sbc	player0height
   1740  2073		       18		      clc
   1741  2074		       69 80		      adc	#$80
   1742  2076		       85 a4		      sta	P0Bottom
   1743  2078
   1744  2078
   1745  2078							;--some final setup
   1746  2078
   1747  2078		       a2 04		      ldx	#4
   1748  207a		       a9 80		      lda	#$80
   1749  207c				   cycle74_HMCLR
   1750  207c		       95 20		      sta	HMP0,X
   1751  207e		       ca		      dex
   1752  207f		       10 fb		      bpl	cycle74_HMCLR
   1753  2081							;	sta HMCLR
   1754  2081
   1755  2081
   1756  2081		       a9 00		      lda	#0
   1757  2083		       85 0e		      sta	PF1
   1758  2085		       85 0f		      sta	PF2
   1759  2087		       85 1b		      sta	GRP0
   1760  2089		       85 1c		      sta	GRP1
   1761  208b
   1762  208b
   1763  208b		       20 d0 f0 	      jsr	KernelSetupSubroutine
   1764  208e
   1765  208e				   WaitForVblankEnd
   1766  208e		       ad 84 02 	      lda	INTIM
   1767  2091		       30 fb		      bmi	WaitForVblankEnd
   1768  2093		       a9 00		      lda	#0
   1769  2095		       85 02		      sta	WSYNC
   1770  2097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
   1771  2099		       85 2c		      sta	CXCLR
   1772  209b
   1773  209b
   1774  209b		       4c 5d f1 	      jmp	KernelRoutine
   1775  209e
   1776  209e
   1777  209e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
   1778  209e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
   1779  209e							;if you do not wish to write to P1 during this function, make
   1780  209e							;sure Y==0 before you call it.  This function will change Y, and A
   1781  209e							;will be the value put into HMxx when returned.
   1782  209e							;Call this function with at least 11 cycles left in the scanline 
   1783  209e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
   1784  209e							;into the second scanline
   1785  209e		       38		      sec
   1786  209f		       85 02		      sta	WSYNC	;begin line 1
   1787  20a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
   1788  20a4				   DivideBy15Loop
   1789  20a4		       e9 0f		      sbc	#15
   1790  20a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
   1791  20a8
   1792  20a8		       a8		      tay		;+2	10/15/...60
   1793  20a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
   1794  20ac
   1795  20ac							;	15
   1796  20ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
   1797  20ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
   1798  20b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1799  20b2		       85 2a		      sta	HMOVE	;+3
   1800  20b4		       60		      rts		;+6	 9
   1801  20b5
   1802  20b5							;-------------------------------------------------------------------------
   1803  20b5
   1804  20b5				   PrePositionAllObjects
   1805  20b5
   1806  20b5		       a2 04		      ldx	#4
   1807  20b7		       a5 82		      lda	ballx
   1808  20b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1809  20bc
   1810  20bc		       ca		      dex
   1811  20bd		       a5 81		      lda	missile1x
   1812  20bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1813  20c2
   1814  20c2		       ca		      dex
   1815  20c3		       a5 80		      lda	missile0x
   1816  20c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1817  20c8
   1818  20c8		       ca		      dex
   1819  20c9		       ca		      dex
   1820  20ca		       a5 84		      lda	player0x
   1821  20cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1822  20cf
   1823  20cf		       60		      rts
   1824  20d0
   1825  20d0
   1826  20d0							;-------------------------------------------------------------------------
   1827  20d0
   1828  20d0
   1829  20d0
   1830  20d0
   1831  20d0
   1832  20d0
   1833  20d0
   1834  20d0
   1835  20d0							;-------------------------------------------------------------------------
   1836  20d0
   1837  20d0
   1838  20d0				   KernelSetupSubroutine
   1839  20d0
   1840  20d0		       a2 04		      ldx	#4
   1841  20d2				   AdjustYValuesUpLoop
   1842  20d2		       b5 8e		      lda	NewSpriteY,X
   1843  20d4		       18		      clc
   1844  20d5		       69 02		      adc	#2
   1845  20d7		       95 8e		      sta	NewSpriteY,X
   1846  20d9		       ca		      dex
   1847  20da		       10 f6		      bpl	AdjustYValuesUpLoop
   1848  20dc
   1849  20dc
   1850  20dc		       a6 cd		      ldx	temp3	; first sprite displayed
   1851  20de
   1852  20de		       b5 9d		      lda	SpriteGfxIndex,x
   1853  20e0		       a8		      tay
   1854  20e1		       b9 8e 00 	      lda	NewSpriteY,y
   1855  20e4		       85 ce		      sta	RepoLine
   1856  20e6
   1857  20e6		       b5 9c		      lda	SpriteGfxIndex-1,x
   1858  20e8		       a8		      tay
   1859  20e9		       b9 8e 00 	      lda	NewSpriteY,y
   1860  20ec		       85 d0		      sta	temp6
   1861  20ee
   1862  20ee		       86 83		      stx	SpriteIndex
   1863  20f0
   1864  20f0
   1865  20f0
   1866  20f0		       a9 ff		      lda	#255
   1867  20f2		       85 a5		      sta	P1Bottom
   1868  20f4
   1869  20f4		       a5 8d		      lda	player0y
   1870  20f6				  -	      ifconst	screenheight
   1871  20f6				  -	      cmp	#screenheight+1
   1872  20f6					      else
   1873  20f6		       c9 59		      cmp	#$59
   1874  20f8					      endif
   1875  20f8		       90 04		      bcc	nottoohigh
   1876  20fa		       a5 a4		      lda	P0Bottom
   1877  20fc		       85 cf		      sta	P0Top
   1878  20fe
   1879  20fe
   1880  20fe
   1881  20fe				   nottoohigh
   1882  20fe		       60		      rts
   1883  20ff
   1884  20ff							;-------------------------------------------------------------------------
   1885  20ff
   1886  20ff
   1887  20ff
   1888  20ff
   1889  20ff
   1890  20ff							;*************************************************************************
   1891  20ff
   1892  20ff							;-------------------------------------------------------------------------
   1893  20ff							;-------------------------Data Below--------------------------------------
   1894  20ff							;-------------------------------------------------------------------------
   1895  20ff
   1896  20ff				   MaskTable
   1897  20ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
   1898  2104
   1899  2104							; shove 6-digit score routine here
   1900  2104
   1901  2104				   sixdigscore
   1902  2104		       a9 00		      lda	#0
   1903  2106							;	sta COLUBK
   1904  2106		       85 0d		      sta	PF0
   1905  2108		       85 0e		      sta	PF1
   1906  210a		       85 0f		      sta	PF2
   1907  210c		       85 1f		      sta	ENABL
   1908  210e		       85 1d		      sta	ENAM0
   1909  2110		       85 1e		      sta	ENAM1
   1910  2112							;end of kernel here
   1911  2112
   1912  2112
   1913  2112							; 6 digit score routine
   1914  2112							; lda #0
   1915  2112							; sta PF1
   1916  2112							; sta PF2
   1917  2112							; tax
   1918  2112
   1919  2112		       85 02		      sta	WSYNC	;,x
   1920  2114
   1921  2114							;		  STA WSYNC ;first one, need one more
   1922  2114		       85 0b		      sta	REFP0
   1923  2116		       85 0c		      sta	REFP1
   1924  2118		       85 1b		      STA	GRP0
   1925  211a		       85 1c		      STA	GRP1
   1926  211c		       85 2b		      sta	HMCLR
   1927  211e
   1928  211e							; restore P0pointer
   1929  211e
   1930  211e		       a5 a2		      lda	player0pointer
   1931  2120		       18		      clc
   1932  2121		       65 8d		      adc	player0y
   1933  2123		       38		      sec
   1934  2124		       e5 b0		      sbc	player0height
   1935  2126		       85 a2		      sta	player0pointer
   1936  2128		       e6 8d		      inc	player0y
   1937  212a
   1938  212a				  -	      ifconst	vblank_time
   1939  212a				  -	      ifconst	screenheight
   1940  212a				  -	      if	screenheight == 84
   1941  212a				  -	      lda	#vblank_time+9+128+10
   1942  212a				  -	      else
   1943  212a				  -	      lda	#vblank_time+9+128+19
   1944  212a				  -	      endif
   1945  212a				  -	      else
   1946  212a				  -	      lda	#vblank_time+9+128
   1947  212a				  -	      endif
   1948  212a					      else
   1949  212a				  -	      ifconst	screenheight
   1950  212a				  -	      if	screenheight == 84
   1951  212a				  -	      lda	#52+128+10
   1952  212a				  -	      else
   1953  212a				  -	      lda	#52+128+19
   1954  212a				  -	      endif
   1955  212a					      else
   1956  212a		       a9 b4		      lda	#52+128
   1957  212c					      endif
   1958  212c					      endif
   1959  212c
   1960  212c		       8d 96 02 	      sta	TIM64T
   1961  212f				  -	      ifconst	minikernel
   1962  212f				  -	      jsr	minikernel
   1963  212f					      endif
   1964  212f				  -	      ifconst	noscore
   1965  212f				  -	      pla
   1966  212f				  -	      pla
   1967  212f				  -	      jmp	skipscore
   1968  212f					      endif
   1969  212f
   1970  212f							; score pointers contain:
   1971  212f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1972  212f							; swap lo2->temp1
   1973  212f							; swap lo4->temp3
   1974  212f							; swap lo6->temp5
   1975  212f
   1976  212f		       a5 ca		      lda	scorepointers+5
   1977  2131		       85 cf		      sta	temp5
   1978  2133		       a5 c6		      lda	scorepointers+1
   1979  2135		       85 cb		      sta	temp1
   1980  2137		       a5 c8		      lda	scorepointers+3
   1981  2139		       85 cd		      sta	temp3
   1982  213b
   1983  213b		       a9 ff		      lda	#>scoretable
   1984  213d		       85 c6		      sta	scorepointers+1
   1985  213f		       85 c8		      sta	scorepointers+3
   1986  2141		       85 ca		      sta	scorepointers+5
   1987  2143		       85 cc		      sta	temp2
   1988  2145		       85 ce		      sta	temp4
   1989  2147		       85 d0		      sta	temp6
   1990  2149
   1991  2149		       60		      rts
   1992  214a
   1993  214a
   1994  214a
   1995  214a							;-------------------------------------------------------------------------
   1996  214a							;----------------------Kernel Routine-------------------------------------
   1997  214a							;-------------------------------------------------------------------------
   1998  214a
   1999  214a
   2000  214a							;-------------------------------------------------------------------------
   2001  214a							; repeat $f147-*
   2002  214a							; brk
   2003  214a							; repend
   2004  214a							;	org $F240
   2005  214a
   2006  214a				   SwitchDrawP0K1		;	72
   2007  214a		       a5 a4		      lda	P0Bottom
   2008  214c		       85 cf		      sta	P0Top	;+6	 2
   2009  214e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   2010  2151
   2011  2151				   WaitDrawP0K1 		;	74
      0  2151					      SLEEP	4	;+4	 2
      1  2151				   .CYCLES    SET	4
      2  2151
      3  2151				  -	      IF	.CYCLES < 2
      4  2151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2151				  -	      ERR
      6  2151					      ENDIF
      7  2151
      8  2151				  -	      IF	.CYCLES & 1
      9  2151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2151				  -	      nop	0
     11  2151				  -	      ELSE
     12  2151				  -	      bit	VSYNC
     13  2151				  -	      ENDIF
     14  2151				  -.CYCLES    SET	.CYCLES - 3
     15  2151					      ENDIF
     16  2151
     17  2151					      REPEAT	.CYCLES / 2
     18  2151		       ea		      nop
     17  2151					      REPEND
     18  2152		       ea		      nop
     19  2153					      REPEND
   2013  2153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   2014  2156
   2015  2156				   SkipDrawP1K1 		;	11
   2016  2156		       a9 00		      lda	#0
   2017  2158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
   2018  215a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
   2019  215d
   2020  215d							;-------------------------------------------------------------------------
   2021  215d
   2022  215d				   KernelRoutine
   2023  215d					      ifnconst	screenheight
      0  215d					      sleep	12
      1  215d				   .CYCLES    SET	12
      2  215d
      3  215d				  -	      IF	.CYCLES < 2
      4  215d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215d				  -	      ERR
      6  215d					      ENDIF
      7  215d
      8  215d				  -	      IF	.CYCLES & 1
      9  215d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215d				  -	      nop	0
     11  215d				  -	      ELSE
     12  215d				  -	      bit	VSYNC
     13  215d				  -	      ENDIF
     14  215d				  -.CYCLES    SET	.CYCLES - 3
     15  215d					      ENDIF
     16  215d
     17  215d					      REPEAT	.CYCLES / 2
     18  215d		       ea		      nop
     17  215d					      REPEND
     18  215e		       ea		      nop
     17  215e					      REPEND
     18  215f		       ea		      nop
     17  215f					      REPEND
     18  2160		       ea		      nop
     17  2160					      REPEND
     18  2161		       ea		      nop
     17  2161					      REPEND
     18  2162		       ea		      nop
     19  2163					      REPEND
   2025  2163							; jsr wastetime ; waste 12 cycles
   2026  2163				  -	      else
   2027  2163				  -	      sleep	6
   2028  2163					      endif
   2029  2163		       ba		      tsx
   2030  2164		       86 f6		      stx	stack1
   2031  2166		       a2 1f		      ldx	#ENABL
   2032  2168		       9a		      txs		;+9	 9
   2033  2169
   2034  2169		       a2 00		      ldx	#0
   2035  216b		       a5 c4		      lda	pfheight
   2036  216d		       10 01		      bpl	asdhj
   2037  216f		       24		      .byte.b	$24
   2038  2170				   asdhj
   2039  2170		       aa		      tax
   2040  2171
   2041  2171							; ldx pfheight
   2042  2171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
   2043  2174
   2044  2174				  -	      ifconst	screenheight
   2045  2174				  -	      sec
   2046  2174				  -	      if	screenheight == 84
   2047  2174				  -	      sbc	pfsub+1,x
   2048  2174				  -	      else
   2049  2174				  -	      sbc	pfsub,x
   2050  2174				  -	      endif
   2051  2174					      endif
   2052  2174
   2053  2174		       85 ba		      sta	pfpixelheight
   2054  2176
   2055  2176				  -	      ifconst	screenheight
   2056  2176				  -	      ldy	#screenheight
   2057  2176					      else
   2058  2176		       a0 58		      ldy	#88
   2059  2178					      endif
   2060  2178
   2061  2178							;	lda #$02
   2062  2178							;	sta COLUBK		;+5	18
   2063  2178
   2064  2178							; sleep 25
      0  2178					      sleep	2
      1  2178				   .CYCLES    SET	2
      2  2178
      3  2178				  -	      IF	.CYCLES < 2
      4  2178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2178				  -	      ERR
      6  2178					      ENDIF
      7  2178
      8  2178				  -	      IF	.CYCLES & 1
      9  2178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2178				  -	      nop	0
     11  2178				  -	      ELSE
     12  2178				  -	      bit	VSYNC
     13  2178				  -	      ENDIF
     14  2178				  -.CYCLES    SET	.CYCLES - 3
     15  2178					      ENDIF
     16  2178
     17  2178					      REPEAT	.CYCLES / 2
     18  2178		       ea		      nop
     19  2179					      REPEND
   2066  2179				   KernelLoopa		;	50
      0  2179					      SLEEP	7	;+4	54
      1  2179				   .CYCLES    SET	7
      2  2179
      3  2179				  -	      IF	.CYCLES < 2
      4  2179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2179				  -	      ERR
      6  2179					      ENDIF
      7  2179
      8  2179					      IF	.CYCLES & 1
      9  2179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2179		       04 00		      nop	0
     11  217b				  -	      ELSE
     12  217b				  -	      bit	VSYNC
     13  217b					      ENDIF
     14  217b				   .CYCLES    SET	.CYCLES - 3
     15  217b					      ENDIF
     16  217b
     17  217b					      REPEAT	.CYCLES / 2
     18  217b		       ea		      nop
     17  217b					      REPEND
     18  217c		       ea		      nop
     19  217d					      REPEND
   2068  217d				   KernelLoopb		;	54
      0  217d					      SLEEP	2	;+12	66
      1  217d				   .CYCLES    SET	2
      2  217d
      3  217d				  -	      IF	.CYCLES < 2
      4  217d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217d				  -	      ERR
      6  217d					      ENDIF
      7  217d
      8  217d				  -	      IF	.CYCLES & 1
      9  217d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217d				  -	      nop	0
     11  217d				  -	      ELSE
     12  217d				  -	      bit	VSYNC
     13  217d				  -	      ENDIF
     14  217d				  -.CYCLES    SET	.CYCLES - 3
     15  217d					      ENDIF
     16  217d
     17  217d					      REPEAT	.CYCLES / 2
     18  217d		       ea		      nop
     19  217e					      REPEND
   2070  217e		       c4 cf		      cpy	P0Top	;+3	69
   2071  2180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
   2072  2182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
   2073  2184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
   2074  2186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
   2075  2188				   BackFromSwitchDrawP0K1
   2076  2188
   2077  2188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
   2078  218a							;		to a value greater than maximum Y value initially
   2079  218a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
   2080  218c		       b1 cc		      lda	(P1display),Y	;+5	15
   2081  218e		       8d 1c 00 	      sta.w	GRP1	;+4	19
   2082  2191				   BackFromSkipDrawP1
   2083  2191
   2084  2191							;fuck	
   2085  2191		       84 cb		      sty	temp1
   2086  2193		       a4 ba		      ldy	pfpixelheight
   2087  2195		       b3 bb		      lax	(PF1pointer),y
   2088  2197		       86 0e		      stx	PF1	;+7	26
   2089  2199		       b1 bd		      lda	(PF2pointer),y
   2090  219b		       85 0f		      sta	PF2	;+7	33
   2091  219d							;sleep 6
   2092  219d		       86 b7		      stx	PF1temp2
   2093  219f		       85 b9		      sta	PF2temp2
   2094  21a1		       88		      dey
   2095  21a2		       30 35		      bmi	pagewraphandler
   2096  21a4		       b1 bb		      lda	(PF1pointer),y
   2097  21a6				   cyclebalance
   2098  21a6		       85 b6		      sta	PF1temp1
   2099  21a8		       b1 bd		      lda	(PF2pointer),y
   2100  21aa		       85 b8		      sta	PF2temp1
   2101  21ac		       a4 cb		      ldy	temp1
   2102  21ae
   2103  21ae		       a2 1f		      ldx	#ENABL
   2104  21b0		       9a		      txs
   2105  21b1		       c4 8c		      cpy	bally
   2106  21b3		       08		      php		;+6	39	VDEL ball
   2107  21b4
   2108  21b4
   2109  21b4		       c4 8b		      cpy	missile1y
   2110  21b6		       08		      php		;+6	71
   2111  21b7
   2112  21b7		       c4 8a		      cpy	missile0y
   2113  21b9		       08		      php		;+6	 1
   2114  21ba
   2115  21ba
   2116  21ba		       88		      dey		;+2	15
   2117  21bb
   2118  21bb		       c4 ce		      cpy	RepoLine	;+3	18
   2119  21bd		       f0 62		      beq	RepoKernel	;+2	20
   2120  21bf							;	SLEEP 20		;+23	43
      0  21bf					      sleep	6
      1  21bf				   .CYCLES    SET	6
      2  21bf
      3  21bf				  -	      IF	.CYCLES < 2
      4  21bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21bf				  -	      ERR
      6  21bf					      ENDIF
      7  21bf
      8  21bf				  -	      IF	.CYCLES & 1
      9  21bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21bf				  -	      nop	0
     11  21bf				  -	      ELSE
     12  21bf				  -	      bit	VSYNC
     13  21bf				  -	      ENDIF
     14  21bf				  -.CYCLES    SET	.CYCLES - 3
     15  21bf					      ENDIF
     16  21bf
     17  21bf					      REPEAT	.CYCLES / 2
     18  21bf		       ea		      nop
     17  21bf					      REPEND
     18  21c0		       ea		      nop
     17  21c0					      REPEND
     18  21c1		       ea		      nop
     19  21c2					      REPEND
   2122  21c2
   2123  21c2				   newrepo		; since we have time here, store next repoline
   2124  21c2		       a6 83		      ldx	SpriteIndex
   2125  21c4		       b5 9c		      lda	SpriteGfxIndex-1,x
   2126  21c6		       aa		      tax
   2127  21c7		       b5 8e		      lda	NewSpriteY,x
   2128  21c9		       85 d0		      sta	temp6
      0  21cb					      sleep	4
      1  21cb				   .CYCLES    SET	4
      2  21cb
      3  21cb				  -	      IF	.CYCLES < 2
      4  21cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21cb				  -	      ERR
      6  21cb					      ENDIF
      7  21cb
      8  21cb				  -	      IF	.CYCLES & 1
      9  21cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21cb				  -	      nop	0
     11  21cb				  -	      ELSE
     12  21cb				  -	      bit	VSYNC
     13  21cb				  -	      ENDIF
     14  21cb				  -.CYCLES    SET	.CYCLES - 3
     15  21cb					      ENDIF
     16  21cb
     17  21cb					      REPEAT	.CYCLES / 2
     18  21cb		       ea		      nop
     17  21cb					      REPEND
     18  21cc		       ea		      nop
     19  21cd					      REPEND
   2130  21cd
   2131  21cd				   BackFromRepoKernel
   2132  21cd		       98		      tya		;+2	45
   2133  21ce		       25 c4		      and	pfheight	;+2	47
   2134  21d0		       d0 a7		      bne	KernelLoopa	;+2	49
   2135  21d2		       c6 ba		      dec	pfpixelheight
   2136  21d4		       10 a7		      bpl	KernelLoopb	;+3	54
   2137  21d6							;	bmi donewkernel		;+3	54
   2138  21d6							;	bne KernelLoopb+1		;+3	54
   2139  21d6
   2140  21d6				   donewkernel
   2141  21d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
   2142  21d9
   2143  21d9				   pagewraphandler
   2144  21d9		       4c a6 f1 	      jmp	cyclebalance
   2145  21dc
   2146  21dc							;-------------------------------------------------------------------------
   2147  21dc
   2148  21dc							; room here for score?
   2149  21dc
   2150  21dc				   setscorepointers
   2151  21dc		       a7 d4		      lax	score+2
   2152  21de		       20 f8 f1 	      jsr	scorepointerset
   2153  21e1		       84 ca		      sty	scorepointers+5
   2154  21e3		       86 c7		      stx	scorepointers+2
   2155  21e5		       a7 d3		      lax	score+1
   2156  21e7		       20 f8 f1 	      jsr	scorepointerset
   2157  21ea		       84 c9		      sty	scorepointers+4
   2158  21ec		       86 c6		      stx	scorepointers+1
   2159  21ee		       a7 d2		      lax	score
   2160  21f0		       20 f8 f1 	      jsr	scorepointerset
   2161  21f3		       84 c8		      sty	scorepointers+3
   2162  21f5		       86 c5		      stx	scorepointers
   2163  21f7				   wastetime
   2164  21f7		       60		      rts
   2165  21f8
   2166  21f8				   scorepointerset
   2167  21f8		       29 0f		      and	#$0F
   2168  21fa		       0a		      asl
   2169  21fb		       0a		      asl
   2170  21fc		       0a		      asl
   2171  21fd		       69 74		      adc	#<scoretable
   2172  21ff		       a8		      tay
   2173  2200		       8a		      txa
   2174  2201		       29 f0		      and	#$F0
   2175  2203		       4a		      lsr
   2176  2204		       69 74		      adc	#<scoretable
   2177  2206		       aa		      tax
   2178  2207		       60		      rts
   2179  2208							;	align 256
   2180  2208
   2181  2208				   SwitchDrawP0KR		;	45
   2182  2208		       a5 a4		      lda	P0Bottom
   2183  220a		       85 cf		      sta	P0Top	;+6	51
   2184  220c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   2185  220f
   2186  220f				   WaitDrawP0KR 		;	47
      0  220f					      SLEEP	4	;+4	51
      1  220f				   .CYCLES    SET	4
      2  220f
      3  220f				  -	      IF	.CYCLES < 2
      4  220f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  220f				  -	      ERR
      6  220f					      ENDIF
      7  220f
      8  220f				  -	      IF	.CYCLES & 1
      9  220f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  220f				  -	      nop	0
     11  220f				  -	      ELSE
     12  220f				  -	      bit	VSYNC
     13  220f				  -	      ENDIF
     14  220f				  -.CYCLES    SET	.CYCLES - 3
     15  220f					      ENDIF
     16  220f
     17  220f					      REPEAT	.CYCLES / 2
     18  220f		       ea		      nop
     17  220f					      REPEND
     18  2210		       ea		      nop
     19  2211					      REPEND
   2188  2211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   2189  2214
   2190  2214							;-----------------------------------------------------------
   2191  2214
   2192  2214				   noUpdateXKR
   2193  2214		       a2 01		      ldx	#1
   2194  2216		       cc cf 00 	      cpy.w	P0Top
   2195  2219		       4c 2b f2 	      JMP	retXKR
   2196  221c
   2197  221c				   skipthis
   2198  221c		       a2 01		      ldx	#1
   2199  221e		       4c 6d f2 	      jmp	goback
   2200  2221
   2201  2221				   RepoKernel		;	22	crosses page boundary
   2202  2221		       98		      tya
   2203  2222		       25 c4		      and	pfheight	;+2	26
   2204  2224		       d0 ee		      bne	noUpdateXKR	;+2	28
   2205  2226		       aa		      tax
   2206  2227							;	dex			;+2	30
   2207  2227		       c6 ba		      dec	pfpixelheight
   2208  2229							;	stx Temp		;+3	35
   2209  2229							;	SLEEP 3
   2210  2229
   2211  2229		       c4 cf		      cpy	P0Top	;+3	42
   2212  222b				   retXKR
   2213  222b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
   2214  222d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
   2215  222f		       b1 a2		      lda	(player0pointer),Y	;+5	51
   2216  2231		       85 1b		      sta	GRP0	;+3	54	VDEL
   2217  2233				   BackFromSwitchDrawP0KR
   2218  2233		       38		      sec		;+2	56
   2219  2234
   2220  2234
   2221  2234
   2222  2234		       b5 b8		      lda	PF2temp1,X
   2223  2236		       b4 b6		      ldy	PF1temp1,X
   2224  2238
   2225  2238		       a6 83		      ldx	SpriteIndex	;+3	 2
   2226  223a
   2227  223a		       85 0f		      sta	PF2	;+7	63
   2228  223c
   2229  223c		       b5 9d		      lda	SpriteGfxIndex,x
   2230  223e		       84 0e		      sty	PF1	;+7	70	too early?
   2231  2240		       aa		      tax
   2232  2241		       a9 00		      lda	#0
   2233  2243		       85 1c		      sta	GRP1	;+5	75	to display player 0
   2234  2245		       b5 85		      lda	NewSpriteX,X	;+4	 6
   2235  2247
   2236  2247				   DivideBy15LoopK		;	 6	(carry set above)
   2237  2247		       e9 0f		      sbc	#15
   2238  2249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
   2239  224b
   2240  224b		       aa		      tax		;+2	12/17/...62
   2241  224c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
   2242  224f
   2243  224f		       85 21		      sta	HMP1	;+3	20/25/...70
   2244  2251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
   2245  2253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   2246  2255							;sta HMOVE			;+3	 3
   2247  2255
   2248  2255		       a2 1f		      ldx	#ENABL
   2249  2257		       9a		      txs		;+4	25
   2250  2258		       a4 ce		      ldy	RepoLine	; restore y
   2251  225a		       c4 8c		      cpy	bally
   2252  225c		       08		      php		;+6	 9	VDEL ball
   2253  225d
   2254  225d		       c4 8b		      cpy	missile1y
   2255  225f		       08		      php		;+6	15
   2256  2260
   2257  2260		       c4 8a		      cpy	missile0y
   2258  2262		       08		      php		;+6	21
   2259  2263
   2260  2263
   2261  2263
   2262  2263
   2263  2263
   2264  2263							;15 cycles
   2265  2263		       98		      tya
   2266  2264		       25 c4		      and	pfheight
   2267  2266							;eor #1
   2268  2266		       29 fe		      and	#$FE
   2269  2268		       d0 b2		      bne	skipthis
   2270  226a		       aa		      tax
      0  226b					      sleep	4
      1  226b				   .CYCLES    SET	4
      2  226b
      3  226b				  -	      IF	.CYCLES < 2
      4  226b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  226b				  -	      ERR
      6  226b					      ENDIF
      7  226b
      8  226b				  -	      IF	.CYCLES & 1
      9  226b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  226b				  -	      nop	0
     11  226b				  -	      ELSE
     12  226b				  -	      bit	VSYNC
     13  226b				  -	      ENDIF
     14  226b				  -.CYCLES    SET	.CYCLES - 3
     15  226b					      ENDIF
     16  226b
     17  226b					      REPEAT	.CYCLES / 2
     18  226b		       ea		      nop
     17  226b					      REPEND
     18  226c		       ea		      nop
     19  226d					      REPEND
   2272  226d							;	sleep 2
   2273  226d				   goback
   2274  226d
   2275  226d		       88		      dey
   2276  226e		       c4 cf		      cpy	P0Top	;+3	52
   2277  2270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
   2278  2272		       10 67		      bpl	WaitDrawP0KV	;+2	56
   2279  2274		       b1 a2		      lda	(player0pointer),Y	;+5	61
   2280  2276		       85 1b		      sta	GRP0	;+3	64	VDEL
   2281  2278				   BackFromSwitchDrawP0KV
   2282  2278
   2283  2278							; sleep 3
   2284  2278
   2285  2278		       b5 b8		      lda	PF2temp1,X
   2286  227a		       85 0f		      sta	PF2	;+7	 5
   2287  227c		       b5 b6		      lda	PF1temp1,X
   2288  227e		       85 0e		      sta	PF1	;+7	74 
   2289  2280		       85 2a		      sta	HMOVE
   2290  2282
   2291  2282		       a9 00		      lda	#0
   2292  2284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
   2293  2286
   2294  2286		       a2 1f		      ldx	#ENABL
   2295  2288		       9a		      txs		;+4	 8
   2296  2289
   2297  2289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
   2298  228b							;--now, set all new variables and return to main kernel loop
   2299  228b
   2300  228b
   2301  228b							;
   2302  228b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
   2303  228d		       aa		      tax		;+2	33
   2304  228e							;
   2305  228e
   2306  228e
   2307  228e
   2308  228e		       b5 93		      lda	NewNUSIZ,X
   2309  2290		       85 05		      sta	NUSIZ1	;+7	20
   2310  2292		       85 0c		      sta	REFP1
   2311  2294		       b5 98		      lda	NewCOLUP1,X
   2312  2296		       85 07		      sta	COLUP1	;+7	27
   2313  2298
   2314  2298							;	lda SpriteGfxIndex,X	;+4	31
   2315  2298							;	tax				;+2	33
   2316  2298							;fuck2
   2317  2298		       b5 8e		      lda	NewSpriteY,X	;+4	46
   2318  229a		       38		      sec		;+2	38
   2319  229b		       f5 b1		      sbc	spriteheight,X	;+4	42
   2320  229d		       85 a5		      sta	P1Bottom	;+3	45
   2321  229f
      0  229f					      sleep	6
      1  229f				   .CYCLES    SET	6
      2  229f
      3  229f				  -	      IF	.CYCLES < 2
      4  229f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  229f				  -	      ERR
      6  229f					      ENDIF
      7  229f
      8  229f				  -	      IF	.CYCLES & 1
      9  229f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  229f				  -	      nop	0
     11  229f				  -	      ELSE
     12  229f				  -	      bit	VSYNC
     13  229f				  -	      ENDIF
     14  229f				  -.CYCLES    SET	.CYCLES - 3
     15  229f					      ENDIF
     16  229f
     17  229f					      REPEAT	.CYCLES / 2
     18  229f		       ea		      nop
     17  229f					      REPEND
     18  22a0		       ea		      nop
     17  22a0					      REPEND
     18  22a1		       ea		      nop
     19  22a2					      REPEND
   2323  22a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
   2324  22a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
   2325  22a6		       85 cc		      sta	P1display	;+3	55
   2326  22a8		       b5 ab		      lda	player1pointerhi,X
   2327  22aa		       85 cd		      sta	P1display+1	;+7	62
   2328  22ac
   2329  22ac
   2330  22ac		       c4 8c		      cpy	bally
   2331  22ae		       08		      php		;+6	68	VDELed
   2332  22af
   2333  22af		       c4 8b		      cpy	missile1y
   2334  22b1		       08		      php		;+6	74
   2335  22b2
   2336  22b2		       c4 8a		      cpy	missile0y
   2337  22b4		       08		      php		;+6	 4
   2338  22b5
   2339  22b5
   2340  22b5
   2341  22b5							; lda SpriteGfxIndex-1,x
   2342  22b5							; sleep 3
   2343  22b5		       c6 83		      dec	SpriteIndex	;+5	13
   2344  22b7							; tax
   2345  22b7							; lda NewSpriteY,x
   2346  22b7							; sta RepoLine
   2347  22b7
   2348  22b7							; 10 cycles below...
   2349  22b7		       10 05		      bpl	SetNextLine
   2350  22b9		       a9 ff		      lda	#255
   2351  22bb		       4c c1 f2 	      jmp	SetLastLine
   2352  22be				   SetNextLine
   2353  22be							;	lda NewSpriteY-1,x
   2354  22be		       ad d0 00 	      lda.w	temp6
   2355  22c1				   SetLastLine
   2356  22c1		       85 ce		      sta	RepoLine
   2357  22c3
   2358  22c3		       98		      tya
   2359  22c4		       25 c4		      and	pfheight
   2360  22c6		       d0 06		      bne	nodec
   2361  22c8		       c6 ba		      dec	pfpixelheight
   2362  22ca		       88		      dey		;+2	30
   2363  22cb
   2364  22cb							; 10 cycles 
   2365  22cb
   2366  22cb
   2367  22cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
   2368  22ce
   2369  22ce				   nodec
      0  22ce					      sleep	4
      1  22ce				   .CYCLES    SET	4
      2  22ce
      3  22ce				  -	      IF	.CYCLES < 2
      4  22ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22ce				  -	      ERR
      6  22ce					      ENDIF
      7  22ce
      8  22ce				  -	      IF	.CYCLES & 1
      9  22ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22ce				  -	      nop	0
     11  22ce				  -	      ELSE
     12  22ce				  -	      bit	VSYNC
     13  22ce				  -	      ENDIF
     14  22ce				  -.CYCLES    SET	.CYCLES - 3
     15  22ce					      ENDIF
     16  22ce
     17  22ce					      REPEAT	.CYCLES / 2
     18  22ce		       ea		      nop
     17  22ce					      REPEND
     18  22cf		       ea		      nop
     19  22d0					      REPEND
   2371  22d0		       88		      dey
   2372  22d1		       4c cd f1 	      jmp	BackFromRepoKernel
   2373  22d4
   2374  22d4							;-------------------------------------------------------------------------
   2375  22d4
   2376  22d4
   2377  22d4				   SwitchDrawP0KV		;	69
   2378  22d4		       a5 a4		      lda	P0Bottom
   2379  22d6		       85 cf		      sta	P0Top	;+6	75
   2380  22d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2381  22db
   2382  22db				   WaitDrawP0KV 		;	71
      0  22db					      SLEEP	4	;+4	75
      1  22db				   .CYCLES    SET	4
      2  22db
      3  22db				  -	      IF	.CYCLES < 2
      4  22db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22db				  -	      ERR
      6  22db					      ENDIF
      7  22db
      8  22db				  -	      IF	.CYCLES & 1
      9  22db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22db				  -	      nop	0
     11  22db				  -	      ELSE
     12  22db				  -	      bit	VSYNC
     13  22db				  -	      ENDIF
     14  22db				  -.CYCLES    SET	.CYCLES - 3
     15  22db					      ENDIF
     16  22db
     17  22db					      REPEAT	.CYCLES / 2
     18  22db		       ea		      nop
     17  22db					      REPEND
     18  22dc		       ea		      nop
     19  22dd					      REPEND
   2384  22dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2385  22e0
   2386  22e0							;-------------------------------------------------------------------------
   2387  22e0
   2388  22e0				   DoneWithKernel
   2389  22e0
   2390  22e0				   BottomOfKernelLoop
   2391  22e0
   2392  22e0		       85 02		      sta	WSYNC
   2393  22e2		       a6 f6		      ldx	stack1
   2394  22e4		       9a		      txs
   2395  22e5		       20 04 f1 	      jsr	sixdigscore	; set up score
   2396  22e8
   2397  22e8
   2398  22e8		       85 02		      sta	WSYNC
   2399  22ea		       a2 00		      ldx	#0
   2400  22ec		       85 2b		      sta	HMCLR
   2401  22ee		       86 1b		      STx	GRP0
   2402  22f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2403  22f2
   2404  22f2		       a0 07		      LDY	#7
   2405  22f4		       84 25		      STy	VDELP0
   2406  22f6		       84 26		      STy	VDELP1
   2407  22f8		       a9 10		      LDA	#$10
   2408  22fa		       85 21		      STA	HMP1
   2409  22fc		       a5 d5		      LDA	scorecolor
   2410  22fe		       85 06		      STA	COLUP0
   2411  2300		       85 07		      STA	COLUP1
   2412  2302
   2413  2302		       a9 03		      LDA	#$03
   2414  2304		       85 04		      STA	NUSIZ0
   2415  2306		       85 05		      STA	NUSIZ1
   2416  2308
   2417  2308		       85 10		      STA	RESP0
   2418  230a		       85 11		      STA	RESP1
   2419  230c
      0  230c					      sleep	9
      1  230c				   .CYCLES    SET	9
      2  230c
      3  230c				  -	      IF	.CYCLES < 2
      4  230c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  230c				  -	      ERR
      6  230c					      ENDIF
      7  230c
      8  230c					      IF	.CYCLES & 1
      9  230c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  230c		       04 00		      nop	0
     11  230e				  -	      ELSE
     12  230e				  -	      bit	VSYNC
     13  230e					      ENDIF
     14  230e				   .CYCLES    SET	.CYCLES - 3
     15  230e					      ENDIF
     16  230e
     17  230e					      REPEAT	.CYCLES / 2
     18  230e		       ea		      nop
     17  230e					      REPEND
     18  230f		       ea		      nop
     17  230f					      REPEND
     18  2310		       ea		      nop
     19  2311					      REPEND
   2421  2311		       b1 c5		      lda	(scorepointers),y
   2422  2313		       85 1b		      sta	GRP0
   2423  2315					      ifconst	pfscore
   2424  2315		       a5 c0		      lda	pfscorecolor
   2425  2317		       85 08		      sta	COLUPF
   2426  2319				  -	      else
   2427  2319				  -	      sleep	6
   2428  2319					      endif
   2429  2319
   2430  2319		       85 2a		      STA	HMOVE
   2431  231b		       b1 cd		      lda	(scorepointers+8),y
   2432  231d							; sta WSYNC
   2433  231d							;sleep 2
   2434  231d		       4c 2b f3 	      jmp	beginscore
   2435  2320
   2436  2320
   2437  2320				   loop2
   2438  2320		       b1 c5		      lda	(scorepointers),y	;+5  68  204
   2439  2322		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
   2440  2324					      ifconst	pfscore
   2441  2324		       ad c1 00 	      lda.w	pfscore1
   2442  2327		       85 0e		      sta	PF1
   2443  2329				  -	      else
   2444  2329				  -	      sleep	7
   2445  2329					      endif
   2446  2329							; cycle 0
   2447  2329		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
   2448  232b				   beginscore
   2449  232b		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
   2450  232d		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
   2451  232f		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
   2452  2331		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
   2453  2333		       9a		      txs
   2454  2334		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  2336					      sleep	3
      1  2336				   .CYCLES    SET	3
      2  2336
      3  2336				  -	      IF	.CYCLES < 2
      4  2336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2336				  -	      ERR
      6  2336					      ENDIF
      7  2336
      8  2336					      IF	.CYCLES & 1
      9  2336					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2336		       04 00		      nop	0
     11  2338				  -	      ELSE
     12  2338				  -	      bit	VSYNC
     13  2338					      ENDIF
     14  2338				   .CYCLES    SET	.CYCLES - 3
     15  2338					      ENDIF
     16  2338
     17  2338				  -	      REPEAT	.CYCLES / 2
     18  2338				  -	      nop
     19  2338					      REPEND
   2456  2338					      ifconst	pfscore
   2457  2338		       a5 c2		      lda	pfscore2
   2458  233a		       85 0e		      sta	PF1
   2459  233c				  -	      else
   2460  233c				  -	      sleep	6
   2461  233c					      endif
   2462  233c		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
   2463  233e		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
   2464  2340		       ba		      tsx
   2465  2341		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
   2466  2343		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
   2467  2345		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
   2468  2347		       88		      dey
   2469  2348		       10 d6		      bpl	loop2	;+2  60  180
   2470  234a		       a6 f6		      ldx	stack1
   2471  234c		       9a		      txs
   2472  234d
   2473  234d
   2474  234d							; lda scorepointers+1
   2475  234d		       a4 cb		      ldy	temp1
   2476  234f							; sta temp1
   2477  234f		       84 c6		      sty	scorepointers+1
   2478  2351
   2479  2351		       a9 00		      LDA	#0
   2480  2353		       85 1b		      STA	GRP0
   2481  2355		       85 1c		      STA	GRP1
   2482  2357		       85 0e		      sta	PF1
   2483  2359		       85 25		      STA	VDELP0
   2484  235b		       85 26		      STA	VDELP1	;do we need these
   2485  235d		       85 04		      STA	NUSIZ0
   2486  235f		       85 05		      STA	NUSIZ1
   2487  2361
   2488  2361							; lda scorepointers+3
   2489  2361		       a4 cd		      ldy	temp3
   2490  2363							; sta temp3
   2491  2363		       84 c8		      sty	scorepointers+3
   2492  2365
   2493  2365							; lda scorepointers+5
   2494  2365		       a4 cf		      ldy	temp5
   2495  2367							; sta temp5
   2496  2367		       84 ca		      sty	scorepointers+5
   2497  2369
   2498  2369
   2499  2369							;-------------------------------------------------------------------------
   2500  2369							;------------------------Overscan Routine---------------------------------
   2501  2369							;-------------------------------------------------------------------------
   2502  2369
   2503  2369				   OverscanRoutine
   2504  2369
   2505  2369
   2506  2369
   2507  2369				   skipscore
   2508  2369		       a9 02		      lda	#2
   2509  236b		       85 02		      sta	WSYNC
   2510  236d		       85 01		      sta	VBLANK	;turn on VBLANK
   2511  236f
   2512  236f
   2513  236f
   2514  236f
   2515  236f
   2516  236f							;-------------------------------------------------------------------------
   2517  236f							;----------------------------End Main Routines----------------------------
   2518  236f							;-------------------------------------------------------------------------
   2519  236f
   2520  236f
   2521  236f							;*************************************************************************
   2522  236f
   2523  236f							;-------------------------------------------------------------------------
   2524  236f							;----------------------Begin Subroutines----------------------------------
   2525  236f							;-------------------------------------------------------------------------
   2526  236f
   2527  236f
   2528  236f
   2529  236f
   2530  236f				   KernelCleanupSubroutine
   2531  236f
   2532  236f		       a2 04		      ldx	#4
   2533  2371				   AdjustYValuesDownLoop
   2534  2371		       b5 8e		      lda	NewSpriteY,X
   2535  2373		       38		      sec
   2536  2374		       e9 02		      sbc	#2
   2537  2376		       95 8e		      sta	NewSpriteY,X
   2538  2378		       ca		      dex
   2539  2379		       10 f6		      bpl	AdjustYValuesDownLoop
   2540  237b
   2541  237b
      0  237b					      RETURN
      1  237b				  -	      ifnconst	bankswitch
      2  237b				  -	      rts
      3  237b					      else
      4  237b		       4c dd ff 	      jmp	BS_return
      5  237e					      endif
   2543  237e							;rts
   2544  237e
   2545  237e				   SetupP1Subroutine
   2546  237e							; flickersort algorithm
   2547  237e							; count 4-0
   2548  237e							; table2=table1 (?)
   2549  237e							; detect overlap of sprites in table 2
   2550  237e							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
   2551  237e							; if no overlap, do regular sort in table 2 and table 1
   2552  237e				   fsstart
   2553  237e		       a2 ff		      ldx	#255
   2554  2380				   copytable
   2555  2380		       e8		      inx
   2556  2381		       b5 f1		      lda	spritesort,x
   2557  2383		       95 9d		      sta	SpriteGfxIndex,x
   2558  2385		       e0 04		      cpx	#4
   2559  2387		       d0 f7		      bne	copytable
   2560  2389
   2561  2389		       86 cd		      stx	temp3	; highest displayed sprite
   2562  238b		       ca		      dex
   2563  238c		       86 cc		      stx	temp2
   2564  238e				   sortloop
   2565  238e		       a6 cc		      ldx	temp2
   2566  2390		       b5 f1		      lda	spritesort,x
   2567  2392		       aa		      tax
   2568  2393		       b5 8e		      lda	NewSpriteY,x
   2569  2395		       85 cb		      sta	temp1
   2570  2397
   2571  2397		       a6 cc		      ldx	temp2
   2572  2399		       b5 f2		      lda	spritesort+1,x
   2573  239b		       aa		      tax
   2574  239c		       b5 8e		      lda	NewSpriteY,x
   2575  239e		       38		      sec
   2576  239f		       18		      clc
   2577  23a0		       e5 cb		      sbc	temp1
   2578  23a2		       90 0e		      bcc	largerXislower
   2579  23a4
   2580  23a4							; larger x is higher (A>=temp1)
   2581  23a4		       d5 b1		      cmp	spriteheight,x
   2582  23a6		       b0 2f		      bcs	countdown
   2583  23a8							; overlap with x+1>x
   2584  23a8							; 
   2585  23a8							; stick x at end of gfxtable, dec counter
   2586  23a8				   overlapping
   2587  23a8		       c6 cd		      dec	temp3
   2588  23aa		       a6 cc		      ldx	temp2
   2589  23ac							; inx
   2590  23ac		       20 eb f3 	      jsr	shiftnumbers
   2591  23af		       4c cd f3 	      jmp	skipswapGfxtable
   2592  23b2
   2593  23b2				   largerXislower		; (temp1>A)
   2594  23b2		       a8		      tay
   2595  23b3		       a6 cc		      ldx	temp2
   2596  23b5		       b5 f1		      lda	spritesort,x
   2597  23b7		       aa		      tax
   2598  23b8		       98		      tya
   2599  23b9		       49 ff		      eor	#$FF
   2600  23bb		       e9 01		      sbc	#1
   2601  23bd		       90 e9		      bcc	overlapping
   2602  23bf		       d5 b1		      cmp	spriteheight,x
   2603  23c1		       b0 0a		      bcs	notoverlapping
   2604  23c3
   2605  23c3		       c6 cd		      dec	temp3
   2606  23c5		       a6 cc		      ldx	temp2
   2607  23c7							; inx
   2608  23c7		       20 eb f3 	      jsr	shiftnumbers
   2609  23ca		       4c cd f3 	      jmp	skipswapGfxtable
   2610  23cd				   notoverlapping
   2611  23cd							; ldx temp2 ; swap display table
   2612  23cd							; ldy SpriteGfxIndex+1,x
   2613  23cd							; lda SpriteGfxIndex,x
   2614  23cd							; sty SpriteGfxIndex,x
   2615  23cd							; sta SpriteGfxIndex+1,x 
   2616  23cd
   2617  23cd				   skipswapGfxtable
   2618  23cd		       a6 cc		      ldx	temp2	; swap sort table
   2619  23cf		       b4 f2		      ldy	spritesort+1,x
   2620  23d1		       b5 f1		      lda	spritesort,x
   2621  23d3		       94 f1		      sty	spritesort,x
   2622  23d5		       95 f2		      sta	spritesort+1,x
   2623  23d7
   2624  23d7				   countdown
   2625  23d7		       c6 cc		      dec	temp2
   2626  23d9		       10 b3		      bpl	sortloop
   2627  23db
   2628  23db				   checktoohigh
   2629  23db		       a6 cd		      ldx	temp3
   2630  23dd		       b5 9d		      lda	SpriteGfxIndex,x
   2631  23df		       aa		      tax
   2632  23e0		       b5 8e		      lda	NewSpriteY,x
   2633  23e2				  -	      ifconst	screenheight
   2634  23e2				  -	      cmp	#screenheight-3
   2635  23e2					      else
   2636  23e2		       c9 55		      cmp	#$55
   2637  23e4					      endif
   2638  23e4		       90 04		      bcc	nonetoohigh
   2639  23e6		       c6 cd		      dec	temp3
   2640  23e8		       d0 f1		      bne	checktoohigh
   2641  23ea
   2642  23ea				   nonetoohigh
   2643  23ea		       60		      rts
   2644  23eb
   2645  23eb
   2646  23eb				   shiftnumbers
   2647  23eb							; stick current x at end, shift others down
   2648  23eb							; if x=4: don't do anything
   2649  23eb							; if x=3: swap 3 and 4
   2650  23eb							; if x=2: 2=3, 3=4, 4=2
   2651  23eb							; if x=1: 1=2, 2=3, 3=4, 4=1
   2652  23eb							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   2653  23eb							; ldy SpriteGfxIndex,x
   2654  23eb				   swaploop
   2655  23eb		       e0 04		      cpx	#4
   2656  23ed		       f0 08		      beq	shiftdone
   2657  23ef		       b5 9e		      lda	SpriteGfxIndex+1,x
   2658  23f1		       95 9d		      sta	SpriteGfxIndex,x
   2659  23f3		       e8		      inx
   2660  23f4		       4c eb f3 	      jmp	swaploop
   2661  23f7				   shiftdone
   2662  23f7							; sty SpriteGfxIndex,x
   2663  23f7		       60		      rts
   2664  23f8
   2665  23f8				  -	      ifconst	debugscore
   2666  23f8				  -debugcycles
   2667  23f8				  -	      ldx	#14
   2668  23f8				  -	      lda	INTIM	; display # cycles left in the score
   2669  23f8				  -
   2670  23f8				  -	      ifconst	mincycles
   2671  23f8				  -	      lda	mincycles
   2672  23f8				  -	      cmp	INTIM
   2673  23f8				  -	      lda	mincycles
   2674  23f8				  -	      bcc	nochange
   2675  23f8				  -	      lda	INTIM
   2676  23f8				  -	      sta	mincycles
   2677  23f8				  -nochange
   2678  23f8				  -	      endif
   2679  23f8				  -
   2680  23f8				  -			;   cmp #$2B
   2681  23f8				  -			;   bcs no_cycles_left
   2682  23f8				  -	      bmi	cycles_left
   2683  23f8				  -	      ldx	#64
   2684  23f8				  -	      eor	#$ff	;make negative
   2685  23f8				  -cycles_left
   2686  23f8				  -	      stx	scorecolor
   2687  23f8				  -	      and	#$7f	; clear sign bit
   2688  23f8				  -	      tax
   2689  23f8				  -	      lda	scorebcd,x
   2690  23f8				  -	      sta	score+2
   2691  23f8				  -	      lda	scorebcd1,x
   2692  23f8				  -	      sta	score+1
   2693  23f8				  -	      rts
   2694  23f8				  -scorebcd
   2695  23f8				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2696  23f8				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2697  23f8				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2698  23f8				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2699  23f8				  -scorebcd1
   2700  23f8				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2701  23f8				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2702  23f8				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2703  23f8				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2704  23f8					      endif
   2705  23f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2706  23f8
   2707  23f8				   start
   2708  23f8		       78		      sei
   2709  23f9		       d8		      cld
   2710  23fa		       a0 00		      ldy	#0
   2711  23fc		       a5 d0		      lda	$D0
   2712  23fe		       c9 2c		      cmp	#$2C	;check RAM location #1
   2713  2400		       d0 07		      bne	MachineIs2600
   2714  2402		       a5 d1		      lda	$D1
   2715  2404		       c9 a9		      cmp	#$A9	;check RAM location #2
   2716  2406		       d0 01		      bne	MachineIs2600
   2717  2408		       88		      dey
   2718  2409				   MachineIs2600
   2719  2409		       a2 00		      ldx	#0
   2720  240b		       8a		      txa
   2721  240c				   clearmem
   2722  240c		       e8		      inx
   2723  240d		       9a		      txs
   2724  240e		       48		      pha
   2725  240f		       d0 fb		      bne	clearmem
   2726  2411		       84 cb		      sty	temp1
   2727  2413				  -	      ifnconst	multisprite
   2728  2413				  -	      ifconst	pfrowheight
   2729  2413				  -	      lda	#pfrowheight
   2730  2413				  -	      else
   2731  2413				  -	      ifconst	pfres
   2732  2413				  -	      lda	#(96/pfres)
   2733  2413				  -	      else
   2734  2413				  -	      lda	#8
   2735  2413				  -	      endif
   2736  2413				  -	      endif
   2737  2413				  -	      sta	playfieldpos
   2738  2413					      endif
   2739  2413		       a2 05		      ldx	#5
   2740  2415				   initscore
   2741  2415		       a9 74		      lda	#<scoretable
   2742  2417		       95 c5		      sta	scorepointers,x
   2743  2419		       ca		      dex
   2744  241a		       10 f9		      bpl	initscore
   2745  241c		       a9 01		      lda	#1
   2746  241e		       85 0a		      sta	CTRLPF
   2747  2420		       0d 84 02 	      ora	INTIM
   2748  2423		       85 d6		      sta	rand
   2749  2425
   2750  2425					      ifconst	multisprite
   2751  2425		       20 1f f0 	      jsr	multisprite_setup
   2752  2428					      endif
   2753  2428
   2754  2428				  -	      ifnconst	bankswitch
   2755  2428				  -	      jmp	game
   2756  2428					      else
   2757  2428		       a9 cf		      lda	#>(game-1)
   2758  242a		       48		      pha
   2759  242b		       a9 ff		      lda	#<(game-1)
   2760  242d		       48		      pha
   2761  242e		       48		      pha
   2762  242f		       48		      pha
   2763  2430		       a2 01		      ldx	#1
   2764  2432		       4c eb ff 	      jmp	BS_jsr
   2765  2435					      endif
   2766  2435							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2767  2435
   2768  2435							;standard routines needed for pretty much all games
   2769  2435							; just the random number generator is left - maybe we should remove this asm file altogether?
   2770  2435							; repositioning code and score pointer setup moved to overscan
   2771  2435							; read switches, joysticks now compiler generated (more efficient)
   2772  2435
   2773  2435				   randomize
   2774  2435		       a5 d6		      lda	rand
   2775  2437		       4a		      lsr
   2776  2438				  -	      ifconst	rand16
   2777  2438				  -	      rol	rand16
   2778  2438					      endif
   2779  2438		       90 02		      bcc	noeor
   2780  243a		       49 b4		      eor	#$B4
   2781  243c				   noeor
   2782  243c		       85 d6		      sta	rand
   2783  243e				  -	      ifconst	rand16
   2784  243e				  -	      eor	rand16
   2785  243e					      endif
      0  243e					      RETURN
      1  243e				  -	      ifnconst	bankswitch
      2  243e				  -	      rts
      3  243e					      else
      4  243e		       4c dd ff 	      jmp	BS_return
      5  2441					      endif
   2787  2441							;bB.asm
   2788  2441							; bB.asm file is split here
   2789  2441				  -	      if	(<*) > (<(*+8))
   2790  2441				  -	      repeat	($100-<*)
   2791  2441				  -	      .byte	0
   2792  2441				  -	      repend
   2793  2441					      endif
   2794  2441					      if	(<*) < 90
   2795  2441					      repeat	(90-<*)
   2796  2441		       00		      .byte.b	0
   2795  2441					      repend
   2796  2442		       00		      .byte.b	0
   2795  2442					      repend
   2796  2443		       00		      .byte.b	0
   2795  2443					      repend
   2796  2444		       00		      .byte.b	0
   2795  2444					      repend
   2796  2445		       00		      .byte.b	0
   2795  2445					      repend
   2796  2446		       00		      .byte.b	0
   2795  2446					      repend
   2796  2447		       00		      .byte.b	0
   2795  2447					      repend
   2796  2448		       00		      .byte.b	0
   2795  2448					      repend
   2796  2449		       00		      .byte.b	0
   2795  2449					      repend
   2796  244a		       00		      .byte.b	0
   2795  244a					      repend
   2796  244b		       00		      .byte.b	0
   2795  244b					      repend
   2796  244c		       00		      .byte.b	0
   2795  244c					      repend
   2796  244d		       00		      .byte.b	0
   2795  244d					      repend
   2796  244e		       00		      .byte.b	0
   2795  244e					      repend
   2796  244f		       00		      .byte.b	0
   2795  244f					      repend
   2796  2450		       00		      .byte.b	0
   2795  2450					      repend
   2796  2451		       00		      .byte.b	0
   2795  2451					      repend
   2796  2452		       00		      .byte.b	0
   2795  2452					      repend
   2796  2453		       00		      .byte.b	0
   2795  2453					      repend
   2796  2454		       00		      .byte.b	0
   2795  2454					      repend
   2796  2455		       00		      .byte.b	0
   2795  2455					      repend
   2796  2456		       00		      .byte.b	0
   2795  2456					      repend
   2796  2457		       00		      .byte.b	0
   2795  2457					      repend
   2796  2458		       00		      .byte.b	0
   2795  2458					      repend
   2796  2459		       00		      .byte.b	0
   2797  245a					      repend
   2798  245a					      endif
   2799  245a				   player15then_0
   2800  245a		       00		      .byte.b	0
   2801  245b		       00		      .byte.b	%00000000
   2802  245c		       82		      .byte.b	%10000010
   2803  245d		       44		      .byte.b	%01000100
   2804  245e		       fe		      .byte.b	%11111110
   2805  245f		       fe		      .byte.b	%11111110
   2806  2460		       ba		      .byte.b	%10111010
   2807  2461		       7c		      .byte.b	%01111100
   2808  2462		       82		      .byte.b	%10000010
   2809  2463				  -	      if	(<*) > (<(*+8))
   2810  2463				  -	      repeat	($100-<*)
   2811  2463				  -	      .byte	0
   2812  2463				  -	      repend
   2813  2463					      endif
   2814  2463				  -	      if	(<*) < 90
   2815  2463				  -	      repeat	(90-<*)
   2816  2463				  -	      .byte	0
   2817  2463				  -	      repend
   2818  2463					      endif
   2819  2463				   player17then_0
   2820  2463		       00		      .byte.b	0
   2821  2464		       00		      .byte.b	%00000000
   2822  2465		       28		      .byte.b	%00101000
   2823  2466		       44		      .byte.b	%01000100
   2824  2467		       fe		      .byte.b	%11111110
   2825  2468		       fe		      .byte.b	%11111110
   2826  2469		       ba		      .byte.b	%10111010
   2827  246a		       7c		      .byte.b	%01111100
   2828  246b		       44		      .byte.b	%01000100
   2829  246c				  -	      if	(<*) > (<(*+7))
   2830  246c				  -	      repeat	($100-<*)
   2831  246c				  -	      .byte	0
   2832  246c				  -	      repend
   2833  246c					      endif
   2834  246c				  -	      if	(<*) < 90
   2835  246c				  -	      repeat	(90-<*)
   2836  246c				  -	      .byte	0
   2837  246c				  -	      repend
   2838  246c					      endif
   2839  246c				   playerL056_2
   2840  246c		       00		      .byte.b	%00000000
   2841  246d		       00		      .byte.b	%00000000
   2842  246e		       10		      .byte.b	%00010000
   2843  246f		       20		      .byte.b	%00100000
   2844  2470		       10		      .byte.b	%00010000
   2845  2471		       08		      .byte.b	%00001000
   2846  2472		       10		      .byte.b	%00010000
   2847  2473		       00		      .byte.b	%00000000
   2848  2474				  -	      if	(<*) > (<(*+8))
   2849  2474				  -	      repeat	($100-<*)
   2850  2474				  -	      .byte	0
   2851  2474				  -	      repend
   2852  2474					      endif
   2853  2474				  -	      if	(<*) < 90
   2854  2474				  -	      repeat	(90-<*)
   2855  2474				  -	      .byte	0
   2856  2474				  -	      repend
   2857  2474					      endif
   2858  2474				   player47then_0
   2859  2474		       00		      .byte.b	0
   2860  2475		       00		      .byte.b	%00000000
   2861  2476		       92		      .byte.b	%10010010
   2862  2477		       54		      .byte.b	%01010100
   2863  2478		       00		      .byte.b	%00000000
   2864  2479		       d6		      .byte.b	%11010110
   2865  247a		       00		      .byte.b	%00000000
   2866  247b		       54		      .byte.b	%01010100
   2867  247c		       92		      .byte.b	%10010010
   2868  247d				  -	      if	(<*) > (<(*+8))
   2869  247d				  -	      repeat	($100-<*)
   2870  247d				  -	      .byte	0
   2871  247d				  -	      repend
   2872  247d					      endif
   2873  247d				  -	      if	(<*) < 90
   2874  247d				  -	      repeat	(90-<*)
   2875  247d				  -	      .byte	0
   2876  247d				  -	      repend
   2877  247d					      endif
   2878  247d				   playerL070_0
   2879  247d		       00		      .byte.b	0
   2880  247e		       00		      .byte.b	%00000000
   2881  247f		       82		      .byte.b	%10000010
   2882  2480		       44		      .byte.b	%01000100
   2883  2481		       fe		      .byte.b	%11111110
   2884  2482		       fe		      .byte.b	%11111110
   2885  2483		       ba		      .byte.b	%10111010
   2886  2484		       7c		      .byte.b	%01111100
   2887  2485		       82		      .byte.b	%10000010
   2888  2486				  -	      if	(<*) > (<(*+7))
   2889  2486				  -	      repeat	($100-<*)
   2890  2486				  -	      .byte	0
   2891  2486				  -	      repend
   2892  2486					      endif
   2893  2486				  -	      if	(<*) < 90
   2894  2486				  -	      repeat	(90-<*)
   2895  2486				  -	      .byte	0
   2896  2486				  -	      repend
   2897  2486					      endif
   2898  2486				   playerL073_1
   2899  2486		       fe		      .byte.b	%11111110
   2900  2487		       fe		      .byte.b	%11111110
   2901  2488		       7c		      .byte.b	%01111100
   2902  2489		       10		      .byte.b	%00010000
   2903  248a		       00		      .byte.b	%00000000
   2904  248b		       00		      .byte.b	%00000000
   2905  248c		       00		      .byte.b	%00000000
   2906  248d		       00		      .byte.b	%00000000
   2907  248e				  -	      if	(<*) > (<(*+7))
   2908  248e				  -	      repeat	($100-<*)
   2909  248e				  -	      .byte	0
   2910  248e				  -	      repend
   2911  248e					      endif
   2912  248e				  -	      if	(<*) < 90
   2913  248e				  -	      repeat	(90-<*)
   2914  248e				  -	      .byte	0
   2915  248e				  -	      repend
   2916  248e					      endif
   2917  248e				   playerL079_3
   2918  248e		       00		      .byte.b	%00000000
   2919  248f		       00		      .byte.b	%00000000
   2920  2490		       00		      .byte.b	%00000000
   2921  2491		       10		      .byte.b	%00010000
   2922  2492		       10		      .byte.b	%00010000
   2923  2493		       00		      .byte.b	%00000000
   2924  2494		       00		      .byte.b	%00000000
   2925  2495		       00		      .byte.b	%00000000
   2926  2496				  -	      if	(<*) > (<(*+7))
   2927  2496				  -	      repeat	($100-<*)
   2928  2496				  -	      .byte	0
   2929  2496				  -	      repend
   2930  2496					      endif
   2931  2496				  -	      if	(<*) < 90
   2932  2496				  -	      repeat	(90-<*)
   2933  2496				  -	      .byte	0
   2934  2496				  -	      repend
   2935  2496					      endif
   2936  2496				   player62then_1
   2937  2496		       b6		      .byte.b	%10110110
   2938  2497		       4a		      .byte.b	%01001010
   2939  2498		       24		      .byte.b	%00100100
   2940  2499		       90		      .byte.b	%10010000
   2941  249a		       44		      .byte.b	%01000100
   2942  249b		       00		      .byte.b	%00000000
   2943  249c		       00		      .byte.b	%00000000
   2944  249d		       00		      .byte.b	%00000000
   2945  249e				  -	      if	(<*) > (<(*+7))
   2946  249e				  -	      repeat	($100-<*)
   2947  249e				  -	      .byte	0
   2948  249e				  -	      repend
   2949  249e					      endif
   2950  249e				  -	      if	(<*) < 90
   2951  249e				  -	      repeat	(90-<*)
   2952  249e				  -	      .byte	0
   2953  249e				  -	      repend
   2954  249e					      endif
   2955  249e				   player63then_1
   2956  249e		       ea		      .byte.b	%11101010
   2957  249f		       14		      .byte.b	%00010100
   2958  24a0		       40		      .byte.b	%01000000
   2959  24a1		       04		      .byte.b	%00000100
   2960  24a2		       20		      .byte.b	%00100000
   2961  24a3		       00		      .byte.b	%00000000
   2962  24a4		       00		      .byte.b	%00000000
   2963  24a5		       00		      .byte.b	%00000000
   2964  24a6				  -	      if	(<*) > (<(*+7))
   2965  24a6				  -	      repeat	($100-<*)
   2966  24a6				  -	      .byte	0
   2967  24a6				  -	      repend
   2968  24a6					      endif
   2969  24a6				  -	      if	(<*) < 90
   2970  24a6				  -	      repeat	(90-<*)
   2971  24a6				  -	      .byte	0
   2972  24a6				  -	      repend
   2973  24a6					      endif
   2974  24a6				   player64then_1
   2975  24a6		       b6		      .byte.b	%10110110
   2976  24a7		       4a		      .byte.b	%01001010
   2977  24a8		       24		      .byte.b	%00100100
   2978  24a9		       90		      .byte.b	%10010000
   2979  24aa		       44		      .byte.b	%01000100
   2980  24ab		       00		      .byte.b	%00000000
   2981  24ac		       00		      .byte.b	%00000000
   2982  24ad		       00		      .byte.b	%00000000
   2983  24ae				  -	      if	(<*) > (<(*+7))
   2984  24ae				  -	      repeat	($100-<*)
   2985  24ae				  -	      .byte	0
   2986  24ae				  -	      repend
   2987  24ae					      endif
   2988  24ae				  -	      if	(<*) < 90
   2989  24ae				  -	      repeat	(90-<*)
   2990  24ae				  -	      .byte	0
   2991  24ae				  -	      repend
   2992  24ae					      endif
   2993  24ae				   player65then_1
   2994  24ae		       ea		      .byte.b	%11101010
   2995  24af		       14		      .byte.b	%00010100
   2996  24b0		       40		      .byte.b	%01000000
   2997  24b1		       04		      .byte.b	%00000100
   2998  24b2		       20		      .byte.b	%00100000
   2999  24b3		       00		      .byte.b	%00000000
   3000  24b4		       00		      .byte.b	%00000000
   3001  24b5		       00		      .byte.b	%00000000
   3002  24b6				  -	      if	(<*) > (<(*+7))
   3003  24b6				  -	      repeat	($100-<*)
   3004  24b6				  -	      .byte	0
   3005  24b6				  -	      repend
   3006  24b6					      endif
   3007  24b6				  -	      if	(<*) < 90
   3008  24b6				  -	      repeat	(90-<*)
   3009  24b6				  -	      .byte	0
   3010  24b6				  -	      repend
   3011  24b6					      endif
   3012  24b6				   player66then_1
   3013  24b6		       b6		      .byte.b	%10110110
   3014  24b7		       4a		      .byte.b	%01001010
   3015  24b8		       24		      .byte.b	%00100100
   3016  24b9		       90		      .byte.b	%10010000
   3017  24ba		       44		      .byte.b	%01000100
   3018  24bb		       00		      .byte.b	%00000000
   3019  24bc		       00		      .byte.b	%00000000
   3020  24bd		       00		      .byte.b	%00000000
   3021  24be				  -	      if	(<*) > (<(*+7))
   3022  24be				  -	      repeat	($100-<*)
   3023  24be				  -	      .byte	0
   3024  24be				  -	      repend
   3025  24be					      endif
   3026  24be				  -	      if	(<*) < 90
   3027  24be				  -	      repeat	(90-<*)
   3028  24be				  -	      .byte	0
   3029  24be				  -	      repend
   3030  24be					      endif
   3031  24be				   player67then_1
   3032  24be		       ea		      .byte.b	%11101010
   3033  24bf		       14		      .byte.b	%00010100
   3034  24c0		       40		      .byte.b	%01000000
   3035  24c1		       04		      .byte.b	%00000100
   3036  24c2		       20		      .byte.b	%00100000
   3037  24c3		       00		      .byte.b	%00000000
   3038  24c4		       00		      .byte.b	%00000000
   3039  24c5		       00		      .byte.b	%00000000
   3040  24c6				  -	      if	(<*) > (<(*+24))
   3041  24c6				  -	      repeat	($100-<*)
   3042  24c6				  -	      .byte	0
   3043  24c6				  -	      repend
   3044  24c6					      endif
   3045  24c6				  -	      if	(<*) < 90
   3046  24c6				  -	      repeat	(90-<*)
   3047  24c6				  -	      .byte	0
   3048  24c6				  -	      repend
   3049  24c6					      endif
   3050  24c6				   playerL097_2
   3051  24c6		       00		      .byte.b	%00000000
   3052  24c7		       00		      .byte.b	%00000000
   3053  24c8		       00		      .byte.b	%00000000
   3054  24c9		       00		      .byte.b	%00000000
   3055  24ca		       00		      .byte.b	%00000000
   3056  24cb		       f8		      .byte.b	%11111000
   3057  24cc		       80		      .byte.b	%10000000
   3058  24cd		       c0		      .byte.b	%11000000
   3059  24ce		       80		      .byte.b	%10000000
   3060  24cf		       f8		      .byte.b	%11111000
   3061  24d0		       00		      .byte.b	%00000000
   3062  24d1		       88		      .byte.b	%10001000
   3063  24d2		       88		      .byte.b	%10001000
   3064  24d3		       a8		      .byte.b	%10101000
   3065  24d4		       f8		      .byte.b	%11111000
   3066  24d5		       00		      .byte.b	%00000000
   3067  24d6		       88		      .byte.b	%10001000
   3068  24d7		       f8		      .byte.b	%11111000
   3069  24d8		       88		      .byte.b	%10001000
   3070  24d9		       f8		      .byte.b	%11111000
   3071  24da		       00		      .byte.b	%00000000
   3072  24db		       f8		      .byte.b	%11111000
   3073  24dc		       88		      .byte.b	%10001000
   3074  24dd		       80		      .byte.b	%10000000
   3075  24de		       f8		      .byte.b	%11111000
   3076  24df				  -	      if	(<*) > (<(*+24))
   3077  24df				  -	      repeat	($100-<*)
   3078  24df				  -	      .byte	0
   3079  24df				  -	      repend
   3080  24df					      endif
   3081  24df				  -	      if	(<*) < 90
   3082  24df				  -	      repeat	(90-<*)
   3083  24df				  -	      .byte	0
   3084  24df				  -	      repend
   3085  24df					      endif
   3086  24df				   playerL098_3
   3087  24df		       00		      .byte.b	%00000000
   3088  24e0		       00		      .byte.b	%00000000
   3089  24e1		       00		      .byte.b	%00000000
   3090  24e2		       00		      .byte.b	%00000000
   3091  24e3		       00		      .byte.b	%00000000
   3092  24e4		       88		      .byte.b	%10001000
   3093  24e5		       f0		      .byte.b	%11110000
   3094  24e6		       88		      .byte.b	%10001000
   3095  24e7		       f8		      .byte.b	%11111000
   3096  24e8		       00		      .byte.b	%00000000
   3097  24e9		       f8		      .byte.b	%11111000
   3098  24ea		       80		      .byte.b	%10000000
   3099  24eb		       c0		      .byte.b	%11000000
   3100  24ec		       80		      .byte.b	%10000000
   3101  24ed		       f8		      .byte.b	%11111000
   3102  24ee		       00		      .byte.b	%00000000
   3103  24ef		       20		      .byte.b	%00100000
   3104  24f0		       50		      .byte.b	%01010000
   3105  24f1		       88		      .byte.b	%10001000
   3106  24f2		       88		      .byte.b	%10001000
   3107  24f3		       00		      .byte.b	%00000000
   3108  24f4		       f8		      .byte.b	%11111000
   3109  24f5		       88		      .byte.b	%10001000
   3110  24f6		       88		      .byte.b	%10001000
   3111  24f7		       f8		      .byte.b	%11111000
   3112  24f8					      if	ECHOFIRST
      2684 bytes of ROM space left in bank 2
   3113  24f8					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   3114  24f8					      endif
   3115  24f8		       00 01	   ECHOFIRST  =	1
   3116  24f8
   3117  24f8
   3118  24f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3119  24f8
   3120  24f8							; feel free to modify the score graphics - just keep each digit 8 high
   3121  24f8							; and keep the conditional compilation stuff intact
   3122  24f8				  -	      ifconst	ROM2k
   3123  24f8				  -	      ORG	$F7AC-8
   3124  24f8					      else
   3125  24f8					      ifconst	bankswitch
   3126  24f8					      if	bankswitch == 8
   3127  2f74					      ORG	$2F94-bscode_length
   3128  2f74					      RORG	$FF94-bscode_length
   3129  2f74					      endif
   3130  2f74				  -	      if	bankswitch == 16
   3131  2f74				  -	      ORG	$4F94-bscode_length
   3132  2f74				  -	      RORG	$FF94-bscode_length
   3133  2f74					      endif
   3134  2f74				  -	      if	bankswitch == 32
   3135  2f74				  -	      ORG	$8F94-bscode_length
   3136  2f74				  -	      RORG	$FF94-bscode_length
   3137  2f74					      endif
   3138  2f74				  -	      if	bankswitch == 64
   3139  2f74				  -	      ORG	$10F80-bscode_length
   3140  2f74				  -	      RORG	$1FF80-bscode_length
   3141  2f74					      endif
   3142  2f74				  -	      else
   3143  2f74				  -	      ORG	$FF9C
   3144  2f74					      endif
   3145  2f74					      endif
   3146  2f74
   3147  2f74							; font equates
   3148  2f74		       00 01	   .21stcentury =	1
   3149  2f74		       00 02	   alarmclock =	2
   3150  2f74		       00 03	   handwritten =	3
   3151  2f74		       00 04	   interrupted =	4
   3152  2f74		       00 05	   retroputer =	5
   3153  2f74		       00 06	   whimsey    =	6
   3154  2f74		       00 07	   tiny       =	7
   3155  2f74		       00 08	   hex	      =	8
   3156  2f74
   3157  2f74				  -	      ifconst	font
   3158  2f74				  -	      if	font == hex
   3159  2f74				  -	      ORG	. - 48
   3160  2f74				  -	      endif
   3161  2f74					      endif
   3162  2f74
   3163  2f74				   scoretable
   3164  2f74
   3165  2f74				  -	      ifconst	font
   3166  2f74				  -	      if	font == .21stcentury
   3167  2f74				  -	      include	"score_graphics.asm.21stcentury"
   3168  2f74				  -	      endif
   3169  2f74				  -	      if	font == alarmclock
   3170  2f74				  -	      include	"score_graphics.asm.alarmclock"
   3171  2f74				  -	      endif
   3172  2f74				  -	      if	font == handwritten
   3173  2f74				  -	      include	"score_graphics.asm.handwritten"
   3174  2f74				  -	      endif
   3175  2f74				  -	      if	font == interrupted
   3176  2f74				  -	      include	"score_graphics.asm.interrupted"
   3177  2f74				  -	      endif
   3178  2f74				  -	      if	font == retroputer
   3179  2f74				  -	      include	"score_graphics.asm.retroputer"
   3180  2f74				  -	      endif
   3181  2f74				  -	      if	font == whimsey
   3182  2f74				  -	      include	"score_graphics.asm.whimsey"
   3183  2f74				  -	      endif
   3184  2f74				  -	      if	font == tiny
   3185  2f74				  -	      include	"score_graphics.asm.tiny"
   3186  2f74				  -	      endif
   3187  2f74				  -	      if	font == hex
   3188  2f74				  -	      include	"score_graphics.asm.hex"
   3189  2f74				  -	      endif
   3190  2f74					      else		; default font
   3191  2f74
   3192  2f74		       3c		      .byte.b	%00111100
   3193  2f75		       66		      .byte.b	%01100110
   3194  2f76		       66		      .byte.b	%01100110
   3195  2f77		       66		      .byte.b	%01100110
   3196  2f78		       66		      .byte.b	%01100110
   3197  2f79		       66		      .byte.b	%01100110
   3198  2f7a		       66		      .byte.b	%01100110
   3199  2f7b		       3c		      .byte.b	%00111100
   3200  2f7c
   3201  2f7c		       7e		      .byte.b	%01111110
   3202  2f7d		       18		      .byte.b	%00011000
   3203  2f7e		       18		      .byte.b	%00011000
   3204  2f7f		       18		      .byte.b	%00011000
   3205  2f80		       18		      .byte.b	%00011000
   3206  2f81		       38		      .byte.b	%00111000
   3207  2f82		       18		      .byte.b	%00011000
   3208  2f83		       08		      .byte.b	%00001000
   3209  2f84
   3210  2f84		       7e		      .byte.b	%01111110
   3211  2f85		       60		      .byte.b	%01100000
   3212  2f86		       60		      .byte.b	%01100000
   3213  2f87		       3c		      .byte.b	%00111100
   3214  2f88		       06		      .byte.b	%00000110
   3215  2f89		       06		      .byte.b	%00000110
   3216  2f8a		       46		      .byte.b	%01000110
   3217  2f8b		       3c		      .byte.b	%00111100
   3218  2f8c
   3219  2f8c		       3c		      .byte.b	%00111100
   3220  2f8d		       46		      .byte.b	%01000110
   3221  2f8e		       06		      .byte.b	%00000110
   3222  2f8f		       06		      .byte.b	%00000110
   3223  2f90		       1c		      .byte.b	%00011100
   3224  2f91		       06		      .byte.b	%00000110
   3225  2f92		       46		      .byte.b	%01000110
   3226  2f93		       3c		      .byte.b	%00111100
   3227  2f94
   3228  2f94		       0c		      .byte.b	%00001100
   3229  2f95		       0c		      .byte.b	%00001100
   3230  2f96		       7e		      .byte.b	%01111110
   3231  2f97		       4c		      .byte.b	%01001100
   3232  2f98		       4c		      .byte.b	%01001100
   3233  2f99		       2c		      .byte.b	%00101100
   3234  2f9a		       1c		      .byte.b	%00011100
   3235  2f9b		       0c		      .byte.b	%00001100
   3236  2f9c
   3237  2f9c		       3c		      .byte.b	%00111100
   3238  2f9d		       46		      .byte.b	%01000110
   3239  2f9e		       06		      .byte.b	%00000110
   3240  2f9f		       06		      .byte.b	%00000110
   3241  2fa0		       3c		      .byte.b	%00111100
   3242  2fa1		       60		      .byte.b	%01100000
   3243  2fa2		       60		      .byte.b	%01100000
   3244  2fa3		       7e		      .byte.b	%01111110
   3245  2fa4
   3246  2fa4		       3c		      .byte.b	%00111100
   3247  2fa5		       66		      .byte.b	%01100110
   3248  2fa6		       66		      .byte.b	%01100110
   3249  2fa7		       66		      .byte.b	%01100110
   3250  2fa8		       7c		      .byte.b	%01111100
   3251  2fa9		       60		      .byte.b	%01100000
   3252  2faa		       62		      .byte.b	%01100010
   3253  2fab		       3c		      .byte.b	%00111100
   3254  2fac
   3255  2fac		       30		      .byte.b	%00110000
   3256  2fad		       30		      .byte.b	%00110000
   3257  2fae		       30		      .byte.b	%00110000
   3258  2faf		       18		      .byte.b	%00011000
   3259  2fb0		       0c		      .byte.b	%00001100
   3260  2fb1		       06		      .byte.b	%00000110
   3261  2fb2		       42		      .byte.b	%01000010
   3262  2fb3		       3e		      .byte.b	%00111110
   3263  2fb4
   3264  2fb4		       3c		      .byte.b	%00111100
   3265  2fb5		       66		      .byte.b	%01100110
   3266  2fb6		       66		      .byte.b	%01100110
   3267  2fb7		       66		      .byte.b	%01100110
   3268  2fb8		       3c		      .byte.b	%00111100
   3269  2fb9		       66		      .byte.b	%01100110
   3270  2fba		       66		      .byte.b	%01100110
   3271  2fbb		       3c		      .byte.b	%00111100
   3272  2fbc
   3273  2fbc		       3c		      .byte.b	%00111100
   3274  2fbd		       46		      .byte.b	%01000110
   3275  2fbe		       06		      .byte.b	%00000110
   3276  2fbf		       3e		      .byte.b	%00111110
   3277  2fc0		       66		      .byte.b	%01100110
   3278  2fc1		       66		      .byte.b	%01100110
   3279  2fc2		       66		      .byte.b	%01100110
   3280  2fc3		       3c		      .byte.b	%00111100
   3281  2fc4
   3282  2fc4					      ifnconst	DPC_kernel_options
   3283  2fc4
   3284  2fc4		       00		      .byte.b	%00000000
   3285  2fc5		       00		      .byte.b	%00000000
   3286  2fc6		       00		      .byte.b	%00000000
   3287  2fc7		       00		      .byte.b	%00000000
   3288  2fc8		       00		      .byte.b	%00000000
   3289  2fc9		       00		      .byte.b	%00000000
   3290  2fca		       00		      .byte.b	%00000000
   3291  2fcb		       00		      .byte.b	%00000000
   3292  2fcc
   3293  2fcc					      endif
   3294  2fcc
   3295  2fcc					      endif
   3296  2fcc
   3297  2fcc				  -	      ifconst	ROM2k
   3298  2fcc				  -	      ORG	$F7FC
   3299  2fcc					      else
   3300  2fcc					      ifconst	bankswitch
   3301  2fcc					      if	bankswitch == 8
   3302  2fd4					      ORG	$2FF4-bscode_length
   3303  2fd4					      RORG	$FFF4-bscode_length
   3304  2fd4					      endif
   3305  2fd4				  -	      if	bankswitch == 16
   3306  2fd4				  -	      ORG	$4FF4-bscode_length
   3307  2fd4				  -	      RORG	$FFF4-bscode_length
   3308  2fd4					      endif
   3309  2fd4				  -	      if	bankswitch == 32
   3310  2fd4				  -	      ORG	$8FF4-bscode_length
   3311  2fd4				  -	      RORG	$FFF4-bscode_length
   3312  2fd4					      endif
   3313  2fd4				  -	      if	bankswitch == 64
   3314  2fd4				  -	      ORG	$10FE0-bscode_length
   3315  2fd4				  -	      RORG	$1FFE0-bscode_length
   3316  2fd4					      endif
   3317  2fd4				  -	      else
   3318  2fd4				  -	      ORG	$FFFC
   3319  2fd4					      endif
   3320  2fd4					      endif
   3321  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3322  2fd4
   3323  2fd4							; every bank has this stuff at the same place
   3324  2fd4							; this code can switch to/from any bank at any entry point
   3325  2fd4							; and can preserve register values
   3326  2fd4							; note: lines not starting with a space are not placed in all banks
   3327  2fd4							;
   3328  2fd4							; line below tells the compiler how long this is - do not remove
   3329  2fd4							;size=32
   3330  2fd4
   3331  2fd4				   begin_bscode
   3332  2fd4		       a2 ff		      ldx	#$ff
   3333  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3334  2fd6				  -	      stx	FASTFETCH
   3335  2fd6					      endif
   3336  2fd6		       9a		      txs
   3337  2fd7				  -	      if	bankswitch == 64
   3338  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3339  2fd7					      else
   3340  2fd7		       a9 f3		      lda	#>(start-1)
   3341  2fd9					      endif
   3342  2fd9		       48		      pha
   3343  2fda		       a9 f7		      lda	#<(start-1)
   3344  2fdc		       48		      pha
   3345  2fdd
   3346  2fdd				   BS_return
   3347  2fdd		       48		      pha
   3348  2fde		       8a		      txa
   3349  2fdf		       48		      pha
   3350  2fe0		       ba		      tsx
   3351  2fe1
   3352  2fe1					      if	bankswitch != 64
   3353  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   3354  2fe3
   3355  2fe3		       2a		      rol
   3356  2fe4		       2a		      rol
   3357  2fe5		       2a		      rol
   3358  2fe6		       2a		      rol
   3359  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3360  2fe9		       aa		      tax
   3361  2fea		       e8		      inx
   3362  2feb				  -	      else
   3363  2feb				  -	      lda	4,x	; get high byte of return address
   3364  2feb				  -	      tay
   3365  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3366  2feb				  -	      sta	4,x
   3367  2feb				  -	      tya
   3368  2feb				  -	      lsr
   3369  2feb				  -	      lsr
   3370  2feb				  -	      lsr
   3371  2feb				  -	      lsr
   3372  2feb				  -	      tax
   3373  2feb				  -	      inx
   3374  2feb					      endif
   3375  2feb
   3376  2feb				   BS_jsr
   3377  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   3378  2fee		       68		      pla
   3379  2fef		       aa		      tax
   3380  2ff0		       68		      pla
   3381  2ff1		       60		      rts
   3382  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3383  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3384  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3385  2ff2					      endif
   3386  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3387  2ff2
   3388  2ff2					      ifconst	bankswitch
   3389  2ff2					      if	bankswitch == 8
   3390  2ffc					      ORG	$2FFC
   3391  2ffc					      RORG	$FFFC
   3392  2ffc					      endif
   3393  2ffc				  -	      if	bankswitch == 16
   3394  2ffc				  -	      ORG	$4FFC
   3395  2ffc				  -	      RORG	$FFFC
   3396  2ffc					      endif
   3397  2ffc				  -	      if	bankswitch == 32
   3398  2ffc				  -	      ORG	$8FFC
   3399  2ffc				  -	      RORG	$FFFC
   3400  2ffc					      endif
   3401  2ffc				  -	      if	bankswitch == 64
   3402  2ffc				  -	      ORG	$10FF0
   3403  2ffc				  -	      RORG	$1FFF0
   3404  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3405  2ffc				  -	      ORG	$10FF8
   3406  2ffc				  -	      RORG	$1FFF8
   3407  2ffc				  -	      ifconst	superchip
   3408  2ffc				  -	      .byte	"E","F","S","C"
   3409  2ffc				  -	      else
   3410  2ffc				  -	      .byte	"E","F","E","F"
   3411  2ffc				  -	      endif
   3412  2ffc				  -	      ORG	$10FFC
   3413  2ffc				  -	      RORG	$1FFFC
   3414  2ffc					      endif
   3415  2ffc				  -	      else
   3416  2ffc				  -	      ifconst	ROM2k
   3417  2ffc				  -	      ORG	$F7FC
   3418  2ffc				  -	      else
   3419  2ffc				  -	      ORG	$FFFC
   3420  2ffc				  -	      endif
   3421  2ffc					      endif
   3422  2ffc		       f8 f3		      .word.w	(start & $ffff)
   3423  2ffe		       f8 f3		      .word.w	(start & $ffff)
