------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_15.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_15.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_15.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  3000 ????				      include	"multisprite.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????	       00 80	   missile0x  =	$80
      4  3000 ????	       00 81	   missile1x  =	$81
      5  3000 ????	       00 82	   ballx      =	$82
      6  3000 ????
      7  3000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  3000 ????
      9  3000 ????	       00 83	   SpriteIndex =	$83
     10  3000 ????
     11  3000 ????	       00 84	   player0x   =	$84
     12  3000 ????	       00 85	   NewSpriteX =	$85	;		X position
     13  3000 ????	       00 85	   player1x   =	$85
     14  3000 ????	       00 86	   player2x   =	$86
     15  3000 ????	       00 87	   player3x   =	$87
     16  3000 ????	       00 88	   player4x   =	$88
     17  3000 ????	       00 89	   player5x   =	$89
     18  3000 ????
     19  3000 ????	       00 8a	   objecty    =	$8A
     20  3000 ????	       00 8a	   missile0y  =	$8A
     21  3000 ????	       00 8b	   missile1y  =	$8B
     22  3000 ????	       00 8c	   bally      =	$8C
     23  3000 ????
     24  3000 ????	       00 8d	   player0y   =	$8D
     25  3000 ????	       00 8e	   NewSpriteY =	$8E	;		Y position
     26  3000 ????	       00 8e	   player1y   =	$8E
     27  3000 ????	       00 8f	   player2y   =	$8F
     28  3000 ????	       00 90	   player3y   =	$90
     29  3000 ????	       00 91	   player4y   =	$91
     30  3000 ????	       00 92	   player5y   =	$92
     31  3000 ????
     32  3000 ????	       00 93	   NewNUSIZ   =	$93
     33  3000 ????	       00 93	   _NUSIZ1    =	$93
     34  3000 ????	       00 94	   NUSIZ2     =	$94
     35  3000 ????	       00 95	   NUSIZ3     =	$95
     36  3000 ????	       00 96	   NUSIZ4     =	$96
     37  3000 ????	       00 97	   NUSIZ5     =	$97
     38  3000 ????
     39  3000 ????	       00 98	   NewCOLUP1  =	$98
     40  3000 ????	       00 98	   _COLUP1    =	$98
     41  3000 ????	       00 99	   COLUP2     =	$99
     42  3000 ????	       00 9a	   COLUP3     =	$9A
     43  3000 ????	       00 9b	   COLUP4     =	$9B
     44  3000 ????	       00 9c	   COLUP5     =	$9C
     45  3000 ????
     46  3000 ????	       00 9d	   SpriteGfxIndex =	$9D
     47  3000 ????
     48  3000 ????	       00 a2	   player0pointer =	$A2
     49  3000 ????	       00 a2	   player0pointerlo =	$A2
     50  3000 ????	       00 a3	   player0pointerhi =	$A3
     51  3000 ????
     52  3000 ????						;P0Top = temp5
     53  3000 ????	       00 cf	   P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  3000 ????	       00 a4	   P0Bottom   =	$A4
     55  3000 ????	       00 a5	   P1Bottom   =	$A5
     56  3000 ????
     57  3000 ????	       00 a6	   player1pointerlo =	$A6
     58  3000 ????	       00 a7	   player2pointerlo =	$A7
     59  3000 ????	       00 a8	   player3pointerlo =	$A8
     60  3000 ????	       00 a9	   player4pointerlo =	$A9
     61  3000 ????	       00 aa	   player5pointerlo =	$AA
     62  3000 ????
     63  3000 ????	       00 ab	   player1pointerhi =	$AB
     64  3000 ????	       00 ac	   player2pointerhi =	$AC
     65  3000 ????	       00 ad	   player3pointerhi =	$AD
     66  3000 ????	       00 ae	   player4pointerhi =	$AE
     67  3000 ????	       00 af	   player5pointerhi =	$AF
     68  3000 ????
     69  3000 ????	       00 b0	   player0height =	$B0
     70  3000 ????	       00 b1	   spriteheight =	$B1	; heights of multiplexed player sprite
     71  3000 ????	       00 b1	   player1height =	$B1
     72  3000 ????	       00 b2	   player2height =	$B2
     73  3000 ????	       00 b3	   player3height =	$B3
     74  3000 ????	       00 b4	   player4height =	$B4
     75  3000 ????	       00 b5	   player5height =	$B5
     76  3000 ????
     77  3000 ????	       00 b6	   PF1temp1   =	$B6
     78  3000 ????	       00 b7	   PF1temp2   =	$B7
     79  3000 ????	       00 b8	   PF2temp1   =	$B8
     80  3000 ????	       00 b9	   PF2temp2   =	$B9
     81  3000 ????
     82  3000 ????	       00 ba	   pfpixelheight =	$BA
     83  3000 ????
     84  3000 ????						; playfield is now a pointer to graphics
     85  3000 ????	       00 bb	   playfield  =	$BB
     86  3000 ????	       00 bb	   PF1pointer =	$BB
     87  3000 ????
     88  3000 ????	       00 bd	   PF2pointer =	$BD
     89  3000 ????
     90  3000 ????	       00 bf	   statusbarlength =	$BF
     91  3000 ????	       00 bf	   aux3       =	$BF
     92  3000 ????
     93  3000 ????	       00 c0	   lifecolor  =	$C0
     94  3000 ????	       00 c0	   pfscorecolor =	$C0
     95  3000 ????	       00 c0	   aux4       =	$C0
     96  3000 ????
     97  3000 ????						;P1display = temp2 ; temp2 and temp3
     98  3000 ????	       00 cc	   P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  3000 ????	       00 c1	   lifepointer =	$c1
    100  3000 ????	       00 c2	   lives      =	$c2
    101  3000 ????	       00 c1	   pfscore1   =	$c1
    102  3000 ????	       00 c2	   pfscore2   =	$c2
    103  3000 ????	       00 c1	   aux5       =	$c1
    104  3000 ????	       00 c2	   aux6       =	$c2
    105  3000 ????
    106  3000 ????	       00 c3	   playfieldpos =	$C3
    107  3000 ????
    108  3000 ????						;RepoLine = temp4
    109  3000 ????	       00 ce	   RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  3000 ????
    111  3000 ????	       00 c4	   pfheight   =	$C4
    112  3000 ????	       00 c5	   scorepointers =	$C5
    113  3000 ????
    114  3000 ????	       00 cb	   temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  3000 ????	       00 cc	   temp2      =	$CC	;are obliterated when drawscreen is called.
    116  3000 ????	       00 cd	   temp3      =	$CD
    117  3000 ????	       00 ce	   temp4      =	$CE
    118  3000 ????	       00 cf	   temp5      =	$CF
    119  3000 ????	       00 d0	   temp6      =	$D0
    120  3000 ????	       00 d1	   temp7      =	$D1	; This is used to aid in bankswitching
    121  3000 ????
    122  3000 ????	       00 d2	   score      =	$D2
    123  3000 ????	       00 d5	   scorecolor =	$D5	;need to find other places for these, possibly...
    124  3000 ????	       00 d6	   rand       =	$D6
    125  3000 ????
    126  3000 ????
    127  3000 ????
    128  3000 ????	       00 d7	   A	      =	$d7
    129  3000 ????	       00 d7	   a	      =	$d7
    130  3000 ????	       00 d8	   B	      =	$d8
    131  3000 ????	       00 d8	   b	      =	$d8
    132  3000 ????	       00 d9	   C	      =	$d9
    133  3000 ????	       00 d9	   c	      =	$d9
    134  3000 ????	       00 da	   D	      =	$da
    135  3000 ????	       00 da	   d	      =	$da
    136  3000 ????	       00 db	   E	      =	$db
    137  3000 ????	       00 db	   e	      =	$db
    138  3000 ????	       00 dc	   F	      =	$dc
    139  3000 ????	       00 dc	   f	      =	$dc
    140  3000 ????	       00 dd	   G	      =	$dd
    141  3000 ????	       00 dd	   g	      =	$dd
    142  3000 ????	       00 de	   H	      =	$de
    143  3000 ????	       00 de	   h	      =	$de
    144  3000 ????	       00 df	   I	      =	$df
    145  3000 ????	       00 df	   i	      =	$df
    146  3000 ????	       00 e0	   J	      =	$e0
    147  3000 ????	       00 e0	   j	      =	$e0
    148  3000 ????	       00 e1	   K	      =	$e1
    149  3000 ????	       00 e1	   k	      =	$e1
    150  3000 ????	       00 e2	   L	      =	$e2
    151  3000 ????	       00 e2	   l	      =	$e2
    152  3000 ????	       00 e3	   M	      =	$e3
    153  3000 ????	       00 e3	   m	      =	$e3
    154  3000 ????	       00 e4	   N	      =	$e4
    155  3000 ????	       00 e4	   n	      =	$e4
    156  3000 ????	       00 e5	   O	      =	$e5
    157  3000 ????	       00 e5	   o	      =	$e5
    158  3000 ????	       00 e6	   P	      =	$e6
    159  3000 ????	       00 e6	   p	      =	$e6
    160  3000 ????	       00 e7	   Q	      =	$e7
    161  3000 ????	       00 e7	   q	      =	$e7
    162  3000 ????	       00 e8	   R	      =	$e8
    163  3000 ????	       00 e8	   r	      =	$e8
    164  3000 ????	       00 e9	   S	      =	$e9
    165  3000 ????	       00 e9	   s	      =	$e9
    166  3000 ????	       00 ea	   T	      =	$ea
    167  3000 ????	       00 ea	   t	      =	$ea
    168  3000 ????	       00 eb	   U	      =	$eb
    169  3000 ????	       00 eb	   u	      =	$eb
    170  3000 ????	       00 ec	   V	      =	$ec
    171  3000 ????	       00 ec	   v	      =	$ec
    172  3000 ????	       00 ed	   W	      =	$ed
    173  3000 ????	       00 ed	   w	      =	$ed
    174  3000 ????	       00 ee	   X	      =	$ee
    175  3000 ????	       00 ee	   x	      =	$ee
    176  3000 ????	       00 ef	   Y	      =	$ef
    177  3000 ????	       00 ef	   y	      =	$ef
    178  3000 ????	       00 f0	   Z	      =	$f0
    179  3000 ????	       00 f0	   z	      =	$f0
    180  3000 ????
    181  3000 ????	       00 f1	   spritesort =	$f1	; helps with flickersort
    182  3000 ????	       00 f2	   spritesort2 =	$f2	; helps with flickersort
    183  3000 ????	       00 f3	   spritesort3 =	$f3
    184  3000 ????	       00 f4	   spritesort4 =	$f4
    185  3000 ????	       00 f5	   spritesort5 =	$f5
    186  3000 ????
    187  3000 ????	       00 f6	   stack1     =	$f6
    188  3000 ????	       00 f7	   stack2     =	$f7
    189  3000 ????	       00 f8	   stack3     =	$f8
    190  3000 ????	       00 f9	   stack4     =	$f9
    191  3000 ????						; the stack bytes above may be used in the kernel
    192  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  3000 ????
    194  3000 ????				      MAC	return
    195  3000 ????				      ifnconst	bankswitch
    196  3000 ????				      rts
    197  3000 ????				      else
    198  3000 ????				      jmp	BS_return
    199  3000 ????				      endif
    200  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_15.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 e3	   tur_fired  =	m
      5  3000 ????	       00 e0	   shot_y     =	j
      6  3000 ????	       00 df	   shot_x     =	i
      7  3000 ????	       00 db	   tur_y      =	e
      8  3000 ????	       00 da	   tur_x      =	d
      9  3000 ????	       00 e5	   inv_blast_delay =	o
     10  3000 ????	       00 e4	   inv_hit    =	n
     11  3000 ????	       00 e2	   inv_fired  =	l
     12  3000 ????	       00 e1	   inv_fire_delay =	k
     13  3000 ????	       00 de	   inv_shot_y =	h
     14  3000 ????	       00 dd	   inv_shot_x =	g
     15  3000 ????	       00 dc	   inv_dir    =	f
     16  3000 ????	       00 d9	   inv_delay  =	c
     17  3000 ????	       00 d8	   inv_y      =	b
     18  3000 ????	       00 d7	   inv_x      =	a
     19  3000 ????	       00 d4	   _sc3       =	score + 2
     20  3000 ????
     21  3000 ????	       00 01	   bs_mask    =	1
     22  3000 ????	       00 08	   bankswitch =	8
     23  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
     24  3000 ????	       00 01	   multisprite =	1
     25  3000 ????	       00 01	   no_blank_lines =	1
------- FILE C:\Atari2600Dev\my_projects\Invader_Atari_2600_Basic\invader_15.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	234	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .
     57  1000							; 
     58  1000
     59  1000				   .L00 		;  includesfile multisprite_bankswitch.inc
     60  1000
     61  1000				   .L01 		;  set kernel_options no_blank_lines
     62  1000
     63  1000				   .L02 		;  set kernel multisprite
     64  1000
     65  1000				   .L03 		;  set romsize 8k
     66  1000
     67  1000				   .
     68  1000							; 
     69  1000
     70  1000				   .
     71  1000							; 
     72  1000
     73  1000				   .
     74  1000							; 
     75  1000
     76  1000				   .L04 		;  scorecolor	=  14
     77  1000
     78  1000		       a9 0e		      LDA	#14
     79  1002		       85 d5		      STA	scorecolor
     80  1004				   .
     81  1004							; 
     82  1004
     83  1004				   .L05 		;  dim _sc3  =  score + 2
     84  1004
     85  1004				   .
     86  1004							; 
     87  1004
     88  1004				   .
     89  1004							; 
     90  1004
     91  1004				   .L06 		;  dim inv_x  =  a  :	a  =  84
     92  1004
     93  1004		       a9 54		      LDA	#84
     94  1006		       85 d7		      STA	a
     95  1008				   .L07 		;  dim inv_y  =  b  :	b  =  76
     96  1008
     97  1008		       a9 4c		      LDA	#76
     98  100a		       85 d8		      STA	b
     99  100c				   .L08 		;  dim inv_delay  =  c  :  c  =  0
    100  100c
    101  100c		       a9 00		      LDA	#0
    102  100e		       85 d9		      STA	c
    103  1010				   .L09 		;  dim inv_dir  =  f  :  f  =	1
    104  1010
    105  1010		       a9 01		      LDA	#1
    106  1012		       85 dc		      STA	f
    107  1014				   .L010		;  dim inv_shot_x  =  g  :  g	=  0
    108  1014
    109  1014		       a9 00		      LDA	#0
    110  1016		       85 dd		      STA	g
    111  1018				   .L011		;  dim inv_shot_y  =  h  :  h	=  0
    112  1018
    113  1018		       a9 00		      LDA	#0
    114  101a		       85 de		      STA	h
    115  101c				   .L012		;  dim inv_fire_delay	=  k  :  k  =  0
    116  101c
    117  101c		       a9 00		      LDA	#0
    118  101e		       85 e1		      STA	k
    119  1020				   .L013		;  dim inv_fired  =  l  :  l  =  0
    120  1020
    121  1020		       a9 00		      LDA	#0
    122  1022		       85 e2		      STA	l
    123  1024				   .L014		;  dim inv_hit  =  n  :  n  =	0
    124  1024
    125  1024		       a9 00		      LDA	#0
    126  1026		       85 e4		      STA	n
    127  1028				   .L015		;  dim inv_blast_delay  =  o  :  o  =	0
    128  1028
    129  1028		       a9 00		      LDA	#0
    130  102a		       85 e5		      STA	o
    131  102c				   .
    132  102c							; 
    133  102c
    134  102c				   .
    135  102c							; 
    136  102c
    137  102c				   .L016		;  dim tur_x  =  d  :	d  =  84
    138  102c
    139  102c		       a9 54		      LDA	#84
    140  102e		       85 da		      STA	d
    141  1030				   .L017		;  dim tur_y  =  e  :	e  =  14
    142  1030
    143  1030		       a9 0e		      LDA	#14
    144  1032		       85 db		      STA	e
    145  1034				   .L018		;  dim shot_x	=  i  :  i  =  tur_x
    146  1034
    147  1034		       a5 da		      LDA	tur_x
    148  1036		       85 df		      STA	i
    149  1038				   .L019		;  dim shot_y	=  j  :  j  =  tur_y
    150  1038
    151  1038		       a5 db		      LDA	tur_y
    152  103a		       85 e0		      STA	j
    153  103c				   .L020		;  dim tur_fired  =  m  :  m  =  0
    154  103c
    155  103c		       a9 00		      LDA	#0
    156  103e		       85 e3		      STA	m
    157  1040				   .
    158  1040							; 
    159  1040
    160  1040				   .
    161  1040							; 
    162  1040
    163  1040				   .
    164  1040							; 
    165  1040
    166  1040				   .main
    167  1040							; main
    168  1040
    169  1040				   .
    170  1040							; 
    171  1040
    172  1040				   .L021		;  gosub draw__move_turret
    173  1040
    174  1040		       20 73 d2 	      jsr	.draw__move_turret
    175  1043
    176  1043				   .L022		;  gosub draw__move_turret_shot
    177  1043
    178  1043		       20 b2 d2 	      jsr	.draw__move_turret_shot
    179  1046
    180  1046				   .L023		;  gosub draw__move_invader
    181  1046
    182  1046		       20 73 d0 	      jsr	.draw__move_invader
    183  1049
    184  1049				   .L024		;  gosub draw__move_inv_shot
    185  1049
    186  1049		       20 45 d1 	      jsr	.draw__move_inv_shot
    187  104c
    188  104c				   .L025		;  gosub col_shot_inv
    189  104c
    190  104c		       20 c4 d1 	      jsr	.col_shot_inv
    191  104f
    192  104f				   .
    193  104f							; 
    194  104f
    195  104f				   .L026		;  if _sc3  >=  70 then goto game_over
    196  104f
    197  104f		       a5 d4		      LDA	_sc3
    198  1051		       c9 46		      CMP	#70
    199  1053		       90 03		      BCC	.skipL026
    200  1055				   .condpart0
    201  1055		       4c 15 d3 	      jmp	.game_over
    202  1058
    203  1058				   .skipL026
    204  1058				   .
    205  1058							; 
    206  1058
    207  1058				   .L027		;  drawscreen
    208  1058
    209  1058		       85 d1		      sta	temp7
    210  105a		       a9 d0		      lda	#>(ret_point1-1)
    211  105c		       48		      pha
    212  105d		       a9 6f		      lda	#<(ret_point1-1)
    213  105f		       48		      pha
    214  1060		       a9 f0		      lda	#>(drawscreen-1)
    215  1062		       48		      pha
    216  1063		       a9 39		      lda	#<(drawscreen-1)
    217  1065		       48		      pha
    218  1066		       a5 d1		      lda	temp7
    219  1068		       48		      pha
    220  1069		       8a		      txa
    221  106a		       48		      pha
    222  106b		       a2 02		      ldx	#2
    223  106d		       4c eb ff 	      jmp	BS_jsr
    224  1070				   ret_point1
    225  1070				   .
    226  1070							; 
    227  1070
    228  1070				   .L028		;  goto main
    229  1070
    230  1070		       4c 40 d0 	      jmp	.main
    231  1073
    232  1073				   .
    233  1073							; 
    234  1073
    235  1073				   .
    236  1073							; 
    237  1073
    238  1073				   .
    239  1073							; 
    240  1073
    241  1073				   .
    242  1073							; 
    243  1073
    244  1073				   .
    245  1073							; 
    246  1073
    247  1073				   .
    248  1073							; 
    249  1073
    250  1073				   .
    251  1073							; 
    252  1073
    253  1073				   .draw__move_invader
    254  1073							; draw__move_invader
    255  1073
    256  1073				   .
    257  1073							; 
    258  1073
    259  1073				   .L029		;  inv_delay  =  inv_delay  +	1
    260  1073
    261  1073		       e6 d9		      INC	inv_delay
    262  1075				   .
    263  1075							; 
    264  1075
    265  1075				   .
    266  1075							; 
    267  1075
    268  1075				   .L030		;  if inv_delay  =  15  &&  inv_hit  =  0 then player0:  
    269  1075
    270  1075		       a5 d9		      LDA	inv_delay
    271  1077		       c9 0f		      CMP	#15
    272  1079		       d0 12		      BNE	.skipL030
    273  107b				   .condpart1
    274  107b		       a5 e4		      LDA	inv_hit
    275  107d		       c9 00		      CMP	#0
    276  107f		       d0 0c		      BNE	.skip1then
    277  1081				   .condpart2
    278  1081		       a2 5a		      LDX	#<player2then_0
    279  1083		       86 a2		      STX	player0pointerlo
    280  1085		       a9 f4		      LDA	#>player2then_0
    281  1087		       85 a3		      STA	player0pointerhi
    282  1089		       a9 09		      LDA	#9
    283  108b		       85 b0		      STA	player0height
    284  108d				   .skip1then
    285  108d				   .skipL030
    286  108d				   .
    287  108d							; 
    288  108d
    289  108d				   .
    290  108d							; 
    291  108d
    292  108d				   .L031		;  if inv_delay  =  30  &&  inv_hit  =  0 then player0:  
    293  108d
    294  108d		       a5 d9		      LDA	inv_delay
    295  108f		       c9 1e		      CMP	#30
    296  1091		       d0 12		      BNE	.skipL031
    297  1093				   .condpart3
    298  1093		       a5 e4		      LDA	inv_hit
    299  1095		       c9 00		      CMP	#0
    300  1097		       d0 0c		      BNE	.skip3then
    301  1099				   .condpart4
    302  1099		       a2 63		      LDX	#<player4then_0
    303  109b		       86 a2		      STX	player0pointerlo
    304  109d		       a9 f4		      LDA	#>player4then_0
    305  109f		       85 a3		      STA	player0pointerhi
    306  10a1		       a9 09		      LDA	#9
    307  10a3		       85 b0		      STA	player0height
    308  10a5				   .skip3then
    309  10a5				   .skipL031
    310  10a5				   .
    311  10a5							; 
    312  10a5
    313  10a5				   .L032		;  if inv_delay  >  30 then inv_delay	=  0
    314  10a5
    315  10a5		       a9 1e		      LDA	#30
    316  10a7		       c5 d9		      CMP	inv_delay
    317  10a9		       b0 04		      BCS	.skipL032
    318  10ab				   .condpart5
    319  10ab		       a9 00		      LDA	#0
    320  10ad		       85 d9		      STA	inv_delay
    321  10af				   .skipL032
    322  10af				   .
    323  10af							; 
    324  10af
    325  10af				   .
    326  10af							; 
    327  10af
    328  10af				   .L033		;  COLUP0  =  52
    329  10af
    330  10af		       a9 34		      LDA	#52
    331  10b1		       85 06		      STA	COLUP0
    332  10b3				   .
    333  10b3							; 
    334  10b3
    335  10b3				   .
    336  10b3							; 
    337  10b3
    338  10b3				   .L034		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  15 then inv_x  =  inv_x  +  1
    339  10b3
    340  10b3		       a5 e4		      LDA	inv_hit
    341  10b5		       c9 00		      CMP	#0
    342  10b7		       d0 0e		      BNE	.skipL034
    343  10b9				   .condpart6
    344  10b9		       a5 dc		      LDA	inv_dir
    345  10bb		       c9 01		      CMP	#1
    346  10bd		       d0 08		      BNE	.skip6then
    347  10bf				   .condpart7
    348  10bf		       a5 d9		      LDA	inv_delay
    349  10c1		       c9 0f		      CMP	#15
    350  10c3		       d0 02		      BNE	.skip7then
    351  10c5				   .condpart8
    352  10c5		       e6 d7		      INC	inv_x
    353  10c7				   .skip7then
    354  10c7				   .skip6then
    355  10c7				   .skipL034
    356  10c7				   .L035		;  if inv_hit	=  0  &&  inv_dir  =  1  &&  inv_delay	=  30 then inv_x  =  inv_x  +  1
    357  10c7
    358  10c7		       a5 e4		      LDA	inv_hit
    359  10c9		       c9 00		      CMP	#0
    360  10cb		       d0 0e		      BNE	.skipL035
    361  10cd				   .condpart9
    362  10cd		       a5 dc		      LDA	inv_dir
    363  10cf		       c9 01		      CMP	#1
    364  10d1		       d0 08		      BNE	.skip9then
    365  10d3				   .condpart10
    366  10d3		       a5 d9		      LDA	inv_delay
    367  10d5		       c9 1e		      CMP	#30
    368  10d7		       d0 02		      BNE	.skip10then
    369  10d9				   .condpart11
    370  10d9		       e6 d7		      INC	inv_x
    371  10db				   .skip10then
    372  10db				   .skip9then
    373  10db				   .skipL035
    374  10db				   .
    375  10db							; 
    376  10db
    377  10db				   .L036		;  if inv_x  >  143 then inv_dir  =  0  :  inv_x  =  143  :  inv_y  =	inv_y  -  5
    378  10db
    379  10db		       a9 8f		      LDA	#143
    380  10dd		       c5 d7		      CMP	inv_x
    381  10df		       b0 0f		      BCS	.skipL036
    382  10e1				   .condpart12
    383  10e1		       a9 00		      LDA	#0
    384  10e3		       85 dc		      STA	inv_dir
    385  10e5		       a9 8f		      LDA	#143
    386  10e7		       85 d7		      STA	inv_x
    387  10e9		       a5 d8		      LDA	inv_y
    388  10eb		       38		      SEC
    389  10ec		       e9 05		      SBC	#5
    390  10ee		       85 d8		      STA	inv_y
    391  10f0				   .skipL036
    392  10f0				   .
    393  10f0							; 
    394  10f0
    395  10f0				   .
    396  10f0							; 
    397  10f0
    398  10f0				   .L037		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  15 then inv_x  =  inv_x  -  1
    399  10f0
    400  10f0		       a5 e4		      LDA	inv_hit
    401  10f2		       c9 00		      CMP	#0
    402  10f4		       d0 0e		      BNE	.skipL037
    403  10f6				   .condpart13
    404  10f6		       a5 dc		      LDA	inv_dir
    405  10f8		       c9 00		      CMP	#0
    406  10fa		       d0 08		      BNE	.skip13then
    407  10fc				   .condpart14
    408  10fc		       a5 d9		      LDA	inv_delay
    409  10fe		       c9 0f		      CMP	#15
    410  1100		       d0 02		      BNE	.skip14then
    411  1102				   .condpart15
    412  1102		       c6 d7		      DEC	inv_x
    413  1104				   .skip14then
    414  1104				   .skip13then
    415  1104				   .skipL037
    416  1104				   .L038		;  if inv_hit	=  0  &&  inv_dir  =  0  &&  inv_delay	=  30 then inv_x  =  inv_x  -  1
    417  1104
    418  1104		       a5 e4		      LDA	inv_hit
    419  1106		       c9 00		      CMP	#0
    420  1108		       d0 0e		      BNE	.skipL038
    421  110a				   .condpart16
    422  110a		       a5 dc		      LDA	inv_dir
    423  110c		       c9 00		      CMP	#0
    424  110e		       d0 08		      BNE	.skip16then
    425  1110				   .condpart17
    426  1110		       a5 d9		      LDA	inv_delay
    427  1112		       c9 1e		      CMP	#30
    428  1114		       d0 02		      BNE	.skip17then
    429  1116				   .condpart18
    430  1116		       c6 d7		      DEC	inv_x
    431  1118				   .skip17then
    432  1118				   .skip16then
    433  1118				   .skipL038
    434  1118				   .
    435  1118							; 
    436  1118
    437  1118				   .L039		;  if inv_x  <  26 then inv_dir  =  1	:  inv_x  =  26  :  inv_y  =  inv_y  -	5
    438  1118
    439  1118		       a5 d7		      LDA	inv_x
    440  111a		       c9 1a		      CMP	#26
    441  111c		       b0 0f		      BCS	.skipL039
    442  111e				   .condpart19
    443  111e		       a9 01		      LDA	#1
    444  1120		       85 dc		      STA	inv_dir
    445  1122		       a9 1a		      LDA	#26
    446  1124		       85 d7		      STA	inv_x
    447  1126		       a5 d8		      LDA	inv_y
    448  1128		       38		      SEC
    449  1129		       e9 05		      SBC	#5
    450  112b		       85 d8		      STA	inv_y
    451  112d				   .skipL039
    452  112d				   .
    453  112d							; 
    454  112d
    455  112d				   .
    456  112d							; 
    457  112d
    458  112d				   .L040		;  player0x  =  inv_x	-  8  :  player0y  =  inv_y
    459  112d
    460  112d		       a5 d7		      LDA	inv_x
    461  112f		       38		      SEC
    462  1130		       e9 08		      SBC	#8
    463  1132		       85 84		      STA	player0x
    464  1134		       a5 d8		      LDA	inv_y
    465  1136		       85 8d		      STA	player0y
    466  1138				   .L041		;  return
    467  1138
    468  1138		       ba		      tsx
    469  1139		       b5 02		      lda	2,x	; check return address
    470  113b		       49 d1		      eor	#(>*)	; vs. current PCH
    471  113d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    472  113f		       f0 03		      beq	*+5	; if equal, do normal return
    473  1141		       4c dd ff 	      JMP	BS_return
    474  1144		       60		      RTS
    475  1145				   .
    476  1145							; 
    477  1145
    478  1145				   .
    479  1145							; 
    480  1145
    481  1145				   .
    482  1145							; 
    483  1145
    484  1145				   .
    485  1145							; 
    486  1145
    487  1145				   .
    488  1145							; 
    489  1145
    490  1145				   .
    491  1145							; 
    492  1145
    493  1145				   .draw__move_inv_shot
    494  1145							; draw__move_inv_shot
    495  1145
    496  1145				   .
    497  1145							; 
    498  1145
    499  1145				   .L042		;  player2:
    500  1145
    501  1145		       a2 6c		      LDX	#<playerL042_2
    502  1147		       86 a7		      STX	player2pointerlo
    503  1149		       a9 f4		      LDA	#>playerL042_2
    504  114b		       85 ac		      STA	player2pointerhi
    505  114d		       a9 09		      LDA	#9
    506  114f		       85 b2		      STA	player2height
    507  1151				   .
    508  1151							; 
    509  1151
    510  1151				   .L043		;  COLUP2  =  14
    511  1151
    512  1151		       a9 0e		      LDA	#14
    513  1153		       85 99		      STA	COLUP2
    514  1155				   .
    515  1155							; 
    516  1155
    517  1155				   .L044		;  inv_fire_delay  =  inv_fire_delay  +  1
    518  1155
    519  1155		       e6 e1		      INC	inv_fire_delay
    520  1157				   .
    521  1157							; 
    522  1157
    523  1157				   .L045		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_shot_x  =  inv_x  :  inv_shot_y  =	inv_y  -  9
    524  1157
    525  1157		       a5 e2		      LDA	inv_fired
    526  1159		       c9 00		      CMP	#0
    527  115b		       d0 11		      BNE	.skipL045
    528  115d				   .condpart20
    529  115d		       a5 e1		      LDA	inv_fire_delay
    530  115f		       c9 b4		      CMP	#180
    531  1161		       d0 0b		      BNE	.skip20then
    532  1163				   .condpart21
    533  1163		       a5 d7		      LDA	inv_x
    534  1165		       85 dd		      STA	inv_shot_x
    535  1167		       a5 d8		      LDA	inv_y
    536  1169		       38		      SEC
    537  116a		       e9 09		      SBC	#9
    538  116c		       85 de		      STA	inv_shot_y
    539  116e				   .skip20then
    540  116e				   .skipL045
    541  116e				   .L046		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then player2x  =  inv_shot_x  :  player2y  =  inv_shot_y
    542  116e
    543  116e		       a5 e2		      LDA	inv_fired
    544  1170		       c9 00		      CMP	#0
    545  1172		       d0 0e		      BNE	.skipL046
    546  1174				   .condpart22
    547  1174		       a5 e1		      LDA	inv_fire_delay
    548  1176		       c9 b4		      CMP	#180
    549  1178		       d0 08		      BNE	.skip22then
    550  117a				   .condpart23
    551  117a		       a5 dd		      LDA	inv_shot_x
    552  117c		       85 86		      STA	player2x
    553  117e		       a5 de		      LDA	inv_shot_y
    554  1180		       85 8f		      STA	player2y
    555  1182				   .skip22then
    556  1182				   .skipL046
    557  1182				   .L047		;  if inv_fired  =  0	&&  inv_fire_delay  =  180 then inv_fired  =  1
    558  1182
    559  1182		       a5 e2		      LDA	inv_fired
    560  1184		       c9 00		      CMP	#0
    561  1186		       d0 0a		      BNE	.skipL047
    562  1188				   .condpart24
    563  1188		       a5 e1		      LDA	inv_fire_delay
    564  118a		       c9 b4		      CMP	#180
    565  118c		       d0 04		      BNE	.skip24then
    566  118e				   .condpart25
    567  118e		       a9 01		      LDA	#1
    568  1190		       85 e2		      STA	inv_fired
    569  1192				   .skip24then
    570  1192				   .skipL047
    571  1192				   .
    572  1192							; 
    573  1192
    574  1192				   .L048		;  if inv_fired  =  1 then inv_shot_y	=  inv_shot_y  -  2  :	player2y  =  inv_shot_y
    575  1192
    576  1192		       a5 e2		      LDA	inv_fired
    577  1194		       c9 01		      CMP	#1
    578  1196		       d0 0b		      BNE	.skipL048
    579  1198				   .condpart26
    580  1198		       a5 de		      LDA	inv_shot_y
    581  119a		       38		      SEC
    582  119b		       e9 02		      SBC	#2
    583  119d		       85 de		      STA	inv_shot_y
    584  119f		       a5 de		      LDA	inv_shot_y
    585  11a1		       85 8f		      STA	player2y
    586  11a3				   .skipL048
    587  11a3				   .
    588  11a3							; 
    589  11a3
    590  11a3				   .L049		;  if inv_shot_y  <  12 then inv_fired  =  0  :  inv_fire_delay  =  0	:  inv_shot_y  =  88  :  player2y  =  inv_shot_y
    591  11a3
    592  11a3		       a5 de		      LDA	inv_shot_y
    593  11a5		       c9 0c		      CMP	#12
    594  11a7		       b0 0e		      BCS	.skipL049
    595  11a9				   .condpart27
    596  11a9		       a9 00		      LDA	#0
    597  11ab		       85 e2		      STA	inv_fired
    598  11ad		       85 e1		      STA	inv_fire_delay
    599  11af		       a9 58		      LDA	#88
    600  11b1		       85 de		      STA	inv_shot_y
    601  11b3		       a5 de		      LDA	inv_shot_y
    602  11b5		       85 8f		      STA	player2y
    603  11b7				   .skipL049
    604  11b7				   .
    605  11b7							; 
    606  11b7
    607  11b7				   .L050		;  return
    608  11b7
    609  11b7		       ba		      tsx
    610  11b8		       b5 02		      lda	2,x	; check return address
    611  11ba		       49 d1		      eor	#(>*)	; vs. current PCH
    612  11bc		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    613  11be		       f0 03		      beq	*+5	; if equal, do normal return
    614  11c0		       4c dd ff 	      JMP	BS_return
    615  11c3		       60		      RTS
    616  11c4				   .
    617  11c4							; 
    618  11c4
    619  11c4				   .
    620  11c4							; 
    621  11c4
    622  11c4				   .
    623  11c4							; 
    624  11c4
    625  11c4				   .
    626  11c4							; 
    627  11c4
    628  11c4				   .
    629  11c4							; 
    630  11c4
    631  11c4				   .
    632  11c4							; 
    633  11c4
    634  11c4				   .col_shot_inv
    635  11c4							; col_shot_inv
    636  11c4
    637  11c4				   .L051		;  if shot_x  +  3  >=  inv_x	&&  shot_x  +  3  <=  inv_x  +	6  &&  shot_y  >  inv_y then inv_hit  =  1
    638  11c4
    639  11c4							; complex condition detected
    640  11c4		       a5 df		      LDA	shot_x
    641  11c6		       18		      CLC
    642  11c7		       69 03		      ADC	#3
    643  11c9							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
    644  11c9		       c5 d7		      CMP	inv_x
    645  11cb		       90 1d		      BCC	.skipL051
    646  11cd				   .condpart28
    647  11cd							; complex condition detected
    648  11cd		       a5 d7		      LDA	inv_x
    649  11cf		       18		      CLC
    650  11d0		       69 06		      ADC	#6
    651  11d2		       48		      PHA
    652  11d3		       a5 df		      LDA	shot_x
    653  11d5		       18		      CLC
    654  11d6		       69 03		      ADC	#3
    655  11d8		       48		      PHA
    656  11d9		       ba		      TSX
    657  11da		       68		      PLA
    658  11db		       68		      PLA
    659  11dc							; todo: this LDA is spurious and should be prevented ->	LDA  2,x
    660  11dc		       d5 01		      CMP	1,x
    661  11de		       90 0a		      BCC	.skip28then
    662  11e0				   .condpart29
    663  11e0		       a5 d8		      LDA	inv_y
    664  11e2		       c5 e0		      CMP	shot_y
    665  11e4		       b0 04		      BCS	.skip29then
    666  11e6				   .condpart30
    667  11e6		       a9 01		      LDA	#1
    668  11e8		       85 e4		      STA	inv_hit
    669  11ea				   .skip29then
    670  11ea				   .skip28then
    671  11ea				   .skipL051
    672  11ea				   .
    673  11ea							; 
    674  11ea
    675  11ea				   .L052		;  if inv_hit	=  1 then inv_blast_delay  =  inv_blast_delay  +  1
    676  11ea
    677  11ea		       a5 e4		      LDA	inv_hit
    678  11ec		       c9 01		      CMP	#1
    679  11ee		       d0 02		      BNE	.skipL052
    680  11f0				   .condpart31
    681  11f0		       e6 e5		      INC	inv_blast_delay
    682  11f2				   .skipL052
    683  11f2				   .
    684  11f2							; 
    685  11f2
    686  11f2				   .L053		;  if inv_blast_delay	>  30 then score  =  score  +  10  :  inv_hit  =  0  :	gosub reset_blast
    687  11f2
    688  11f2		       a9 1e		      LDA	#30
    689  11f4		       c5 e5		      CMP	inv_blast_delay
    690  11f6		       b0 1c		      BCS	.skipL053
    691  11f8				   .condpart32
    692  11f8		       f8		      SED
    693  11f9		       18		      CLC
    694  11fa		       a5 d4		      LDA	score+2
    695  11fc		       69 10		      ADC	#$10
    696  11fe		       85 d4		      STA	score+2
    697  1200		       a5 d3		      LDA	score+1
    698  1202		       69 00		      ADC	#$00
    699  1204		       85 d3		      STA	score+1
    700  1206		       a5 d2		      LDA	score
    701  1208		       69 00		      ADC	#$00
    702  120a		       85 d2		      STA	score
    703  120c		       d8		      CLD
    704  120d		       a9 00		      LDA	#0
    705  120f		       85 e4		      STA	inv_hit
    706  1211		       20 33 d2 	      jsr	.reset_blast
    707  1214
    708  1214				   .skipL053
    709  1214				   .
    710  1214							; 
    711  1214
    712  1214				   .L054		;  if inv_hit	=  1 then player0:  
    713  1214
    714  1214		       a5 e4		      LDA	inv_hit
    715  1216		       c9 01		      CMP	#1
    716  1218		       d0 0c		      BNE	.skipL054
    717  121a				   .condpart33
    718  121a		       a2 74		      LDX	#<player33then_0
    719  121c		       86 a2		      STX	player0pointerlo
    720  121e		       a9 f4		      LDA	#>player33then_0
    721  1220		       85 a3		      STA	player0pointerhi
    722  1222		       a9 09		      LDA	#9
    723  1224		       85 b0		      STA	player0height
    724  1226				   .skipL054
    725  1226				   .
    726  1226							; 
    727  1226
    728  1226				   .L055		;  return
    729  1226
    730  1226		       ba		      tsx
    731  1227		       b5 02		      lda	2,x	; check return address
    732  1229		       49 d2		      eor	#(>*)	; vs. current PCH
    733  122b		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    734  122d		       f0 03		      beq	*+5	; if equal, do normal return
    735  122f		       4c dd ff 	      JMP	BS_return
    736  1232		       60		      RTS
    737  1233				   .
    738  1233							; 
    739  1233
    740  1233				   .
    741  1233							; 
    742  1233
    743  1233				   .
    744  1233							; 
    745  1233
    746  1233				   .
    747  1233							; 
    748  1233
    749  1233				   .
    750  1233							; 
    751  1233
    752  1233				   .
    753  1233							; 
    754  1233
    755  1233				   .reset_blast
    756  1233							; reset_blast
    757  1233
    758  1233				   .L056		;  player0:  
    759  1233
    760  1233		       a2 7d		      LDX	#<playerL056_0
    761  1235		       86 a2		      STX	player0pointerlo
    762  1237		       a9 f4		      LDA	#>playerL056_0
    763  1239		       85 a3		      STA	player0pointerhi
    764  123b		       a9 09		      LDA	#9
    765  123d		       85 b0		      STA	player0height
    766  123f				   .
    767  123f							; 
    768  123f
    769  123f				   .
    770  123f							; 
    771  123f
    772  123f				   .L057		;  inv_blast_delay  =	0  :  inv_x  =	 ( rand & 117 )   +  26  :  inv_y  =  76
    773  123f
    774  123f		       a9 00		      LDA	#0
    775  1241		       85 e5		      STA	inv_blast_delay
    776  1243							; complex statement detected
    777  1243		       85 d1		      sta	temp7
    778  1245		       a9 d2		      lda	#>(ret_point2-1)
    779  1247		       48		      pha
    780  1248		       a9 5a		      lda	#<(ret_point2-1)
    781  124a		       48		      pha
    782  124b		       a9 f4		      lda	#>(randomize-1)
    783  124d		       48		      pha
    784  124e		       a9 31		      lda	#<(randomize-1)
    785  1250		       48		      pha
    786  1251		       a5 d1		      lda	temp7
    787  1253		       48		      pha
    788  1254		       8a		      txa
    789  1255		       48		      pha
    790  1256		       a2 02		      ldx	#2
    791  1258		       4c eb ff 	      jmp	BS_jsr
    792  125b				   ret_point2
    793  125b		       29 75		      AND	#117
    794  125d		       18		      CLC
    795  125e		       69 1a		      ADC	#26
    796  1260		       85 d7		      STA	inv_x
    797  1262		       a9 4c		      LDA	#76
    798  1264		       85 d8		      STA	inv_y
    799  1266				   .
    800  1266							; 
    801  1266
    802  1266				   .L058		;  return
    803  1266
    804  1266		       ba		      tsx
    805  1267		       b5 02		      lda	2,x	; check return address
    806  1269		       49 d2		      eor	#(>*)	; vs. current PCH
    807  126b		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    808  126d		       f0 03		      beq	*+5	; if equal, do normal return
    809  126f		       4c dd ff 	      JMP	BS_return
    810  1272		       60		      RTS
    811  1273				   .
    812  1273							; 
    813  1273
    814  1273				   .
    815  1273							; 
    816  1273
    817  1273				   .
    818  1273							; 
    819  1273
    820  1273				   .
    821  1273							; 
    822  1273
    823  1273				   .
    824  1273							; 
    825  1273
    826  1273				   .
    827  1273							; 
    828  1273
    829  1273				   .draw__move_turret
    830  1273							; draw__move_turret
    831  1273
    832  1273				   .L059		;  player1:
    833  1273
    834  1273		       a2 86		      LDX	#<playerL059_1
    835  1275		       86 a6		      STX	player1pointerlo
    836  1277		       a9 f4		      LDA	#>playerL059_1
    837  1279		       85 ab		      STA	player1pointerhi
    838  127b		       a9 09		      LDA	#9
    839  127d		       85 b1		      STA	player1height
    840  127f				   .
    841  127f							; 
    842  127f
    843  127f				   .
    844  127f							; 
    845  127f
    846  127f				   .L060		;  _COLUP1  =	196
    847  127f
    848  127f		       a9 c4		      LDA	#196
    849  1281		       85 98		      STA	_COLUP1
    850  1283				   .
    851  1283							; 
    852  1283
    853  1283				   .L061		;  if joy0left  &&  tur_x  >=	26 then tur_x  =  tur_x  -  1
    854  1283
    855  1283		       2c 80 02 	      bit	SWCHA
    856  1286		       70 08		      BVS	.skipL061
    857  1288				   .condpart34
    858  1288		       a5 da		      LDA	tur_x
    859  128a		       c9 1a		      CMP	#26
    860  128c		       90 02		      BCC	.skip34then
    861  128e				   .condpart35
    862  128e		       c6 da		      DEC	tur_x
    863  1290				   .skip34then
    864  1290				   .skipL061
    865  1290				   .L062		;  if joy0right  &&  tur_x  <=  143 then tur_x  =  tur_x  +  1
    866  1290
    867  1290		       2c 80 02 	      bit	SWCHA
    868  1293		       30 08		      BMI	.skipL062
    869  1295				   .condpart36
    870  1295		       a9 8f		      LDA	#143
    871  1297		       c5 da		      CMP	tur_x
    872  1299		       90 02		      BCC	.skip36then
    873  129b				   .condpart37
    874  129b		       e6 da		      INC	tur_x
    875  129d				   .skip36then
    876  129d				   .skipL062
    877  129d				   .
    878  129d							; 
    879  129d
    880  129d				   .
    881  129d							; 
    882  129d
    883  129d				   .
    884  129d							; 
    885  129d
    886  129d				   .
    887  129d							; 
    888  129d
    889  129d				   .L063		;  player1x  =  tur_x	:  player1y  =	tur_y
    890  129d
    891  129d		       a5 da		      LDA	tur_x
    892  129f		       85 85		      STA	player1x
    893  12a1		       a5 db		      LDA	tur_y
    894  12a3		       85 8e		      STA	player1y
    895  12a5				   .
    896  12a5							; 
    897  12a5
    898  12a5				   .L064		;  return
    899  12a5
    900  12a5		       ba		      tsx
    901  12a6		       b5 02		      lda	2,x	; check return address
    902  12a8		       49 d2		      eor	#(>*)	; vs. current PCH
    903  12aa		       29 e0		      and	#$E0	;  mask off all but top 3 bits
    904  12ac		       f0 03		      beq	*+5	; if equal, do normal return
    905  12ae		       4c dd ff 	      JMP	BS_return
    906  12b1		       60		      RTS
    907  12b2				   .
    908  12b2							; 
    909  12b2
    910  12b2				   .
    911  12b2							; 
    912  12b2
    913  12b2				   .
    914  12b2							; 
    915  12b2
    916  12b2				   .
    917  12b2							; 
    918  12b2
    919  12b2				   .
    920  12b2							; 
    921  12b2
    922  12b2				   .
    923  12b2							; 
    924  12b2
    925  12b2				   .draw__move_turret_shot
    926  12b2							; draw__move_turret_shot
    927  12b2
    928  12b2				   .L065		;  player3:
    929  12b2
    930  12b2		       a2 8e		      LDX	#<playerL065_3
    931  12b4		       86 a8		      STX	player3pointerlo
    932  12b6		       a9 f4		      LDA	#>playerL065_3
    933  12b8		       85 ad		      STA	player3pointerhi
    934  12ba		       a9 09		      LDA	#9
    935  12bc		       85 b3		      STA	player3height
    936  12be				   .
    937  12be							; 
    938  12be
    939  12be				   .L066		;  COLUP3  =  14
    940  12be
    941  12be		       a9 0e		      LDA	#14
    942  12c0		       85 9a		      STA	COLUP3
    943  12c2				   .
    944  12c2							; 
    945  12c2
    946  12c2				   .L067		;  if joy0fire  &&  tur_fired	=  0 then tur_fired  =	1  :  shot_x  =  tur_x	:  shot_y  =  tur_y  +	1  :  player3x	=  shot_x  :  player3y	=  shot_y
    947  12c2
    948  12c2		       24 0c		      bit	INPT4
    949  12c4		       30 1d		      BMI	.skipL067
    950  12c6				   .condpart38
    951  12c6		       a5 e3		      LDA	tur_fired
    952  12c8		       c9 00		      CMP	#0
    953  12ca		       d0 17		      BNE	.skip38then
    954  12cc				   .condpart39
    955  12cc		       a9 01		      LDA	#1
    956  12ce		       85 e3		      STA	tur_fired
    957  12d0		       a5 da		      LDA	tur_x
    958  12d2		       85 df		      STA	shot_x
    959  12d4		       a5 db		      LDA	tur_y
    960  12d6		       18		      CLC
    961  12d7		       69 01		      ADC	#1
    962  12d9		       85 e0		      STA	shot_y
    963  12db		       a5 df		      LDA	shot_x
    964  12dd		       85 87		      STA	player3x
    965  12df		       a5 e0		      LDA	shot_y
    966  12e1		       85 90		      STA	player3y
    967  12e3				   .skip38then
    968  12e3				   .skipL067
    969  12e3				   .
    970  12e3							; 
    971  12e3
    972  12e3				   .L068		;  if tur_fired  =  1 then shot_y  =  shot_y  +  2  :	player3x  =  shot_x  :	player3y  =  shot_y
    973  12e3
    974  12e3		       a5 e3		      LDA	tur_fired
    975  12e5		       c9 01		      CMP	#1
    976  12e7		       d0 0f		      BNE	.skipL068
    977  12e9				   .condpart40
    978  12e9		       a5 e0		      LDA	shot_y
    979  12eb		       18		      CLC
    980  12ec		       69 02		      ADC	#2
    981  12ee		       85 e0		      STA	shot_y
    982  12f0		       a5 df		      LDA	shot_x
    983  12f2		       85 87		      STA	player3x
    984  12f4		       a5 e0		      LDA	shot_y
    985  12f6		       85 90		      STA	player3y
    986  12f8				   .skipL068
    987  12f8				   .
    988  12f8							; 
    989  12f8
    990  12f8				   .L069		;  if shot_y  >  77 then tur_fired  =	0  :  shot_y  =  0  :  player3y  =  shot_y
    991  12f8
    992  12f8		       a9 4d		      LDA	#77
    993  12fa		       c5 e0		      CMP	shot_y
    994  12fc		       b0 0a		      BCS	.skipL069
    995  12fe				   .condpart41
    996  12fe		       a9 00		      LDA	#0
    997  1300		       85 e3		      STA	tur_fired
    998  1302		       85 e0		      STA	shot_y
    999  1304		       a5 e0		      LDA	shot_y
   1000  1306		       85 90		      STA	player3y
   1001  1308				   .skipL069
   1002  1308				   .
   1003  1308							; 
   1004  1308
   1005  1308				   .L070		;  return
   1006  1308
   1007  1308		       ba		      tsx
   1008  1309		       b5 02		      lda	2,x	; check return address
   1009  130b		       49 d3		      eor	#(>*)	; vs. current PCH
   1010  130d		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   1011  130f		       f0 03		      beq	*+5	; if equal, do normal return
   1012  1311		       4c dd ff 	      JMP	BS_return
   1013  1314		       60		      RTS
   1014  1315				   .
   1015  1315							; 
   1016  1315
   1017  1315				   .
   1018  1315							; 
   1019  1315
   1020  1315				   .
   1021  1315							; 
   1022  1315
   1023  1315				   .
   1024  1315							; 
   1025  1315
   1026  1315				   .
   1027  1315							; 
   1028  1315
   1029  1315				   .game_over
   1030  1315							; game_over
   1031  1315
   1032  1315				   .
   1033  1315							; 
   1034  1315
   1035  1315				   .L071		;  if joy0up then reboot
   1036  1315
   1037  1315		       a9 10		      lda	#$10
   1038  1317		       2c 80 02 	      bit	SWCHA
   1039  131a		       d0 03		      BNE	.skipL071
   1040  131c				   .condpart42
   1041  131c		       6c fc ff 	      JMP	($FFFC)
   1042  131f				   .skipL071
   1043  131f				   .
   1044  131f							; 
   1045  131f
   1046  131f				   .L072		;  score  =  50
   1047  131f
   1048  131f		       a9 50		      LDA	#$50
   1049  1321		       85 d4		      STA	score+2
   1050  1323		       a9 00		      LDA	#$00
   1051  1325		       85 d3		      STA	score+1
   1052  1327		       a9 00		      LDA	#$00
   1053  1329		       85 d2		      STA	score
   1054  132b				   .
   1055  132b							; 
   1056  132b
   1057  132b				   .L073		;  player2:
   1058  132b
   1059  132b		       a2 96		      LDX	#<playerL073_2
   1060  132d		       86 a7		      STX	player2pointerlo
   1061  132f		       a9 f4		      LDA	#>playerL073_2
   1062  1331		       85 ac		      STA	player2pointerhi
   1063  1333		       a9 1a		      LDA	#26
   1064  1335		       85 b2		      STA	player2height
   1065  1337				   .
   1066  1337							; 
   1067  1337
   1068  1337				   .L074		;  player3:
   1069  1337
   1070  1337		       a2 af		      LDX	#<playerL074_3
   1071  1339		       86 a8		      STX	player3pointerlo
   1072  133b		       a9 f4		      LDA	#>playerL074_3
   1073  133d		       85 ad		      STA	player3pointerhi
   1074  133f		       a9 1a		      LDA	#26
   1075  1341		       85 b3		      STA	player3height
   1076  1343				   .
   1077  1343							; 
   1078  1343
   1079  1343				   .L075		;  rem  ; GA
   1080  1343
   1081  1343				   .L076		;  rem  player2:
   1082  1343
   1083  1343				   .L077		;  rem  %00000000
   1084  1343
   1085  1343				   .L078		;  rem  %00000000
   1086  1343
   1087  1343				   .L079		;  rem  %11101010
   1088  1343
   1089  1343				   .L080		;  rem  %10101010
   1090  1343
   1091  1343				   .L081		;  rem  %10101110
   1092  1343
   1093  1343				   .L082		;  rem  %10001010
   1094  1343
   1095  1343				   .L083		;  rem  %10001010
   1096  1343
   1097  1343				   .L084		;  rem  %11101110
   1098  1343
   1099  1343				   .L085		;  rem end
   1100  1343
   1101  1343				   .L086		;  rem  COLUP2 = 14
   1102  1343
   1103  1343				   .L087		;  rem 
   1104  1343
   1105  1343				   .L088		;  rem  ; ME
   1106  1343
   1107  1343				   .L089		;  rem  player3:
   1108  1343
   1109  1343				   .L090		;  rem  %00000000
   1110  1343
   1111  1343				   .L091		;  rem  %00000000
   1112  1343
   1113  1343				   .L092		;  rem  %10101110
   1114  1343
   1115  1343				   .L093		;  rem  %10101000
   1116  1343
   1117  1343				   .L094		;  rem  %10101000
   1118  1343
   1119  1343				   .L095		;  rem  %10101100
   1120  1343
   1121  1343				   .L096		;  rem  %11101000
   1122  1343
   1123  1343				   .L097		;  rem  %10101110
   1124  1343
   1125  1343				   .L098		;  rem end
   1126  1343
   1127  1343				   .L099		;  rem  COLUP3 = 14
   1128  1343
   1129  1343				   .L0100		;  rem 
   1130  1343
   1131  1343				   .L0101		;  rem  ; OV
   1132  1343
   1133  1343				   .L0102		;  rem  player4:
   1134  1343
   1135  1343				   .L0103		;  rem  %00000000
   1136  1343
   1137  1343				   .L0104		;  rem  %00000000
   1138  1343
   1139  1343				   .L0105		;  rem  %11100100
   1140  1343
   1141  1343				   .L0106		;  rem  %10101010
   1142  1343
   1143  1343				   .L0107		;  rem  %10101010
   1144  1343
   1145  1343				   .L0108		;  rem  %10101010
   1146  1343
   1147  1343				   .L0109		;  rem  %10101010
   1148  1343
   1149  1343				   .L0110		;  rem  %11101010
   1150  1343
   1151  1343				   .L0111		;  rem end
   1152  1343
   1153  1343				   .L0112		;  rem  COLUP4 = 14
   1154  1343
   1155  1343				   .L0113		;  rem 
   1156  1343
   1157  1343				   .L0114		;  rem  ; ER
   1158  1343
   1159  1343				   .L0115		;  rem  player5:
   1160  1343
   1161  1343				   .L0116		;  rem  %00000000
   1162  1343
   1163  1343				   .L0117		;  rem  %00000000
   1164  1343
   1165  1343				   .L0118		;  rem  %11101010
   1166  1343
   1167  1343				   .L0119		;  rem  %10001010
   1168  1343
   1169  1343				   .L0120		;  rem  %11001010
   1170  1343
   1171  1343				   .L0121		;  rem  %10001100
   1172  1343
   1173  1343				   .L0122		;  rem  %10001010
   1174  1343
   1175  1343				   .L0123		;  rem  %11101100
   1176  1343
   1177  1343				   .L0124		;  rem end
   1178  1343
   1179  1343				   .L0125		;  rem  COLUP5 = 14
   1180  1343
   1181  1343				   .
   1182  1343							; 
   1183  1343
   1184  1343				   .L0126		;  player0x  =  0  :  player0y  =  0
   1185  1343
   1186  1343		       a9 00		      LDA	#0
   1187  1345		       85 84		      STA	player0x
   1188  1347		       85 8d		      STA	player0y
   1189  1349				   .L0127		;  player1x  =  0  :  player1y  =  0
   1190  1349
   1191  1349		       a9 00		      LDA	#0
   1192  134b		       85 85		      STA	player1x
   1193  134d		       85 8e		      STA	player1y
   1194  134f				   .L0128		;  COLUP0  =  0
   1195  134f
   1196  134f		       a9 00		      LDA	#0
   1197  1351		       85 06		      STA	COLUP0
   1198  1353				   .L0129		;  COLUP1  =  0
   1199  1353
   1200  1353		       a9 00		      LDA	#0
   1201  1355		       85 07		      STA	COLUP1
   1202  1357				   .
   1203  1357							; 
   1204  1357
   1205  1357				   .L0130		;  player2x  =  85  :	player2y  =  66
   1206  1357
   1207  1357		       a9 55		      LDA	#85
   1208  1359		       85 86		      STA	player2x
   1209  135b		       a9 42		      LDA	#66
   1210  135d		       85 8f		      STA	player2y
   1211  135f				   .L0131		;  player3x  =  85  :	player3y  =  39
   1212  135f
   1213  135f		       a9 55		      LDA	#85
   1214  1361		       85 87		      STA	player3x
   1215  1363		       a9 27		      LDA	#39
   1216  1365		       85 90		      STA	player3y
   1217  1367				   .
   1218  1367							; 
   1219  1367
   1220  1367				   .L0132		;  rem player2x = 70 : player2y = 50
   1221  1367
   1222  1367				   .L0133		;  rem  player3x = 78 : player3y = 50
   1223  1367
   1224  1367				   .L0134		;  rem  player4x = 86 : player4y = 50
   1225  1367
   1226  1367				   .L0135		;  rem  player5x = 94 : player5y = 50
   1227  1367
   1228  1367				   .L0136		;  rem 
   1229  1367
   1230  1367				   .
   1231  1367							; 
   1232  1367
   1233  1367				   .L0137		;  drawscreen
   1234  1367
   1235  1367		       85 d1		      sta	temp7
   1236  1369		       a9 d3		      lda	#>(ret_point3-1)
   1237  136b		       48		      pha
   1238  136c		       a9 7e		      lda	#<(ret_point3-1)
   1239  136e		       48		      pha
   1240  136f		       a9 f0		      lda	#>(drawscreen-1)
   1241  1371		       48		      pha
   1242  1372		       a9 39		      lda	#<(drawscreen-1)
   1243  1374		       48		      pha
   1244  1375		       a5 d1		      lda	temp7
   1245  1377		       48		      pha
   1246  1378		       8a		      txa
   1247  1379		       48		      pha
   1248  137a		       a2 02		      ldx	#2
   1249  137c		       4c eb ff 	      jmp	BS_jsr
   1250  137f				   ret_point3
   1251  137f				   .
   1252  137f							; 
   1253  137f
   1254  137f				   .L0138		;  goto game_over
   1255  137f
   1256  137f		       4c 15 d3 	      jmp	.game_over
   1257  1382
   1258  1382					      if	ECHO1
      3154 bytes of ROM space left in bank 1
   1259  1382					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1260  1382					      endif
   1261  1382		       00 01	   ECHO1      =	1
   1262  1fd4					      ORG	$1FF4-bscode_length
   1263  1fd4					      RORG	$DFF4-bscode_length
   1264  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1265  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1266  1fd6				  -	      stx	FASTFETCH
   1267  1fd6					      endif
   1268  1fd6		       9a		      txs
   1269  1fd7				  -	      if	bankswitch == 64
   1270  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1271  1fd7					      else
   1272  1fd7		       a9 f3		      lda	#>(start-1)
   1273  1fd9					      endif
   1274  1fd9		       48		      pha
   1275  1fda		       a9 f4		      lda	#<(start-1)
   1276  1fdc		       48		      pha
   1277  1fdd		       48		      pha
   1278  1fde		       8a		      txa
   1279  1fdf		       48		      pha
   1280  1fe0		       ba		      tsx
   1281  1fe1					      if	bankswitch != 64
   1282  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1283  1fe3		       2a		      rol
   1284  1fe4		       2a		      rol
   1285  1fe5		       2a		      rol
   1286  1fe6		       2a		      rol
   1287  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1288  1fe9		       aa		      tax
   1289  1fea		       e8		      inx
   1290  1feb				  -	      else
   1291  1feb				  -	      lda	4,x	; get high byte of return address
   1292  1feb				  -	      tay
   1293  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1294  1feb				  -	      sta	4,x
   1295  1feb				  -	      tya
   1296  1feb				  -	      lsr
   1297  1feb				  -	      lsr
   1298  1feb				  -	      lsr
   1299  1feb				  -	      lsr
   1300  1feb				  -	      tax
   1301  1feb				  -	      inx
   1302  1feb					      endif
   1303  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1304  1fee		       68		      pla
   1305  1fef		       aa		      tax
   1306  1ff0		       68		      pla
   1307  1ff1		       60		      rts
   1308  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1309  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1310  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1311  1ff2					      endif
   1312  1ffc					      ORG	$1FFC
   1313  1ffc					      RORG	$DFFC
   1314  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
   1315  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
   1316  2000					      ORG	$2000
   1317  2000					      RORG	$F000
   1318  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1319  2000
   1320  2000				   FineAdjustTableBegin
   1321  2000		       60		      .byte.b	%01100000	;left 6
   1322  2001		       50		      .byte.b	%01010000
   1323  2002		       40		      .byte.b	%01000000
   1324  2003		       30		      .byte.b	%00110000
   1325  2004		       20		      .byte.b	%00100000
   1326  2005		       10		      .byte.b	%00010000
   1327  2006		       00		      .byte.b	%00000000	;left 0
   1328  2007		       f0		      .byte.b	%11110000
   1329  2008		       e0		      .byte.b	%11100000
   1330  2009		       d0		      .byte.b	%11010000
   1331  200a		       c0		      .byte.b	%11000000
   1332  200b		       b0		      .byte.b	%10110000
   1333  200c		       a0		      .byte.b	%10100000
   1334  200d		       90		      .byte.b	%10010000
   1335  200e		       80		      .byte.b	%10000000	;right 8
   1336  200e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
   1337  200f
   1338  200f				   PFStart
   1339  200f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
   1340  2017				   blank_pf
   1341  2017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
   1342  201f							; .byte 43,21,0,10,0,0,0,5
   1343  201f				  -	      ifconst	screenheight
   1344  201f				  -pfsub
   1345  201f				  -	      .byte	8,4,2,2,1,0,0,1,0
   1346  201f					      endif
   1347  201f							;--set initial P1 positions
   1348  201f				   multisprite_setup
   1349  201f		       a9 0f		      lda	#15
   1350  2021		       85 c4		      sta	pfheight
   1351  2023
   1352  2023		       a2 04		      ldx	#4
   1353  2025							; stx temp3
   1354  2025				   SetCopyHeight
   1355  2025							;	lda #76
   1356  2025							;	sta NewSpriteX,X
   1357  2025							;	lda CopyColorData,X
   1358  2025							;	sta NewCOLUP1,X
   1359  2025							;lda SpriteHeightTable,X
   1360  2025							; sta spriteheight,x
   1361  2025		       8a		      txa
   1362  2026		       95 9d		      sta	SpriteGfxIndex,X
   1363  2028		       95 f1		      sta	spritesort,X
   1364  202a		       ca		      dex
   1365  202b		       10 f8		      bpl	SetCopyHeight
   1366  202d
   1367  202d
   1368  202d
   1369  202d							; since we can't turn off pf, point PF to zeros here
   1370  202d		       a9 f0		      lda	#>blank_pf
   1371  202f		       85 be		      sta	PF2pointer+1
   1372  2031		       85 bc		      sta	PF1pointer+1
   1373  2033		       a9 17		      lda	#<blank_pf
   1374  2035		       85 bd		      sta	PF2pointer
   1375  2037		       85 bb		      sta	PF1pointer
   1376  2039		       60		      rts
   1377  203a
   1378  203a				   drawscreen
   1379  203a				  -	      ifconst	debugscore
   1380  203a				  -	      jsr	debugcycles
   1381  203a					      endif
   1382  203a
   1383  203a				   WaitForOverscanEnd
   1384  203a		       ad 84 02 	      lda	INTIM
   1385  203d		       30 fb		      bmi	WaitForOverscanEnd
   1386  203f
   1387  203f		       a9 02		      lda	#2
   1388  2041		       85 02		      sta	WSYNC
   1389  2043		       85 00		      sta	VSYNC
   1390  2045		       85 02		      sta	WSYNC
   1391  2047		       85 02		      sta	WSYNC
   1392  2049		       4a		      lsr
   1393  204a		       85 27		      sta	VDELBL
   1394  204c		       85 25		      sta	VDELP0
   1395  204e		       85 02		      sta	WSYNC
   1396  2050		       85 00		      sta	VSYNC	;turn off VSYNC
   1397  2052				  -	      ifconst	overscan_time
   1398  2052				  -	      lda	#overscan_time+5+128
   1399  2052					      else
   1400  2052		       a9 aa		      lda	#42+128
   1401  2054					      endif
   1402  2054		       8d 96 02 	      sta	TIM64T
   1403  2057
   1404  2057							; run possible vblank bB code
   1405  2057				  -	      ifconst	vblank_bB_code
   1406  2057				  -	      jsr	vblank_bB_code
   1407  2057					      endif
   1408  2057
   1409  2057		       20 dc f1 	      jsr	setscorepointers
   1410  205a		       20 7b f3 	      jsr	SetupP1Subroutine
   1411  205d
   1412  205d							;-------------
   1413  205d
   1414  205d
   1415  205d
   1416  205d
   1417  205d
   1418  205d							;--position P0, M0, M1, BL
   1419  205d
   1420  205d		       20 b5 f0 	      jsr	PrePositionAllObjects
   1421  2060
   1422  2060							;--set up player 0 pointer
   1423  2060
   1424  2060		       c6 8d		      dec	player0y
   1425  2062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
   1426  2064		       38		      sec
   1427  2065		       e5 8d		      sbc	player0y
   1428  2067		       18		      clc
   1429  2068		       65 b0		      adc	player0height
   1430  206a		       85 a2		      sta	player0pointer
   1431  206c
   1432  206c		       a5 8d		      lda	player0y
   1433  206e		       85 cf		      sta	P0Top
   1434  2070		       38		      sec
   1435  2071		       e5 b0		      sbc	player0height
   1436  2073		       18		      clc
   1437  2074		       69 80		      adc	#$80
   1438  2076		       85 a4		      sta	P0Bottom
   1439  2078
   1440  2078
   1441  2078							;--some final setup
   1442  2078
   1443  2078		       a2 04		      ldx	#4
   1444  207a		       a9 80		      lda	#$80
   1445  207c				   cycle74_HMCLR
   1446  207c		       95 20		      sta	HMP0,X
   1447  207e		       ca		      dex
   1448  207f		       10 fb		      bpl	cycle74_HMCLR
   1449  2081							;	sta HMCLR
   1450  2081
   1451  2081
   1452  2081		       a9 00		      lda	#0
   1453  2083		       85 0e		      sta	PF1
   1454  2085		       85 0f		      sta	PF2
   1455  2087		       85 1b		      sta	GRP0
   1456  2089		       85 1c		      sta	GRP1
   1457  208b
   1458  208b
   1459  208b		       20 d0 f0 	      jsr	KernelSetupSubroutine
   1460  208e
   1461  208e				   WaitForVblankEnd
   1462  208e		       ad 84 02 	      lda	INTIM
   1463  2091		       30 fb		      bmi	WaitForVblankEnd
   1464  2093		       a9 00		      lda	#0
   1465  2095		       85 02		      sta	WSYNC
   1466  2097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
   1467  2099		       85 2c		      sta	CXCLR
   1468  209b
   1469  209b
   1470  209b		       4c 5d f1 	      jmp	KernelRoutine
   1471  209e
   1472  209e
   1473  209e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
   1474  209e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
   1475  209e							;if you do not wish to write to P1 during this function, make
   1476  209e							;sure Y==0 before you call it.  This function will change Y, and A
   1477  209e							;will be the value put into HMxx when returned.
   1478  209e							;Call this function with at least 11 cycles left in the scanline 
   1479  209e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
   1480  209e							;into the second scanline
   1481  209e		       38		      sec
   1482  209f		       85 02		      sta	WSYNC	;begin line 1
   1483  20a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
   1484  20a4				   DivideBy15Loop
   1485  20a4		       e9 0f		      sbc	#15
   1486  20a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
   1487  20a8
   1488  20a8		       a8		      tay		;+2	10/15/...60
   1489  20a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
   1490  20ac
   1491  20ac							;	15
   1492  20ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
   1493  20ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
   1494  20b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1495  20b2		       85 2a		      sta	HMOVE	;+3
   1496  20b4		       60		      rts		;+6	 9
   1497  20b5
   1498  20b5							;-------------------------------------------------------------------------
   1499  20b5
   1500  20b5				   PrePositionAllObjects
   1501  20b5
   1502  20b5		       a2 04		      ldx	#4
   1503  20b7		       a5 82		      lda	ballx
   1504  20b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1505  20bc
   1506  20bc		       ca		      dex
   1507  20bd		       a5 81		      lda	missile1x
   1508  20bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1509  20c2
   1510  20c2		       ca		      dex
   1511  20c3		       a5 80		      lda	missile0x
   1512  20c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1513  20c8
   1514  20c8		       ca		      dex
   1515  20c9		       ca		      dex
   1516  20ca		       a5 84		      lda	player0x
   1517  20cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
   1518  20cf
   1519  20cf		       60		      rts
   1520  20d0
   1521  20d0
   1522  20d0							;-------------------------------------------------------------------------
   1523  20d0
   1524  20d0
   1525  20d0
   1526  20d0
   1527  20d0
   1528  20d0
   1529  20d0
   1530  20d0
   1531  20d0							;-------------------------------------------------------------------------
   1532  20d0
   1533  20d0
   1534  20d0				   KernelSetupSubroutine
   1535  20d0
   1536  20d0		       a2 04		      ldx	#4
   1537  20d2				   AdjustYValuesUpLoop
   1538  20d2		       b5 8e		      lda	NewSpriteY,X
   1539  20d4		       18		      clc
   1540  20d5		       69 02		      adc	#2
   1541  20d7		       95 8e		      sta	NewSpriteY,X
   1542  20d9		       ca		      dex
   1543  20da		       10 f6		      bpl	AdjustYValuesUpLoop
   1544  20dc
   1545  20dc
   1546  20dc		       a6 cd		      ldx	temp3	; first sprite displayed
   1547  20de
   1548  20de		       b5 9d		      lda	SpriteGfxIndex,x
   1549  20e0		       a8		      tay
   1550  20e1		       b9 8e 00 	      lda	NewSpriteY,y
   1551  20e4		       85 ce		      sta	RepoLine
   1552  20e6
   1553  20e6		       b5 9c		      lda	SpriteGfxIndex-1,x
   1554  20e8		       a8		      tay
   1555  20e9		       b9 8e 00 	      lda	NewSpriteY,y
   1556  20ec		       85 d0		      sta	temp6
   1557  20ee
   1558  20ee		       86 83		      stx	SpriteIndex
   1559  20f0
   1560  20f0
   1561  20f0
   1562  20f0		       a9 ff		      lda	#255
   1563  20f2		       85 a5		      sta	P1Bottom
   1564  20f4
   1565  20f4		       a5 8d		      lda	player0y
   1566  20f6				  -	      ifconst	screenheight
   1567  20f6				  -	      cmp	#screenheight+1
   1568  20f6					      else
   1569  20f6		       c9 59		      cmp	#$59
   1570  20f8					      endif
   1571  20f8		       90 04		      bcc	nottoohigh
   1572  20fa		       a5 a4		      lda	P0Bottom
   1573  20fc		       85 cf		      sta	P0Top
   1574  20fe
   1575  20fe
   1576  20fe
   1577  20fe				   nottoohigh
   1578  20fe		       60		      rts
   1579  20ff
   1580  20ff							;-------------------------------------------------------------------------
   1581  20ff
   1582  20ff
   1583  20ff
   1584  20ff
   1585  20ff
   1586  20ff							;*************************************************************************
   1587  20ff
   1588  20ff							;-------------------------------------------------------------------------
   1589  20ff							;-------------------------Data Below--------------------------------------
   1590  20ff							;-------------------------------------------------------------------------
   1591  20ff
   1592  20ff				   MaskTable
   1593  20ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
   1594  2104
   1595  2104							; shove 6-digit score routine here
   1596  2104
   1597  2104				   sixdigscore
   1598  2104		       a9 00		      lda	#0
   1599  2106							;	sta COLUBK
   1600  2106		       85 0d		      sta	PF0
   1601  2108		       85 0e		      sta	PF1
   1602  210a		       85 0f		      sta	PF2
   1603  210c		       85 1f		      sta	ENABL
   1604  210e		       85 1d		      sta	ENAM0
   1605  2110		       85 1e		      sta	ENAM1
   1606  2112							;end of kernel here
   1607  2112
   1608  2112
   1609  2112							; 6 digit score routine
   1610  2112							; lda #0
   1611  2112							; sta PF1
   1612  2112							; sta PF2
   1613  2112							; tax
   1614  2112
   1615  2112		       85 02		      sta	WSYNC	;,x
   1616  2114
   1617  2114							;		  STA WSYNC ;first one, need one more
   1618  2114		       85 0b		      sta	REFP0
   1619  2116		       85 0c		      sta	REFP1
   1620  2118		       85 1b		      STA	GRP0
   1621  211a		       85 1c		      STA	GRP1
   1622  211c		       85 2b		      sta	HMCLR
   1623  211e
   1624  211e							; restore P0pointer
   1625  211e
   1626  211e		       a5 a2		      lda	player0pointer
   1627  2120		       18		      clc
   1628  2121		       65 8d		      adc	player0y
   1629  2123		       38		      sec
   1630  2124		       e5 b0		      sbc	player0height
   1631  2126		       85 a2		      sta	player0pointer
   1632  2128		       e6 8d		      inc	player0y
   1633  212a
   1634  212a				  -	      ifconst	vblank_time
   1635  212a				  -	      ifconst	screenheight
   1636  212a				  -	      if	screenheight == 84
   1637  212a				  -	      lda	#vblank_time+9+128+10
   1638  212a				  -	      else
   1639  212a				  -	      lda	#vblank_time+9+128+19
   1640  212a				  -	      endif
   1641  212a				  -	      else
   1642  212a				  -	      lda	#vblank_time+9+128
   1643  212a				  -	      endif
   1644  212a					      else
   1645  212a				  -	      ifconst	screenheight
   1646  212a				  -	      if	screenheight == 84
   1647  212a				  -	      lda	#52+128+10
   1648  212a				  -	      else
   1649  212a				  -	      lda	#52+128+19
   1650  212a				  -	      endif
   1651  212a					      else
   1652  212a		       a9 b4		      lda	#52+128
   1653  212c					      endif
   1654  212c					      endif
   1655  212c
   1656  212c		       8d 96 02 	      sta	TIM64T
   1657  212f				  -	      ifconst	minikernel
   1658  212f				  -	      jsr	minikernel
   1659  212f					      endif
   1660  212f				  -	      ifconst	noscore
   1661  212f				  -	      pla
   1662  212f				  -	      pla
   1663  212f				  -	      jmp	skipscore
   1664  212f					      endif
   1665  212f
   1666  212f							; score pointers contain:
   1667  212f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1668  212f							; swap lo2->temp1
   1669  212f							; swap lo4->temp3
   1670  212f							; swap lo6->temp5
   1671  212f
   1672  212f		       a5 ca		      lda	scorepointers+5
   1673  2131		       85 cf		      sta	temp5
   1674  2133		       a5 c6		      lda	scorepointers+1
   1675  2135		       85 cb		      sta	temp1
   1676  2137		       a5 c8		      lda	scorepointers+3
   1677  2139		       85 cd		      sta	temp3
   1678  213b
   1679  213b		       a9 ff		      lda	#>scoretable
   1680  213d		       85 c6		      sta	scorepointers+1
   1681  213f		       85 c8		      sta	scorepointers+3
   1682  2141		       85 ca		      sta	scorepointers+5
   1683  2143		       85 cc		      sta	temp2
   1684  2145		       85 ce		      sta	temp4
   1685  2147		       85 d0		      sta	temp6
   1686  2149
   1687  2149		       60		      rts
   1688  214a
   1689  214a
   1690  214a
   1691  214a							;-------------------------------------------------------------------------
   1692  214a							;----------------------Kernel Routine-------------------------------------
   1693  214a							;-------------------------------------------------------------------------
   1694  214a
   1695  214a
   1696  214a							;-------------------------------------------------------------------------
   1697  214a							; repeat $f147-*
   1698  214a							; brk
   1699  214a							; repend
   1700  214a							;	org $F240
   1701  214a
   1702  214a				   SwitchDrawP0K1		;	72
   1703  214a		       a5 a4		      lda	P0Bottom
   1704  214c		       85 cf		      sta	P0Top	;+6	 2
   1705  214e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1706  2151
   1707  2151				   WaitDrawP0K1 		;	74
      0  2151					      SLEEP	4	;+4	 2
      1  2151				   .CYCLES    SET	4
      2  2151
      3  2151				  -	      IF	.CYCLES < 2
      4  2151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2151				  -	      ERR
      6  2151					      ENDIF
      7  2151
      8  2151				  -	      IF	.CYCLES & 1
      9  2151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2151				  -	      nop	0
     11  2151				  -	      ELSE
     12  2151				  -	      bit	VSYNC
     13  2151				  -	      ENDIF
     14  2151				  -.CYCLES    SET	.CYCLES - 3
     15  2151					      ENDIF
     16  2151
     17  2151					      REPEAT	.CYCLES / 2
     18  2151		       ea		      nop
     17  2151					      REPEND
     18  2152		       ea		      nop
     19  2153					      REPEND
   1709  2153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   1710  2156
   1711  2156				   SkipDrawP1K1 		;	11
   1712  2156		       a9 00		      lda	#0
   1713  2158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
   1714  215a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
   1715  215d
   1716  215d							;-------------------------------------------------------------------------
   1717  215d
   1718  215d				   KernelRoutine
   1719  215d					      ifnconst	screenheight
      0  215d					      sleep	12
      1  215d				   .CYCLES    SET	12
      2  215d
      3  215d				  -	      IF	.CYCLES < 2
      4  215d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215d				  -	      ERR
      6  215d					      ENDIF
      7  215d
      8  215d				  -	      IF	.CYCLES & 1
      9  215d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215d				  -	      nop	0
     11  215d				  -	      ELSE
     12  215d				  -	      bit	VSYNC
     13  215d				  -	      ENDIF
     14  215d				  -.CYCLES    SET	.CYCLES - 3
     15  215d					      ENDIF
     16  215d
     17  215d					      REPEAT	.CYCLES / 2
     18  215d		       ea		      nop
     17  215d					      REPEND
     18  215e		       ea		      nop
     17  215e					      REPEND
     18  215f		       ea		      nop
     17  215f					      REPEND
     18  2160		       ea		      nop
     17  2160					      REPEND
     18  2161		       ea		      nop
     17  2161					      REPEND
     18  2162		       ea		      nop
     19  2163					      REPEND
   1721  2163							; jsr wastetime ; waste 12 cycles
   1722  2163				  -	      else
   1723  2163				  -	      sleep	6
   1724  2163					      endif
   1725  2163		       ba		      tsx
   1726  2164		       86 f6		      stx	stack1
   1727  2166		       a2 1f		      ldx	#ENABL
   1728  2168		       9a		      txs		;+9	 9
   1729  2169
   1730  2169		       a2 00		      ldx	#0
   1731  216b		       a5 c4		      lda	pfheight
   1732  216d		       10 01		      bpl	asdhj
   1733  216f		       24		      .byte.b	$24
   1734  2170				   asdhj
   1735  2170		       aa		      tax
   1736  2171
   1737  2171							; ldx pfheight
   1738  2171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
   1739  2174
   1740  2174				  -	      ifconst	screenheight
   1741  2174				  -	      sec
   1742  2174				  -	      if	screenheight == 84
   1743  2174				  -	      sbc	pfsub+1,x
   1744  2174				  -	      else
   1745  2174				  -	      sbc	pfsub,x
   1746  2174				  -	      endif
   1747  2174					      endif
   1748  2174
   1749  2174		       85 ba		      sta	pfpixelheight
   1750  2176
   1751  2176				  -	      ifconst	screenheight
   1752  2176				  -	      ldy	#screenheight
   1753  2176					      else
   1754  2176		       a0 58		      ldy	#88
   1755  2178					      endif
   1756  2178
   1757  2178							;	lda #$02
   1758  2178							;	sta COLUBK		;+5	18
   1759  2178
   1760  2178							; sleep 25
      0  2178					      sleep	2
      1  2178				   .CYCLES    SET	2
      2  2178
      3  2178				  -	      IF	.CYCLES < 2
      4  2178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2178				  -	      ERR
      6  2178					      ENDIF
      7  2178
      8  2178				  -	      IF	.CYCLES & 1
      9  2178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2178				  -	      nop	0
     11  2178				  -	      ELSE
     12  2178				  -	      bit	VSYNC
     13  2178				  -	      ENDIF
     14  2178				  -.CYCLES    SET	.CYCLES - 3
     15  2178					      ENDIF
     16  2178
     17  2178					      REPEAT	.CYCLES / 2
     18  2178		       ea		      nop
     19  2179					      REPEND
   1762  2179				   KernelLoopa		;	50
      0  2179					      SLEEP	7	;+4	54
      1  2179				   .CYCLES    SET	7
      2  2179
      3  2179				  -	      IF	.CYCLES < 2
      4  2179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2179				  -	      ERR
      6  2179					      ENDIF
      7  2179
      8  2179					      IF	.CYCLES & 1
      9  2179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2179		       04 00		      nop	0
     11  217b				  -	      ELSE
     12  217b				  -	      bit	VSYNC
     13  217b					      ENDIF
     14  217b				   .CYCLES    SET	.CYCLES - 3
     15  217b					      ENDIF
     16  217b
     17  217b					      REPEAT	.CYCLES / 2
     18  217b		       ea		      nop
     17  217b					      REPEND
     18  217c		       ea		      nop
     19  217d					      REPEND
   1764  217d				   KernelLoopb		;	54
      0  217d					      SLEEP	2	;+12	66
      1  217d				   .CYCLES    SET	2
      2  217d
      3  217d				  -	      IF	.CYCLES < 2
      4  217d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217d				  -	      ERR
      6  217d					      ENDIF
      7  217d
      8  217d				  -	      IF	.CYCLES & 1
      9  217d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217d				  -	      nop	0
     11  217d				  -	      ELSE
     12  217d				  -	      bit	VSYNC
     13  217d				  -	      ENDIF
     14  217d				  -.CYCLES    SET	.CYCLES - 3
     15  217d					      ENDIF
     16  217d
     17  217d					      REPEAT	.CYCLES / 2
     18  217d		       ea		      nop
     19  217e					      REPEND
   1766  217e		       c4 cf		      cpy	P0Top	;+3	69
   1767  2180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
   1768  2182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
   1769  2184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
   1770  2186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
   1771  2188				   BackFromSwitchDrawP0K1
   1772  2188
   1773  2188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
   1774  218a							;		to a value greater than maximum Y value initially
   1775  218a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
   1776  218c		       b1 cc		      lda	(P1display),Y	;+5	15
   1777  218e		       8d 1c 00 	      sta.w	GRP1	;+4	19
   1778  2191				   BackFromSkipDrawP1
   1779  2191
   1780  2191							;fuck	
   1781  2191		       84 cb		      sty	temp1
   1782  2193		       a4 ba		      ldy	pfpixelheight
   1783  2195		       b3 bb		      lax	(PF1pointer),y
   1784  2197		       86 0e		      stx	PF1	;+7	26
   1785  2199		       b1 bd		      lda	(PF2pointer),y
   1786  219b		       85 0f		      sta	PF2	;+7	33
   1787  219d							;sleep 6
   1788  219d		       86 b7		      stx	PF1temp2
   1789  219f		       85 b9		      sta	PF2temp2
   1790  21a1		       88		      dey
   1791  21a2		       30 35		      bmi	pagewraphandler
   1792  21a4		       b1 bb		      lda	(PF1pointer),y
   1793  21a6				   cyclebalance
   1794  21a6		       85 b6		      sta	PF1temp1
   1795  21a8		       b1 bd		      lda	(PF2pointer),y
   1796  21aa		       85 b8		      sta	PF2temp1
   1797  21ac		       a4 cb		      ldy	temp1
   1798  21ae
   1799  21ae		       a2 1f		      ldx	#ENABL
   1800  21b0		       9a		      txs
   1801  21b1		       c4 8c		      cpy	bally
   1802  21b3		       08		      php		;+6	39	VDEL ball
   1803  21b4
   1804  21b4
   1805  21b4		       c4 8b		      cpy	missile1y
   1806  21b6		       08		      php		;+6	71
   1807  21b7
   1808  21b7		       c4 8a		      cpy	missile0y
   1809  21b9		       08		      php		;+6	 1
   1810  21ba
   1811  21ba
   1812  21ba		       88		      dey		;+2	15
   1813  21bb
   1814  21bb		       c4 ce		      cpy	RepoLine	;+3	18
   1815  21bd		       f0 62		      beq	RepoKernel	;+2	20
   1816  21bf							;	SLEEP 20		;+23	43
      0  21bf					      sleep	6
      1  21bf				   .CYCLES    SET	6
      2  21bf
      3  21bf				  -	      IF	.CYCLES < 2
      4  21bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21bf				  -	      ERR
      6  21bf					      ENDIF
      7  21bf
      8  21bf				  -	      IF	.CYCLES & 1
      9  21bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21bf				  -	      nop	0
     11  21bf				  -	      ELSE
     12  21bf				  -	      bit	VSYNC
     13  21bf				  -	      ENDIF
     14  21bf				  -.CYCLES    SET	.CYCLES - 3
     15  21bf					      ENDIF
     16  21bf
     17  21bf					      REPEAT	.CYCLES / 2
     18  21bf		       ea		      nop
     17  21bf					      REPEND
     18  21c0		       ea		      nop
     17  21c0					      REPEND
     18  21c1		       ea		      nop
     19  21c2					      REPEND
   1818  21c2
   1819  21c2				   newrepo		; since we have time here, store next repoline
   1820  21c2		       a6 83		      ldx	SpriteIndex
   1821  21c4		       b5 9c		      lda	SpriteGfxIndex-1,x
   1822  21c6		       aa		      tax
   1823  21c7		       b5 8e		      lda	NewSpriteY,x
   1824  21c9		       85 d0		      sta	temp6
      0  21cb					      sleep	4
      1  21cb				   .CYCLES    SET	4
      2  21cb
      3  21cb				  -	      IF	.CYCLES < 2
      4  21cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21cb				  -	      ERR
      6  21cb					      ENDIF
      7  21cb
      8  21cb				  -	      IF	.CYCLES & 1
      9  21cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21cb				  -	      nop	0
     11  21cb				  -	      ELSE
     12  21cb				  -	      bit	VSYNC
     13  21cb				  -	      ENDIF
     14  21cb				  -.CYCLES    SET	.CYCLES - 3
     15  21cb					      ENDIF
     16  21cb
     17  21cb					      REPEAT	.CYCLES / 2
     18  21cb		       ea		      nop
     17  21cb					      REPEND
     18  21cc		       ea		      nop
     19  21cd					      REPEND
   1826  21cd
   1827  21cd				   BackFromRepoKernel
   1828  21cd		       98		      tya		;+2	45
   1829  21ce		       25 c4		      and	pfheight	;+2	47
   1830  21d0		       d0 a7		      bne	KernelLoopa	;+2	49
   1831  21d2		       c6 ba		      dec	pfpixelheight
   1832  21d4		       10 a7		      bpl	KernelLoopb	;+3	54
   1833  21d6							;	bmi donewkernel		;+3	54
   1834  21d6							;	bne KernelLoopb+1		;+3	54
   1835  21d6
   1836  21d6				   donewkernel
   1837  21d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
   1838  21d9
   1839  21d9				   pagewraphandler
   1840  21d9		       4c a6 f1 	      jmp	cyclebalance
   1841  21dc
   1842  21dc							;-------------------------------------------------------------------------
   1843  21dc
   1844  21dc							; room here for score?
   1845  21dc
   1846  21dc				   setscorepointers
   1847  21dc		       a7 d4		      lax	score+2
   1848  21de		       20 f8 f1 	      jsr	scorepointerset
   1849  21e1		       84 ca		      sty	scorepointers+5
   1850  21e3		       86 c7		      stx	scorepointers+2
   1851  21e5		       a7 d3		      lax	score+1
   1852  21e7		       20 f8 f1 	      jsr	scorepointerset
   1853  21ea		       84 c9		      sty	scorepointers+4
   1854  21ec		       86 c6		      stx	scorepointers+1
   1855  21ee		       a7 d2		      lax	score
   1856  21f0		       20 f8 f1 	      jsr	scorepointerset
   1857  21f3		       84 c8		      sty	scorepointers+3
   1858  21f5		       86 c5		      stx	scorepointers
   1859  21f7				   wastetime
   1860  21f7		       60		      rts
   1861  21f8
   1862  21f8				   scorepointerset
   1863  21f8		       29 0f		      and	#$0F
   1864  21fa		       0a		      asl
   1865  21fb		       0a		      asl
   1866  21fc		       0a		      asl
   1867  21fd		       69 74		      adc	#<scoretable
   1868  21ff		       a8		      tay
   1869  2200		       8a		      txa
   1870  2201		       29 f0		      and	#$F0
   1871  2203		       4a		      lsr
   1872  2204		       69 74		      adc	#<scoretable
   1873  2206		       aa		      tax
   1874  2207		       60		      rts
   1875  2208							;	align 256
   1876  2208
   1877  2208				   SwitchDrawP0KR		;	45
   1878  2208		       a5 a4		      lda	P0Bottom
   1879  220a		       85 cf		      sta	P0Top	;+6	51
   1880  220c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1881  220f
   1882  220f				   WaitDrawP0KR 		;	47
      0  220f					      SLEEP	4	;+4	51
      1  220f				   .CYCLES    SET	4
      2  220f
      3  220f				  -	      IF	.CYCLES < 2
      4  220f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  220f				  -	      ERR
      6  220f					      ENDIF
      7  220f
      8  220f				  -	      IF	.CYCLES & 1
      9  220f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  220f				  -	      nop	0
     11  220f				  -	      ELSE
     12  220f				  -	      bit	VSYNC
     13  220f				  -	      ENDIF
     14  220f				  -.CYCLES    SET	.CYCLES - 3
     15  220f					      ENDIF
     16  220f
     17  220f					      REPEAT	.CYCLES / 2
     18  220f		       ea		      nop
     17  220f					      REPEND
     18  2210		       ea		      nop
     19  2211					      REPEND
   1884  2211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   1885  2214
   1886  2214							;-----------------------------------------------------------
   1887  2214
   1888  2214				   noUpdateXKR
   1889  2214		       a2 01		      ldx	#1
   1890  2216		       cc cf 00 	      cpy.w	P0Top
   1891  2219		       4c 2b f2 	      JMP	retXKR
   1892  221c
   1893  221c				   skipthis
   1894  221c		       a2 01		      ldx	#1
   1895  221e		       4c 6d f2 	      jmp	goback
   1896  2221
   1897  2221				   RepoKernel		;	22	crosses page boundary
   1898  2221		       98		      tya
   1899  2222		       25 c4		      and	pfheight	;+2	26
   1900  2224		       d0 ee		      bne	noUpdateXKR	;+2	28
   1901  2226		       aa		      tax
   1902  2227							;	dex			;+2	30
   1903  2227		       c6 ba		      dec	pfpixelheight
   1904  2229							;	stx Temp		;+3	35
   1905  2229							;	SLEEP 3
   1906  2229
   1907  2229		       c4 cf		      cpy	P0Top	;+3	42
   1908  222b				   retXKR
   1909  222b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
   1910  222d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
   1911  222f		       b1 a2		      lda	(player0pointer),Y	;+5	51
   1912  2231		       85 1b		      sta	GRP0	;+3	54	VDEL
   1913  2233				   BackFromSwitchDrawP0KR
   1914  2233		       38		      sec		;+2	56
   1915  2234
   1916  2234
   1917  2234
   1918  2234		       b5 b8		      lda	PF2temp1,X
   1919  2236		       b4 b6		      ldy	PF1temp1,X
   1920  2238
   1921  2238		       a6 83		      ldx	SpriteIndex	;+3	 2
   1922  223a
   1923  223a		       85 0f		      sta	PF2	;+7	63
   1924  223c
   1925  223c		       b5 9d		      lda	SpriteGfxIndex,x
   1926  223e		       84 0e		      sty	PF1	;+7	70	too early?
   1927  2240		       aa		      tax
   1928  2241		       a9 00		      lda	#0
   1929  2243		       85 1c		      sta	GRP1	;+5	75	to display player 0
   1930  2245		       b5 85		      lda	NewSpriteX,X	;+4	 6
   1931  2247
   1932  2247				   DivideBy15LoopK		;	 6	(carry set above)
   1933  2247		       e9 0f		      sbc	#15
   1934  2249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
   1935  224b
   1936  224b		       aa		      tax		;+2	12/17/...62
   1937  224c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
   1938  224f
   1939  224f		       85 21		      sta	HMP1	;+3	20/25/...70
   1940  2251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
   1941  2253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   1942  2255							;sta HMOVE			;+3	 3
   1943  2255
   1944  2255		       a2 1f		      ldx	#ENABL
   1945  2257		       9a		      txs		;+4	25
   1946  2258		       a4 ce		      ldy	RepoLine	; restore y
   1947  225a		       c4 8c		      cpy	bally
   1948  225c		       08		      php		;+6	 9	VDEL ball
   1949  225d
   1950  225d		       c4 8b		      cpy	missile1y
   1951  225f		       08		      php		;+6	15
   1952  2260
   1953  2260		       c4 8a		      cpy	missile0y
   1954  2262		       08		      php		;+6	21
   1955  2263
   1956  2263
   1957  2263
   1958  2263
   1959  2263
   1960  2263							;15 cycles
   1961  2263		       98		      tya
   1962  2264		       25 c4		      and	pfheight
   1963  2266							;eor #1
   1964  2266		       29 fe		      and	#$FE
   1965  2268		       d0 b2		      bne	skipthis
   1966  226a		       aa		      tax
      0  226b					      sleep	4
      1  226b				   .CYCLES    SET	4
      2  226b
      3  226b				  -	      IF	.CYCLES < 2
      4  226b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  226b				  -	      ERR
      6  226b					      ENDIF
      7  226b
      8  226b				  -	      IF	.CYCLES & 1
      9  226b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  226b				  -	      nop	0
     11  226b				  -	      ELSE
     12  226b				  -	      bit	VSYNC
     13  226b				  -	      ENDIF
     14  226b				  -.CYCLES    SET	.CYCLES - 3
     15  226b					      ENDIF
     16  226b
     17  226b					      REPEAT	.CYCLES / 2
     18  226b		       ea		      nop
     17  226b					      REPEND
     18  226c		       ea		      nop
     19  226d					      REPEND
   1968  226d							;	sleep 2
   1969  226d				   goback
   1970  226d
   1971  226d		       88		      dey
   1972  226e		       c4 cf		      cpy	P0Top	;+3	52
   1973  2270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
   1974  2272		       10 67		      bpl	WaitDrawP0KV	;+2	56
   1975  2274		       b1 a2		      lda	(player0pointer),Y	;+5	61
   1976  2276		       85 1b		      sta	GRP0	;+3	64	VDEL
   1977  2278				   BackFromSwitchDrawP0KV
   1978  2278
   1979  2278							; sleep 3
   1980  2278
   1981  2278		       b5 b8		      lda	PF2temp1,X
   1982  227a		       85 0f		      sta	PF2	;+7	 5
   1983  227c		       b5 b6		      lda	PF1temp1,X
   1984  227e		       85 0e		      sta	PF1	;+7	74 
   1985  2280		       85 2a		      sta	HMOVE
   1986  2282
   1987  2282		       a9 00		      lda	#0
   1988  2284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
   1989  2286
   1990  2286		       a2 1f		      ldx	#ENABL
   1991  2288		       9a		      txs		;+4	 8
   1992  2289
   1993  2289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
   1994  228b							;--now, set all new variables and return to main kernel loop
   1995  228b
   1996  228b
   1997  228b							;
   1998  228b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
   1999  228d		       aa		      tax		;+2	33
   2000  228e							;
   2001  228e
   2002  228e
   2003  228e
   2004  228e		       b5 93		      lda	NewNUSIZ,X
   2005  2290		       85 05		      sta	NUSIZ1	;+7	20
   2006  2292		       85 0c		      sta	REFP1
   2007  2294		       b5 98		      lda	NewCOLUP1,X
   2008  2296		       85 07		      sta	COLUP1	;+7	27
   2009  2298
   2010  2298							;	lda SpriteGfxIndex,X	;+4	31
   2011  2298							;	tax				;+2	33
   2012  2298							;fuck2
   2013  2298		       b5 8e		      lda	NewSpriteY,X	;+4	46
   2014  229a		       38		      sec		;+2	38
   2015  229b		       f5 b1		      sbc	spriteheight,X	;+4	42
   2016  229d		       85 a5		      sta	P1Bottom	;+3	45
   2017  229f
      0  229f					      sleep	6
      1  229f				   .CYCLES    SET	6
      2  229f
      3  229f				  -	      IF	.CYCLES < 2
      4  229f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  229f				  -	      ERR
      6  229f					      ENDIF
      7  229f
      8  229f				  -	      IF	.CYCLES & 1
      9  229f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  229f				  -	      nop	0
     11  229f				  -	      ELSE
     12  229f				  -	      bit	VSYNC
     13  229f				  -	      ENDIF
     14  229f				  -.CYCLES    SET	.CYCLES - 3
     15  229f					      ENDIF
     16  229f
     17  229f					      REPEAT	.CYCLES / 2
     18  229f		       ea		      nop
     17  229f					      REPEND
     18  22a0		       ea		      nop
     17  22a0					      REPEND
     18  22a1		       ea		      nop
     19  22a2					      REPEND
   2019  22a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
   2020  22a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
   2021  22a6		       85 cc		      sta	P1display	;+3	55
   2022  22a8		       b5 ab		      lda	player1pointerhi,X
   2023  22aa		       85 cd		      sta	P1display+1	;+7	62
   2024  22ac
   2025  22ac
   2026  22ac		       c4 8c		      cpy	bally
   2027  22ae		       08		      php		;+6	68	VDELed
   2028  22af
   2029  22af		       c4 8b		      cpy	missile1y
   2030  22b1		       08		      php		;+6	74
   2031  22b2
   2032  22b2		       c4 8a		      cpy	missile0y
   2033  22b4		       08		      php		;+6	 4
   2034  22b5
   2035  22b5
   2036  22b5
   2037  22b5							; lda SpriteGfxIndex-1,x
   2038  22b5							; sleep 3
   2039  22b5		       c6 83		      dec	SpriteIndex	;+5	13
   2040  22b7							; tax
   2041  22b7							; lda NewSpriteY,x
   2042  22b7							; sta RepoLine
   2043  22b7
   2044  22b7							; 10 cycles below...
   2045  22b7		       10 05		      bpl	SetNextLine
   2046  22b9		       a9 ff		      lda	#255
   2047  22bb		       4c c1 f2 	      jmp	SetLastLine
   2048  22be				   SetNextLine
   2049  22be							;	lda NewSpriteY-1,x
   2050  22be		       ad d0 00 	      lda.w	temp6
   2051  22c1				   SetLastLine
   2052  22c1		       85 ce		      sta	RepoLine
   2053  22c3
   2054  22c3		       98		      tya
   2055  22c4		       25 c4		      and	pfheight
   2056  22c6		       d0 06		      bne	nodec
   2057  22c8		       c6 ba		      dec	pfpixelheight
   2058  22ca		       88		      dey		;+2	30
   2059  22cb
   2060  22cb							; 10 cycles 
   2061  22cb
   2062  22cb
   2063  22cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
   2064  22ce
   2065  22ce				   nodec
      0  22ce					      sleep	4
      1  22ce				   .CYCLES    SET	4
      2  22ce
      3  22ce				  -	      IF	.CYCLES < 2
      4  22ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22ce				  -	      ERR
      6  22ce					      ENDIF
      7  22ce
      8  22ce				  -	      IF	.CYCLES & 1
      9  22ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22ce				  -	      nop	0
     11  22ce				  -	      ELSE
     12  22ce				  -	      bit	VSYNC
     13  22ce				  -	      ENDIF
     14  22ce				  -.CYCLES    SET	.CYCLES - 3
     15  22ce					      ENDIF
     16  22ce
     17  22ce					      REPEAT	.CYCLES / 2
     18  22ce		       ea		      nop
     17  22ce					      REPEND
     18  22cf		       ea		      nop
     19  22d0					      REPEND
   2067  22d0		       88		      dey
   2068  22d1		       4c cd f1 	      jmp	BackFromRepoKernel
   2069  22d4
   2070  22d4							;-------------------------------------------------------------------------
   2071  22d4
   2072  22d4
   2073  22d4				   SwitchDrawP0KV		;	69
   2074  22d4		       a5 a4		      lda	P0Bottom
   2075  22d6		       85 cf		      sta	P0Top	;+6	75
   2076  22d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2077  22db
   2078  22db				   WaitDrawP0KV 		;	71
      0  22db					      SLEEP	4	;+4	75
      1  22db				   .CYCLES    SET	4
      2  22db
      3  22db				  -	      IF	.CYCLES < 2
      4  22db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22db				  -	      ERR
      6  22db					      ENDIF
      7  22db
      8  22db				  -	      IF	.CYCLES & 1
      9  22db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22db				  -	      nop	0
     11  22db				  -	      ELSE
     12  22db				  -	      bit	VSYNC
     13  22db				  -	      ENDIF
     14  22db				  -.CYCLES    SET	.CYCLES - 3
     15  22db					      ENDIF
     16  22db
     17  22db					      REPEAT	.CYCLES / 2
     18  22db		       ea		      nop
     17  22db					      REPEND
     18  22dc		       ea		      nop
     19  22dd					      REPEND
   2080  22dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   2081  22e0
   2082  22e0							;-------------------------------------------------------------------------
   2083  22e0
   2084  22e0				   DoneWithKernel
   2085  22e0
   2086  22e0				   BottomOfKernelLoop
   2087  22e0
   2088  22e0		       85 02		      sta	WSYNC
   2089  22e2		       a6 f6		      ldx	stack1
   2090  22e4		       9a		      txs
   2091  22e5		       20 04 f1 	      jsr	sixdigscore	; set up score
   2092  22e8
   2093  22e8
   2094  22e8		       85 02		      sta	WSYNC
   2095  22ea		       a2 00		      ldx	#0
   2096  22ec		       85 2b		      sta	HMCLR
   2097  22ee		       86 1b		      STx	GRP0
   2098  22f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2099  22f2
   2100  22f2		       a0 07		      LDY	#7
   2101  22f4		       84 25		      STy	VDELP0
   2102  22f6		       84 26		      STy	VDELP1
   2103  22f8		       a9 10		      LDA	#$10
   2104  22fa		       85 21		      STA	HMP1
   2105  22fc		       a5 d5		      LDA	scorecolor
   2106  22fe		       85 06		      STA	COLUP0
   2107  2300		       85 07		      STA	COLUP1
   2108  2302
   2109  2302		       a9 03		      LDA	#$03
   2110  2304		       85 04		      STA	NUSIZ0
   2111  2306		       85 05		      STA	NUSIZ1
   2112  2308
   2113  2308		       85 10		      STA	RESP0
   2114  230a		       85 11		      STA	RESP1
   2115  230c
      0  230c					      sleep	9
      1  230c				   .CYCLES    SET	9
      2  230c
      3  230c				  -	      IF	.CYCLES < 2
      4  230c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  230c				  -	      ERR
      6  230c					      ENDIF
      7  230c
      8  230c					      IF	.CYCLES & 1
      9  230c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  230c		       04 00		      nop	0
     11  230e				  -	      ELSE
     12  230e				  -	      bit	VSYNC
     13  230e					      ENDIF
     14  230e				   .CYCLES    SET	.CYCLES - 3
     15  230e					      ENDIF
     16  230e
     17  230e					      REPEAT	.CYCLES / 2
     18  230e		       ea		      nop
     17  230e					      REPEND
     18  230f		       ea		      nop
     17  230f					      REPEND
     18  2310		       ea		      nop
     19  2311					      REPEND
   2117  2311		       b1 c5		      lda	(scorepointers),y
   2118  2313		       85 1b		      sta	GRP0
   2119  2315				  -	      ifconst	pfscore
   2120  2315				  -	      lda	pfscorecolor
   2121  2315				  -	      sta	COLUPF
   2122  2315					      else
      0  2315					      sleep	6
      1  2315				   .CYCLES    SET	6
      2  2315
      3  2315				  -	      IF	.CYCLES < 2
      4  2315				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2315				  -	      ERR
      6  2315					      ENDIF
      7  2315
      8  2315				  -	      IF	.CYCLES & 1
      9  2315				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2315				  -	      nop	0
     11  2315				  -	      ELSE
     12  2315				  -	      bit	VSYNC
     13  2315				  -	      ENDIF
     14  2315				  -.CYCLES    SET	.CYCLES - 3
     15  2315					      ENDIF
     16  2315
     17  2315					      REPEAT	.CYCLES / 2
     18  2315		       ea		      nop
     17  2315					      REPEND
     18  2316		       ea		      nop
     17  2316					      REPEND
     18  2317		       ea		      nop
     19  2318					      REPEND
   2124  2318					      endif
   2125  2318
   2126  2318		       85 2a		      STA	HMOVE
   2127  231a		       b1 cd		      lda	(scorepointers+8),y
   2128  231c							; sta WSYNC
   2129  231c							;sleep 2
   2130  231c		       4c 29 f3 	      jmp	beginscore
   2131  231f
   2132  231f
   2133  231f				   loop2
   2134  231f		       b1 c5		      lda	(scorepointers),y	;+5  68  204
   2135  2321		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
   2136  2323				  -	      ifconst	pfscore
   2137  2323				  -	      lda.w	pfscore1
   2138  2323				  -	      sta	PF1
   2139  2323					      else
      0  2323					      sleep	7
      1  2323				   .CYCLES    SET	7
      2  2323
      3  2323				  -	      IF	.CYCLES < 2
      4  2323				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2323				  -	      ERR
      6  2323					      ENDIF
      7  2323
      8  2323					      IF	.CYCLES & 1
      9  2323					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2323		       04 00		      nop	0
     11  2325				  -	      ELSE
     12  2325				  -	      bit	VSYNC
     13  2325					      ENDIF
     14  2325				   .CYCLES    SET	.CYCLES - 3
     15  2325					      ENDIF
     16  2325
     17  2325					      REPEAT	.CYCLES / 2
     18  2325		       ea		      nop
     17  2325					      REPEND
     18  2326		       ea		      nop
     19  2327					      REPEND
   2141  2327					      endif
   2142  2327							; cycle 0
   2143  2327		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
   2144  2329				   beginscore
   2145  2329		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
   2146  232b		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
   2147  232d		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
   2148  232f		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
   2149  2331		       9a		      txs
   2150  2332		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  2334					      sleep	3
      1  2334				   .CYCLES    SET	3
      2  2334
      3  2334				  -	      IF	.CYCLES < 2
      4  2334				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2334				  -	      ERR
      6  2334					      ENDIF
      7  2334
      8  2334					      IF	.CYCLES & 1
      9  2334					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2334		       04 00		      nop	0
     11  2336				  -	      ELSE
     12  2336				  -	      bit	VSYNC
     13  2336					      ENDIF
     14  2336				   .CYCLES    SET	.CYCLES - 3
     15  2336					      ENDIF
     16  2336
     17  2336				  -	      REPEAT	.CYCLES / 2
     18  2336				  -	      nop
     19  2336					      REPEND
   2152  2336				  -	      ifconst	pfscore
   2153  2336				  -	      lda	pfscore2
   2154  2336				  -	      sta	PF1
   2155  2336					      else
      0  2336					      sleep	6
      1  2336				   .CYCLES    SET	6
      2  2336
      3  2336				  -	      IF	.CYCLES < 2
      4  2336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2336				  -	      ERR
      6  2336					      ENDIF
      7  2336
      8  2336				  -	      IF	.CYCLES & 1
      9  2336				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2336				  -	      nop	0
     11  2336				  -	      ELSE
     12  2336				  -	      bit	VSYNC
     13  2336				  -	      ENDIF
     14  2336				  -.CYCLES    SET	.CYCLES - 3
     15  2336					      ENDIF
     16  2336
     17  2336					      REPEAT	.CYCLES / 2
     18  2336		       ea		      nop
     17  2336					      REPEND
     18  2337		       ea		      nop
     17  2337					      REPEND
     18  2338		       ea		      nop
     19  2339					      REPEND
   2157  2339					      endif
   2158  2339		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
   2159  233b		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
   2160  233d		       ba		      tsx
   2161  233e		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
   2162  2340		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
   2163  2342		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
   2164  2344		       88		      dey
   2165  2345		       10 d8		      bpl	loop2	;+2  60  180
   2166  2347		       a6 f6		      ldx	stack1
   2167  2349		       9a		      txs
   2168  234a
   2169  234a
   2170  234a							; lda scorepointers+1
   2171  234a		       a4 cb		      ldy	temp1
   2172  234c							; sta temp1
   2173  234c		       84 c6		      sty	scorepointers+1
   2174  234e
   2175  234e		       a9 00		      LDA	#0
   2176  2350		       85 1b		      STA	GRP0
   2177  2352		       85 1c		      STA	GRP1
   2178  2354		       85 0e		      sta	PF1
   2179  2356		       85 25		      STA	VDELP0
   2180  2358		       85 26		      STA	VDELP1	;do we need these
   2181  235a		       85 04		      STA	NUSIZ0
   2182  235c		       85 05		      STA	NUSIZ1
   2183  235e
   2184  235e							; lda scorepointers+3
   2185  235e		       a4 cd		      ldy	temp3
   2186  2360							; sta temp3
   2187  2360		       84 c8		      sty	scorepointers+3
   2188  2362
   2189  2362							; lda scorepointers+5
   2190  2362		       a4 cf		      ldy	temp5
   2191  2364							; sta temp5
   2192  2364		       84 ca		      sty	scorepointers+5
   2193  2366
   2194  2366
   2195  2366							;-------------------------------------------------------------------------
   2196  2366							;------------------------Overscan Routine---------------------------------
   2197  2366							;-------------------------------------------------------------------------
   2198  2366
   2199  2366				   OverscanRoutine
   2200  2366
   2201  2366
   2202  2366
   2203  2366				   skipscore
   2204  2366		       a9 02		      lda	#2
   2205  2368		       85 02		      sta	WSYNC
   2206  236a		       85 01		      sta	VBLANK	;turn on VBLANK
   2207  236c
   2208  236c
   2209  236c
   2210  236c
   2211  236c
   2212  236c							;-------------------------------------------------------------------------
   2213  236c							;----------------------------End Main Routines----------------------------
   2214  236c							;-------------------------------------------------------------------------
   2215  236c
   2216  236c
   2217  236c							;*************************************************************************
   2218  236c
   2219  236c							;-------------------------------------------------------------------------
   2220  236c							;----------------------Begin Subroutines----------------------------------
   2221  236c							;-------------------------------------------------------------------------
   2222  236c
   2223  236c
   2224  236c
   2225  236c
   2226  236c				   KernelCleanupSubroutine
   2227  236c
   2228  236c		       a2 04		      ldx	#4
   2229  236e				   AdjustYValuesDownLoop
   2230  236e		       b5 8e		      lda	NewSpriteY,X
   2231  2370		       38		      sec
   2232  2371		       e9 02		      sbc	#2
   2233  2373		       95 8e		      sta	NewSpriteY,X
   2234  2375		       ca		      dex
   2235  2376		       10 f6		      bpl	AdjustYValuesDownLoop
   2236  2378
   2237  2378
      0  2378					      RETURN
      1  2378				  -	      ifnconst	bankswitch
      2  2378				  -	      rts
      3  2378					      else
      4  2378		       4c dd ff 	      jmp	BS_return
      5  237b					      endif
   2239  237b							;rts
   2240  237b
   2241  237b				   SetupP1Subroutine
   2242  237b							; flickersort algorithm
   2243  237b							; count 4-0
   2244  237b							; table2=table1 (?)
   2245  237b							; detect overlap of sprites in table 2
   2246  237b							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
   2247  237b							; if no overlap, do regular sort in table 2 and table 1
   2248  237b				   fsstart
   2249  237b		       a2 ff		      ldx	#255
   2250  237d				   copytable
   2251  237d		       e8		      inx
   2252  237e		       b5 f1		      lda	spritesort,x
   2253  2380		       95 9d		      sta	SpriteGfxIndex,x
   2254  2382		       e0 04		      cpx	#4
   2255  2384		       d0 f7		      bne	copytable
   2256  2386
   2257  2386		       86 cd		      stx	temp3	; highest displayed sprite
   2258  2388		       ca		      dex
   2259  2389		       86 cc		      stx	temp2
   2260  238b				   sortloop
   2261  238b		       a6 cc		      ldx	temp2
   2262  238d		       b5 f1		      lda	spritesort,x
   2263  238f		       aa		      tax
   2264  2390		       b5 8e		      lda	NewSpriteY,x
   2265  2392		       85 cb		      sta	temp1
   2266  2394
   2267  2394		       a6 cc		      ldx	temp2
   2268  2396		       b5 f2		      lda	spritesort+1,x
   2269  2398		       aa		      tax
   2270  2399		       b5 8e		      lda	NewSpriteY,x
   2271  239b		       38		      sec
   2272  239c		       18		      clc
   2273  239d		       e5 cb		      sbc	temp1
   2274  239f		       90 0e		      bcc	largerXislower
   2275  23a1
   2276  23a1							; larger x is higher (A>=temp1)
   2277  23a1		       d5 b1		      cmp	spriteheight,x
   2278  23a3		       b0 2f		      bcs	countdown
   2279  23a5							; overlap with x+1>x
   2280  23a5							; 
   2281  23a5							; stick x at end of gfxtable, dec counter
   2282  23a5				   overlapping
   2283  23a5		       c6 cd		      dec	temp3
   2284  23a7		       a6 cc		      ldx	temp2
   2285  23a9							; inx
   2286  23a9		       20 e8 f3 	      jsr	shiftnumbers
   2287  23ac		       4c ca f3 	      jmp	skipswapGfxtable
   2288  23af
   2289  23af				   largerXislower		; (temp1>A)
   2290  23af		       a8		      tay
   2291  23b0		       a6 cc		      ldx	temp2
   2292  23b2		       b5 f1		      lda	spritesort,x
   2293  23b4		       aa		      tax
   2294  23b5		       98		      tya
   2295  23b6		       49 ff		      eor	#$FF
   2296  23b8		       e9 01		      sbc	#1
   2297  23ba		       90 e9		      bcc	overlapping
   2298  23bc		       d5 b1		      cmp	spriteheight,x
   2299  23be		       b0 0a		      bcs	notoverlapping
   2300  23c0
   2301  23c0		       c6 cd		      dec	temp3
   2302  23c2		       a6 cc		      ldx	temp2
   2303  23c4							; inx
   2304  23c4		       20 e8 f3 	      jsr	shiftnumbers
   2305  23c7		       4c ca f3 	      jmp	skipswapGfxtable
   2306  23ca				   notoverlapping
   2307  23ca							; ldx temp2 ; swap display table
   2308  23ca							; ldy SpriteGfxIndex+1,x
   2309  23ca							; lda SpriteGfxIndex,x
   2310  23ca							; sty SpriteGfxIndex,x
   2311  23ca							; sta SpriteGfxIndex+1,x 
   2312  23ca
   2313  23ca				   skipswapGfxtable
   2314  23ca		       a6 cc		      ldx	temp2	; swap sort table
   2315  23cc		       b4 f2		      ldy	spritesort+1,x
   2316  23ce		       b5 f1		      lda	spritesort,x
   2317  23d0		       94 f1		      sty	spritesort,x
   2318  23d2		       95 f2		      sta	spritesort+1,x
   2319  23d4
   2320  23d4				   countdown
   2321  23d4		       c6 cc		      dec	temp2
   2322  23d6		       10 b3		      bpl	sortloop
   2323  23d8
   2324  23d8				   checktoohigh
   2325  23d8		       a6 cd		      ldx	temp3
   2326  23da		       b5 9d		      lda	SpriteGfxIndex,x
   2327  23dc		       aa		      tax
   2328  23dd		       b5 8e		      lda	NewSpriteY,x
   2329  23df				  -	      ifconst	screenheight
   2330  23df				  -	      cmp	#screenheight-3
   2331  23df					      else
   2332  23df		       c9 55		      cmp	#$55
   2333  23e1					      endif
   2334  23e1		       90 04		      bcc	nonetoohigh
   2335  23e3		       c6 cd		      dec	temp3
   2336  23e5		       d0 f1		      bne	checktoohigh
   2337  23e7
   2338  23e7				   nonetoohigh
   2339  23e7		       60		      rts
   2340  23e8
   2341  23e8
   2342  23e8				   shiftnumbers
   2343  23e8							; stick current x at end, shift others down
   2344  23e8							; if x=4: don't do anything
   2345  23e8							; if x=3: swap 3 and 4
   2346  23e8							; if x=2: 2=3, 3=4, 4=2
   2347  23e8							; if x=1: 1=2, 2=3, 3=4, 4=1
   2348  23e8							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   2349  23e8							; ldy SpriteGfxIndex,x
   2350  23e8				   swaploop
   2351  23e8		       e0 04		      cpx	#4
   2352  23ea		       f0 08		      beq	shiftdone
   2353  23ec		       b5 9e		      lda	SpriteGfxIndex+1,x
   2354  23ee		       95 9d		      sta	SpriteGfxIndex,x
   2355  23f0		       e8		      inx
   2356  23f1		       4c e8 f3 	      jmp	swaploop
   2357  23f4				   shiftdone
   2358  23f4							; sty SpriteGfxIndex,x
   2359  23f4		       60		      rts
   2360  23f5
   2361  23f5				  -	      ifconst	debugscore
   2362  23f5				  -debugcycles
   2363  23f5				  -	      ldx	#14
   2364  23f5				  -	      lda	INTIM	; display # cycles left in the score
   2365  23f5				  -
   2366  23f5				  -	      ifconst	mincycles
   2367  23f5				  -	      lda	mincycles
   2368  23f5				  -	      cmp	INTIM
   2369  23f5				  -	      lda	mincycles
   2370  23f5				  -	      bcc	nochange
   2371  23f5				  -	      lda	INTIM
   2372  23f5				  -	      sta	mincycles
   2373  23f5				  -nochange
   2374  23f5				  -	      endif
   2375  23f5				  -
   2376  23f5				  -			;   cmp #$2B
   2377  23f5				  -			;   bcs no_cycles_left
   2378  23f5				  -	      bmi	cycles_left
   2379  23f5				  -	      ldx	#64
   2380  23f5				  -	      eor	#$ff	;make negative
   2381  23f5				  -cycles_left
   2382  23f5				  -	      stx	scorecolor
   2383  23f5				  -	      and	#$7f	; clear sign bit
   2384  23f5				  -	      tax
   2385  23f5				  -	      lda	scorebcd,x
   2386  23f5				  -	      sta	score+2
   2387  23f5				  -	      lda	scorebcd1,x
   2388  23f5				  -	      sta	score+1
   2389  23f5				  -	      rts
   2390  23f5				  -scorebcd
   2391  23f5				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2392  23f5				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2393  23f5				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2394  23f5				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2395  23f5				  -scorebcd1
   2396  23f5				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2397  23f5				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2398  23f5				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2399  23f5				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2400  23f5					      endif
   2401  23f5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2402  23f5
   2403  23f5				   start
   2404  23f5		       78		      sei
   2405  23f6		       d8		      cld
   2406  23f7		       a0 00		      ldy	#0
   2407  23f9		       a5 d0		      lda	$D0
   2408  23fb		       c9 2c		      cmp	#$2C	;check RAM location #1
   2409  23fd		       d0 07		      bne	MachineIs2600
   2410  23ff		       a5 d1		      lda	$D1
   2411  2401		       c9 a9		      cmp	#$A9	;check RAM location #2
   2412  2403		       d0 01		      bne	MachineIs2600
   2413  2405		       88		      dey
   2414  2406				   MachineIs2600
   2415  2406		       a2 00		      ldx	#0
   2416  2408		       8a		      txa
   2417  2409				   clearmem
   2418  2409		       e8		      inx
   2419  240a		       9a		      txs
   2420  240b		       48		      pha
   2421  240c		       d0 fb		      bne	clearmem
   2422  240e		       84 cb		      sty	temp1
   2423  2410				  -	      ifnconst	multisprite
   2424  2410				  -	      ifconst	pfrowheight
   2425  2410				  -	      lda	#pfrowheight
   2426  2410				  -	      else
   2427  2410				  -	      ifconst	pfres
   2428  2410				  -	      lda	#(96/pfres)
   2429  2410				  -	      else
   2430  2410				  -	      lda	#8
   2431  2410				  -	      endif
   2432  2410				  -	      endif
   2433  2410				  -	      sta	playfieldpos
   2434  2410					      endif
   2435  2410		       a2 05		      ldx	#5
   2436  2412				   initscore
   2437  2412		       a9 74		      lda	#<scoretable
   2438  2414		       95 c5		      sta	scorepointers,x
   2439  2416		       ca		      dex
   2440  2417		       10 f9		      bpl	initscore
   2441  2419		       a9 01		      lda	#1
   2442  241b		       85 0a		      sta	CTRLPF
   2443  241d		       0d 84 02 	      ora	INTIM
   2444  2420		       85 d6		      sta	rand
   2445  2422
   2446  2422					      ifconst	multisprite
   2447  2422		       20 1f f0 	      jsr	multisprite_setup
   2448  2425					      endif
   2449  2425
   2450  2425				  -	      ifnconst	bankswitch
   2451  2425				  -	      jmp	game
   2452  2425					      else
   2453  2425		       a9 cf		      lda	#>(game-1)
   2454  2427		       48		      pha
   2455  2428		       a9 ff		      lda	#<(game-1)
   2456  242a		       48		      pha
   2457  242b		       48		      pha
   2458  242c		       48		      pha
   2459  242d		       a2 01		      ldx	#1
   2460  242f		       4c eb ff 	      jmp	BS_jsr
   2461  2432					      endif
   2462  2432							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2463  2432
   2464  2432							;standard routines needed for pretty much all games
   2465  2432							; just the random number generator is left - maybe we should remove this asm file altogether?
   2466  2432							; repositioning code and score pointer setup moved to overscan
   2467  2432							; read switches, joysticks now compiler generated (more efficient)
   2468  2432
   2469  2432				   randomize
   2470  2432		       a5 d6		      lda	rand
   2471  2434		       4a		      lsr
   2472  2435				  -	      ifconst	rand16
   2473  2435				  -	      rol	rand16
   2474  2435					      endif
   2475  2435		       90 02		      bcc	noeor
   2476  2437		       49 b4		      eor	#$B4
   2477  2439				   noeor
   2478  2439		       85 d6		      sta	rand
   2479  243b				  -	      ifconst	rand16
   2480  243b				  -	      eor	rand16
   2481  243b					      endif
      0  243b					      RETURN
      1  243b				  -	      ifnconst	bankswitch
      2  243b				  -	      rts
      3  243b					      else
      4  243b		       4c dd ff 	      jmp	BS_return
      5  243e					      endif
   2483  243e							;bB.asm
   2484  243e							; bB.asm file is split here
   2485  243e				  -	      if	(<*) > (<(*+8))
   2486  243e				  -	      repeat	($100-<*)
   2487  243e				  -	      .byte	0
   2488  243e				  -	      repend
   2489  243e					      endif
   2490  243e					      if	(<*) < 90
   2491  243e					      repeat	(90-<*)
   2492  243e		       00		      .byte.b	0
   2491  243e					      repend
   2492  243f		       00		      .byte.b	0
   2491  243f					      repend
   2492  2440		       00		      .byte.b	0
   2491  2440					      repend
   2492  2441		       00		      .byte.b	0
   2491  2441					      repend
   2492  2442		       00		      .byte.b	0
   2491  2442					      repend
   2492  2443		       00		      .byte.b	0
   2491  2443					      repend
   2492  2444		       00		      .byte.b	0
   2491  2444					      repend
   2492  2445		       00		      .byte.b	0
   2491  2445					      repend
   2492  2446		       00		      .byte.b	0
   2491  2446					      repend
   2492  2447		       00		      .byte.b	0
   2491  2447					      repend
   2492  2448		       00		      .byte.b	0
   2491  2448					      repend
   2492  2449		       00		      .byte.b	0
   2491  2449					      repend
   2492  244a		       00		      .byte.b	0
   2491  244a					      repend
   2492  244b		       00		      .byte.b	0
   2491  244b					      repend
   2492  244c		       00		      .byte.b	0
   2491  244c					      repend
   2492  244d		       00		      .byte.b	0
   2491  244d					      repend
   2492  244e		       00		      .byte.b	0
   2491  244e					      repend
   2492  244f		       00		      .byte.b	0
   2491  244f					      repend
   2492  2450		       00		      .byte.b	0
   2491  2450					      repend
   2492  2451		       00		      .byte.b	0
   2491  2451					      repend
   2492  2452		       00		      .byte.b	0
   2491  2452					      repend
   2492  2453		       00		      .byte.b	0
   2491  2453					      repend
   2492  2454		       00		      .byte.b	0
   2491  2454					      repend
   2492  2455		       00		      .byte.b	0
   2491  2455					      repend
   2492  2456		       00		      .byte.b	0
   2491  2456					      repend
   2492  2457		       00		      .byte.b	0
   2491  2457					      repend
   2492  2458		       00		      .byte.b	0
   2491  2458					      repend
   2492  2459		       00		      .byte.b	0
   2493  245a					      repend
   2494  245a					      endif
   2495  245a				   player2then_0
   2496  245a		       00		      .byte.b	0
   2497  245b		       00		      .byte.b	%00000000
   2498  245c		       82		      .byte.b	%10000010
   2499  245d		       44		      .byte.b	%01000100
   2500  245e		       fe		      .byte.b	%11111110
   2501  245f		       fe		      .byte.b	%11111110
   2502  2460		       ba		      .byte.b	%10111010
   2503  2461		       7c		      .byte.b	%01111100
   2504  2462		       82		      .byte.b	%10000010
   2505  2463				  -	      if	(<*) > (<(*+8))
   2506  2463				  -	      repeat	($100-<*)
   2507  2463				  -	      .byte	0
   2508  2463				  -	      repend
   2509  2463					      endif
   2510  2463				  -	      if	(<*) < 90
   2511  2463				  -	      repeat	(90-<*)
   2512  2463				  -	      .byte	0
   2513  2463				  -	      repend
   2514  2463					      endif
   2515  2463				   player4then_0
   2516  2463		       00		      .byte.b	0
   2517  2464		       00		      .byte.b	%00000000
   2518  2465		       28		      .byte.b	%00101000
   2519  2466		       44		      .byte.b	%01000100
   2520  2467		       fe		      .byte.b	%11111110
   2521  2468		       fe		      .byte.b	%11111110
   2522  2469		       ba		      .byte.b	%10111010
   2523  246a		       7c		      .byte.b	%01111100
   2524  246b		       44		      .byte.b	%01000100
   2525  246c				  -	      if	(<*) > (<(*+7))
   2526  246c				  -	      repeat	($100-<*)
   2527  246c				  -	      .byte	0
   2528  246c				  -	      repend
   2529  246c					      endif
   2530  246c				  -	      if	(<*) < 90
   2531  246c				  -	      repeat	(90-<*)
   2532  246c				  -	      .byte	0
   2533  246c				  -	      repend
   2534  246c					      endif
   2535  246c				   playerL042_2
   2536  246c		       00		      .byte.b	%00000000
   2537  246d		       00		      .byte.b	%00000000
   2538  246e		       10		      .byte.b	%00010000
   2539  246f		       20		      .byte.b	%00100000
   2540  2470		       10		      .byte.b	%00010000
   2541  2471		       08		      .byte.b	%00001000
   2542  2472		       10		      .byte.b	%00010000
   2543  2473		       00		      .byte.b	%00000000
   2544  2474				  -	      if	(<*) > (<(*+8))
   2545  2474				  -	      repeat	($100-<*)
   2546  2474				  -	      .byte	0
   2547  2474				  -	      repend
   2548  2474					      endif
   2549  2474				  -	      if	(<*) < 90
   2550  2474				  -	      repeat	(90-<*)
   2551  2474				  -	      .byte	0
   2552  2474				  -	      repend
   2553  2474					      endif
   2554  2474				   player33then_0
   2555  2474		       00		      .byte.b	0
   2556  2475		       00		      .byte.b	%00000000
   2557  2476		       92		      .byte.b	%10010010
   2558  2477		       54		      .byte.b	%01010100
   2559  2478		       00		      .byte.b	%00000000
   2560  2479		       d6		      .byte.b	%11010110
   2561  247a		       00		      .byte.b	%00000000
   2562  247b		       54		      .byte.b	%01010100
   2563  247c		       92		      .byte.b	%10010010
   2564  247d				  -	      if	(<*) > (<(*+8))
   2565  247d				  -	      repeat	($100-<*)
   2566  247d				  -	      .byte	0
   2567  247d				  -	      repend
   2568  247d					      endif
   2569  247d				  -	      if	(<*) < 90
   2570  247d				  -	      repeat	(90-<*)
   2571  247d				  -	      .byte	0
   2572  247d				  -	      repend
   2573  247d					      endif
   2574  247d				   playerL056_0
   2575  247d		       00		      .byte.b	0
   2576  247e		       00		      .byte.b	%00000000
   2577  247f		       82		      .byte.b	%10000010
   2578  2480		       44		      .byte.b	%01000100
   2579  2481		       fe		      .byte.b	%11111110
   2580  2482		       fe		      .byte.b	%11111110
   2581  2483		       ba		      .byte.b	%10111010
   2582  2484		       7c		      .byte.b	%01111100
   2583  2485		       82		      .byte.b	%10000010
   2584  2486				  -	      if	(<*) > (<(*+7))
   2585  2486				  -	      repeat	($100-<*)
   2586  2486				  -	      .byte	0
   2587  2486				  -	      repend
   2588  2486					      endif
   2589  2486				  -	      if	(<*) < 90
   2590  2486				  -	      repeat	(90-<*)
   2591  2486				  -	      .byte	0
   2592  2486				  -	      repend
   2593  2486					      endif
   2594  2486				   playerL059_1
   2595  2486		       fe		      .byte.b	%11111110
   2596  2487		       fe		      .byte.b	%11111110
   2597  2488		       7c		      .byte.b	%01111100
   2598  2489		       10		      .byte.b	%00010000
   2599  248a		       00		      .byte.b	%00000000
   2600  248b		       00		      .byte.b	%00000000
   2601  248c		       00		      .byte.b	%00000000
   2602  248d		       00		      .byte.b	%00000000
   2603  248e				  -	      if	(<*) > (<(*+7))
   2604  248e				  -	      repeat	($100-<*)
   2605  248e				  -	      .byte	0
   2606  248e				  -	      repend
   2607  248e					      endif
   2608  248e				  -	      if	(<*) < 90
   2609  248e				  -	      repeat	(90-<*)
   2610  248e				  -	      .byte	0
   2611  248e				  -	      repend
   2612  248e					      endif
   2613  248e				   playerL065_3
   2614  248e		       00		      .byte.b	%00000000
   2615  248f		       00		      .byte.b	%00000000
   2616  2490		       00		      .byte.b	%00000000
   2617  2491		       10		      .byte.b	%00010000
   2618  2492		       10		      .byte.b	%00010000
   2619  2493		       00		      .byte.b	%00000000
   2620  2494		       00		      .byte.b	%00000000
   2621  2495		       00		      .byte.b	%00000000
   2622  2496				  -	      if	(<*) > (<(*+24))
   2623  2496				  -	      repeat	($100-<*)
   2624  2496				  -	      .byte	0
   2625  2496				  -	      repend
   2626  2496					      endif
   2627  2496				  -	      if	(<*) < 90
   2628  2496				  -	      repeat	(90-<*)
   2629  2496				  -	      .byte	0
   2630  2496				  -	      repend
   2631  2496					      endif
   2632  2496				   playerL073_2
   2633  2496		       00		      .byte.b	%00000000
   2634  2497		       00		      .byte.b	%00000000
   2635  2498		       00		      .byte.b	%00000000
   2636  2499		       00		      .byte.b	%00000000
   2637  249a		       00		      .byte.b	%00000000
   2638  249b		       f8		      .byte.b	%11111000
   2639  249c		       80		      .byte.b	%10000000
   2640  249d		       c0		      .byte.b	%11000000
   2641  249e		       80		      .byte.b	%10000000
   2642  249f		       f8		      .byte.b	%11111000
   2643  24a0		       00		      .byte.b	%00000000
   2644  24a1		       88		      .byte.b	%10001000
   2645  24a2		       88		      .byte.b	%10001000
   2646  24a3		       a8		      .byte.b	%10101000
   2647  24a4		       f8		      .byte.b	%11111000
   2648  24a5		       00		      .byte.b	%00000000
   2649  24a6		       88		      .byte.b	%10001000
   2650  24a7		       f8		      .byte.b	%11111000
   2651  24a8		       88		      .byte.b	%10001000
   2652  24a9		       f8		      .byte.b	%11111000
   2653  24aa		       00		      .byte.b	%00000000
   2654  24ab		       f8		      .byte.b	%11111000
   2655  24ac		       88		      .byte.b	%10001000
   2656  24ad		       80		      .byte.b	%10000000
   2657  24ae		       f8		      .byte.b	%11111000
   2658  24af				  -	      if	(<*) > (<(*+24))
   2659  24af				  -	      repeat	($100-<*)
   2660  24af				  -	      .byte	0
   2661  24af				  -	      repend
   2662  24af					      endif
   2663  24af				  -	      if	(<*) < 90
   2664  24af				  -	      repeat	(90-<*)
   2665  24af				  -	      .byte	0
   2666  24af				  -	      repend
   2667  24af					      endif
   2668  24af				   playerL074_3
   2669  24af		       00		      .byte.b	%00000000
   2670  24b0		       00		      .byte.b	%00000000
   2671  24b1		       00		      .byte.b	%00000000
   2672  24b2		       00		      .byte.b	%00000000
   2673  24b3		       00		      .byte.b	%00000000
   2674  24b4		       88		      .byte.b	%10001000
   2675  24b5		       f0		      .byte.b	%11110000
   2676  24b6		       88		      .byte.b	%10001000
   2677  24b7		       f8		      .byte.b	%11111000
   2678  24b8		       00		      .byte.b	%00000000
   2679  24b9		       f8		      .byte.b	%11111000
   2680  24ba		       80		      .byte.b	%10000000
   2681  24bb		       c0		      .byte.b	%11000000
   2682  24bc		       80		      .byte.b	%10000000
   2683  24bd		       f8		      .byte.b	%11111000
   2684  24be		       00		      .byte.b	%00000000
   2685  24bf		       20		      .byte.b	%00100000
   2686  24c0		       50		      .byte.b	%01010000
   2687  24c1		       88		      .byte.b	%10001000
   2688  24c2		       88		      .byte.b	%10001000
   2689  24c3		       00		      .byte.b	%00000000
   2690  24c4		       f8		      .byte.b	%11111000
   2691  24c5		       88		      .byte.b	%10001000
   2692  24c6		       88		      .byte.b	%10001000
   2693  24c7		       f8		      .byte.b	%11111000
   2694  24c8					      if	ECHOFIRST
      2732 bytes of ROM space left in bank 2
   2695  24c8					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   2696  24c8					      endif
   2697  24c8		       00 01	   ECHOFIRST  =	1
   2698  24c8
   2699  24c8
   2700  24c8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2701  24c8
   2702  24c8							; feel free to modify the score graphics - just keep each digit 8 high
   2703  24c8							; and keep the conditional compilation stuff intact
   2704  24c8				  -	      ifconst	ROM2k
   2705  24c8				  -	      ORG	$F7AC-8
   2706  24c8					      else
   2707  24c8					      ifconst	bankswitch
   2708  24c8					      if	bankswitch == 8
   2709  2f74					      ORG	$2F94-bscode_length
   2710  2f74					      RORG	$FF94-bscode_length
   2711  2f74					      endif
   2712  2f74				  -	      if	bankswitch == 16
   2713  2f74				  -	      ORG	$4F94-bscode_length
   2714  2f74				  -	      RORG	$FF94-bscode_length
   2715  2f74					      endif
   2716  2f74				  -	      if	bankswitch == 32
   2717  2f74				  -	      ORG	$8F94-bscode_length
   2718  2f74				  -	      RORG	$FF94-bscode_length
   2719  2f74					      endif
   2720  2f74				  -	      if	bankswitch == 64
   2721  2f74				  -	      ORG	$10F80-bscode_length
   2722  2f74				  -	      RORG	$1FF80-bscode_length
   2723  2f74					      endif
   2724  2f74				  -	      else
   2725  2f74				  -	      ORG	$FF9C
   2726  2f74					      endif
   2727  2f74					      endif
   2728  2f74
   2729  2f74							; font equates
   2730  2f74		       00 01	   .21stcentury =	1
   2731  2f74		       00 02	   alarmclock =	2
   2732  2f74		       00 03	   handwritten =	3
   2733  2f74		       00 04	   interrupted =	4
   2734  2f74		       00 05	   retroputer =	5
   2735  2f74		       00 06	   whimsey    =	6
   2736  2f74		       00 07	   tiny       =	7
   2737  2f74		       00 08	   hex	      =	8
   2738  2f74
   2739  2f74				  -	      ifconst	font
   2740  2f74				  -	      if	font == hex
   2741  2f74				  -	      ORG	. - 48
   2742  2f74				  -	      endif
   2743  2f74					      endif
   2744  2f74
   2745  2f74				   scoretable
   2746  2f74
   2747  2f74				  -	      ifconst	font
   2748  2f74				  -	      if	font == .21stcentury
   2749  2f74				  -	      include	"score_graphics.asm.21stcentury"
   2750  2f74				  -	      endif
   2751  2f74				  -	      if	font == alarmclock
   2752  2f74				  -	      include	"score_graphics.asm.alarmclock"
   2753  2f74				  -	      endif
   2754  2f74				  -	      if	font == handwritten
   2755  2f74				  -	      include	"score_graphics.asm.handwritten"
   2756  2f74				  -	      endif
   2757  2f74				  -	      if	font == interrupted
   2758  2f74				  -	      include	"score_graphics.asm.interrupted"
   2759  2f74				  -	      endif
   2760  2f74				  -	      if	font == retroputer
   2761  2f74				  -	      include	"score_graphics.asm.retroputer"
   2762  2f74				  -	      endif
   2763  2f74				  -	      if	font == whimsey
   2764  2f74				  -	      include	"score_graphics.asm.whimsey"
   2765  2f74				  -	      endif
   2766  2f74				  -	      if	font == tiny
   2767  2f74				  -	      include	"score_graphics.asm.tiny"
   2768  2f74				  -	      endif
   2769  2f74				  -	      if	font == hex
   2770  2f74				  -	      include	"score_graphics.asm.hex"
   2771  2f74				  -	      endif
   2772  2f74					      else		; default font
   2773  2f74
   2774  2f74		       3c		      .byte.b	%00111100
   2775  2f75		       66		      .byte.b	%01100110
   2776  2f76		       66		      .byte.b	%01100110
   2777  2f77		       66		      .byte.b	%01100110
   2778  2f78		       66		      .byte.b	%01100110
   2779  2f79		       66		      .byte.b	%01100110
   2780  2f7a		       66		      .byte.b	%01100110
   2781  2f7b		       3c		      .byte.b	%00111100
   2782  2f7c
   2783  2f7c		       7e		      .byte.b	%01111110
   2784  2f7d		       18		      .byte.b	%00011000
   2785  2f7e		       18		      .byte.b	%00011000
   2786  2f7f		       18		      .byte.b	%00011000
   2787  2f80		       18		      .byte.b	%00011000
   2788  2f81		       38		      .byte.b	%00111000
   2789  2f82		       18		      .byte.b	%00011000
   2790  2f83		       08		      .byte.b	%00001000
   2791  2f84
   2792  2f84		       7e		      .byte.b	%01111110
   2793  2f85		       60		      .byte.b	%01100000
   2794  2f86		       60		      .byte.b	%01100000
   2795  2f87		       3c		      .byte.b	%00111100
   2796  2f88		       06		      .byte.b	%00000110
   2797  2f89		       06		      .byte.b	%00000110
   2798  2f8a		       46		      .byte.b	%01000110
   2799  2f8b		       3c		      .byte.b	%00111100
   2800  2f8c
   2801  2f8c		       3c		      .byte.b	%00111100
   2802  2f8d		       46		      .byte.b	%01000110
   2803  2f8e		       06		      .byte.b	%00000110
   2804  2f8f		       06		      .byte.b	%00000110
   2805  2f90		       1c		      .byte.b	%00011100
   2806  2f91		       06		      .byte.b	%00000110
   2807  2f92		       46		      .byte.b	%01000110
   2808  2f93		       3c		      .byte.b	%00111100
   2809  2f94
   2810  2f94		       0c		      .byte.b	%00001100
   2811  2f95		       0c		      .byte.b	%00001100
   2812  2f96		       7e		      .byte.b	%01111110
   2813  2f97		       4c		      .byte.b	%01001100
   2814  2f98		       4c		      .byte.b	%01001100
   2815  2f99		       2c		      .byte.b	%00101100
   2816  2f9a		       1c		      .byte.b	%00011100
   2817  2f9b		       0c		      .byte.b	%00001100
   2818  2f9c
   2819  2f9c		       3c		      .byte.b	%00111100
   2820  2f9d		       46		      .byte.b	%01000110
   2821  2f9e		       06		      .byte.b	%00000110
   2822  2f9f		       06		      .byte.b	%00000110
   2823  2fa0		       3c		      .byte.b	%00111100
   2824  2fa1		       60		      .byte.b	%01100000
   2825  2fa2		       60		      .byte.b	%01100000
   2826  2fa3		       7e		      .byte.b	%01111110
   2827  2fa4
   2828  2fa4		       3c		      .byte.b	%00111100
   2829  2fa5		       66		      .byte.b	%01100110
   2830  2fa6		       66		      .byte.b	%01100110
   2831  2fa7		       66		      .byte.b	%01100110
   2832  2fa8		       7c		      .byte.b	%01111100
   2833  2fa9		       60		      .byte.b	%01100000
   2834  2faa		       62		      .byte.b	%01100010
   2835  2fab		       3c		      .byte.b	%00111100
   2836  2fac
   2837  2fac		       30		      .byte.b	%00110000
   2838  2fad		       30		      .byte.b	%00110000
   2839  2fae		       30		      .byte.b	%00110000
   2840  2faf		       18		      .byte.b	%00011000
   2841  2fb0		       0c		      .byte.b	%00001100
   2842  2fb1		       06		      .byte.b	%00000110
   2843  2fb2		       42		      .byte.b	%01000010
   2844  2fb3		       3e		      .byte.b	%00111110
   2845  2fb4
   2846  2fb4		       3c		      .byte.b	%00111100
   2847  2fb5		       66		      .byte.b	%01100110
   2848  2fb6		       66		      .byte.b	%01100110
   2849  2fb7		       66		      .byte.b	%01100110
   2850  2fb8		       3c		      .byte.b	%00111100
   2851  2fb9		       66		      .byte.b	%01100110
   2852  2fba		       66		      .byte.b	%01100110
   2853  2fbb		       3c		      .byte.b	%00111100
   2854  2fbc
   2855  2fbc		       3c		      .byte.b	%00111100
   2856  2fbd		       46		      .byte.b	%01000110
   2857  2fbe		       06		      .byte.b	%00000110
   2858  2fbf		       3e		      .byte.b	%00111110
   2859  2fc0		       66		      .byte.b	%01100110
   2860  2fc1		       66		      .byte.b	%01100110
   2861  2fc2		       66		      .byte.b	%01100110
   2862  2fc3		       3c		      .byte.b	%00111100
   2863  2fc4
   2864  2fc4					      ifnconst	DPC_kernel_options
   2865  2fc4
   2866  2fc4		       00		      .byte.b	%00000000
   2867  2fc5		       00		      .byte.b	%00000000
   2868  2fc6		       00		      .byte.b	%00000000
   2869  2fc7		       00		      .byte.b	%00000000
   2870  2fc8		       00		      .byte.b	%00000000
   2871  2fc9		       00		      .byte.b	%00000000
   2872  2fca		       00		      .byte.b	%00000000
   2873  2fcb		       00		      .byte.b	%00000000
   2874  2fcc
   2875  2fcc					      endif
   2876  2fcc
   2877  2fcc					      endif
   2878  2fcc
   2879  2fcc				  -	      ifconst	ROM2k
   2880  2fcc				  -	      ORG	$F7FC
   2881  2fcc					      else
   2882  2fcc					      ifconst	bankswitch
   2883  2fcc					      if	bankswitch == 8
   2884  2fd4					      ORG	$2FF4-bscode_length
   2885  2fd4					      RORG	$FFF4-bscode_length
   2886  2fd4					      endif
   2887  2fd4				  -	      if	bankswitch == 16
   2888  2fd4				  -	      ORG	$4FF4-bscode_length
   2889  2fd4				  -	      RORG	$FFF4-bscode_length
   2890  2fd4					      endif
   2891  2fd4				  -	      if	bankswitch == 32
   2892  2fd4				  -	      ORG	$8FF4-bscode_length
   2893  2fd4				  -	      RORG	$FFF4-bscode_length
   2894  2fd4					      endif
   2895  2fd4				  -	      if	bankswitch == 64
   2896  2fd4				  -	      ORG	$10FE0-bscode_length
   2897  2fd4				  -	      RORG	$1FFE0-bscode_length
   2898  2fd4					      endif
   2899  2fd4				  -	      else
   2900  2fd4				  -	      ORG	$FFFC
   2901  2fd4					      endif
   2902  2fd4					      endif
   2903  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2904  2fd4
   2905  2fd4							; every bank has this stuff at the same place
   2906  2fd4							; this code can switch to/from any bank at any entry point
   2907  2fd4							; and can preserve register values
   2908  2fd4							; note: lines not starting with a space are not placed in all banks
   2909  2fd4							;
   2910  2fd4							; line below tells the compiler how long this is - do not remove
   2911  2fd4							;size=32
   2912  2fd4
   2913  2fd4				   begin_bscode
   2914  2fd4		       a2 ff		      ldx	#$ff
   2915  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   2916  2fd6				  -	      stx	FASTFETCH
   2917  2fd6					      endif
   2918  2fd6		       9a		      txs
   2919  2fd7				  -	      if	bankswitch == 64
   2920  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2921  2fd7					      else
   2922  2fd7		       a9 f3		      lda	#>(start-1)
   2923  2fd9					      endif
   2924  2fd9		       48		      pha
   2925  2fda		       a9 f4		      lda	#<(start-1)
   2926  2fdc		       48		      pha
   2927  2fdd
   2928  2fdd				   BS_return
   2929  2fdd		       48		      pha
   2930  2fde		       8a		      txa
   2931  2fdf		       48		      pha
   2932  2fe0		       ba		      tsx
   2933  2fe1
   2934  2fe1					      if	bankswitch != 64
   2935  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   2936  2fe3
   2937  2fe3		       2a		      rol
   2938  2fe4		       2a		      rol
   2939  2fe5		       2a		      rol
   2940  2fe6		       2a		      rol
   2941  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2942  2fe9		       aa		      tax
   2943  2fea		       e8		      inx
   2944  2feb				  -	      else
   2945  2feb				  -	      lda	4,x	; get high byte of return address
   2946  2feb				  -	      tay
   2947  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2948  2feb				  -	      sta	4,x
   2949  2feb				  -	      tya
   2950  2feb				  -	      lsr
   2951  2feb				  -	      lsr
   2952  2feb				  -	      lsr
   2953  2feb				  -	      lsr
   2954  2feb				  -	      tax
   2955  2feb				  -	      inx
   2956  2feb					      endif
   2957  2feb
   2958  2feb				   BS_jsr
   2959  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   2960  2fee		       68		      pla
   2961  2fef		       aa		      tax
   2962  2ff0		       68		      pla
   2963  2ff1		       60		      rts
   2964  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2965  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2966  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2967  2ff2					      endif
   2968  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2969  2ff2
   2970  2ff2					      ifconst	bankswitch
   2971  2ff2					      if	bankswitch == 8
   2972  2ffc					      ORG	$2FFC
   2973  2ffc					      RORG	$FFFC
   2974  2ffc					      endif
   2975  2ffc				  -	      if	bankswitch == 16
   2976  2ffc				  -	      ORG	$4FFC
   2977  2ffc				  -	      RORG	$FFFC
   2978  2ffc					      endif
   2979  2ffc				  -	      if	bankswitch == 32
   2980  2ffc				  -	      ORG	$8FFC
   2981  2ffc				  -	      RORG	$FFFC
   2982  2ffc					      endif
   2983  2ffc				  -	      if	bankswitch == 64
   2984  2ffc				  -	      ORG	$10FF0
   2985  2ffc				  -	      RORG	$1FFF0
   2986  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   2987  2ffc				  -	      ORG	$10FF8
   2988  2ffc				  -	      RORG	$1FFF8
   2989  2ffc				  -	      ifconst	superchip
   2990  2ffc				  -	      .byte	"E","F","S","C"
   2991  2ffc				  -	      else
   2992  2ffc				  -	      .byte	"E","F","E","F"
   2993  2ffc				  -	      endif
   2994  2ffc				  -	      ORG	$10FFC
   2995  2ffc				  -	      RORG	$1FFFC
   2996  2ffc					      endif
   2997  2ffc				  -	      else
   2998  2ffc				  -	      ifconst	ROM2k
   2999  2ffc				  -	      ORG	$F7FC
   3000  2ffc				  -	      else
   3001  2ffc				  -	      ORG	$FFFC
   3002  2ffc				  -	      endif
   3003  2ffc					      endif
   3004  2ffc		       f5 f3		      .word.w	(start & $ffff)
   3005  2ffe		       f5 f3		      .word.w	(start & $ffff)
